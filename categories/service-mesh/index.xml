<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Service Mesh on TechBlog about OpenShift/Ansible/Satellite and much more</title><link>https://blog.stderr.at/categories/service-mesh/</link><description>TechBlog about OpenShift/Ansible/Satellite and much more</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Toni Schmidbauer &amp; Thomas Jungbauer</copyright><lastBuildDate>Wed, 13 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stderr.at/categories/service-mesh/index.xml" rel="self" type="application/rss+xml"/><item><title>Enable Automatic Route Creation</title><link>https://blog.stderr.at/service-mesh/2020/05/enable-automatic-route-creation/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/05/enable-automatic-route-creation/</guid><description>&lt;div class="paragraph">
&lt;p>Red Hat Service Mesh 1.1 allows you to enable a &amp;#34;&lt;strong>Automatic Route Creation&lt;/strong>&amp;#34; which will take care about the routes for a specific Gateway. Instead of defining * for hosts, a list of domains can be defined. The Istio OpenShift Routing (ior) synchronizes the routes and creates them inside the Istio namespace. If a Gateway is deleted, the routes will also be removed again.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This new features makes the manual creation of the route obsolete, as it was explained here: &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/">Openshift 4 and Service Mesh 4 - Ingress with custom domain&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_enable_automatic_route_creation">Enable Automatic Route Creation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before this feature can be used, it must be enabled. To do so the &lt;strong>ServiceMeshContolPlace&lt;/strong>, typically found in the namespace &lt;em>istio-system&lt;/em> must be modified.
Add the line &lt;strong>ior_enabled: true&lt;/strong> to the &lt;em>istio-ingressgate&lt;/em> configuration.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">...
spec:
istio:
gateways:
istio-egressgateway:
autoscaleEnabled: false
istio-ingressgateway:
autoscaleEnabled: false
ior_enabled: true
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_current_service">Verify current service&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Let’s check our &lt;em>tutorial&lt;/em> application, if it is still working.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc project tutorial
export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
curl $GATEWAY_URL/customer
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 30&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s review and remove the current used Gateway. As you can see the hosts is set to &amp;#39;*&amp;#39;&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">oc get istio-io
oc get gateway.networking.istio.io/customer-gateway -o yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
annotations:
kubectl.kubernetes.io/last-applied-configuration: |
{&amp;#34;apiVersion&amp;#34;:&amp;#34;networking.istio.io/v1alpha3&amp;#34;,&amp;#34;kind&amp;#34;:&amp;#34;Gateway&amp;#34;,&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{},&amp;#34;name&amp;#34;:&amp;#34;customer-gateway&amp;#34;,&amp;#34;namespace&amp;#34;:&amp;#34;tutorial&amp;#34;},&amp;#34;spec&amp;#34;:{&amp;#34;selector&amp;#34;:{&amp;#34;istio&amp;#34;:&amp;#34;ingressgateway&amp;#34;},&amp;#34;servers&amp;#34;:[{&amp;#34;hosts&amp;#34;:[&amp;#34;*&amp;#34;],&amp;#34;port&amp;#34;:{&amp;#34;name&amp;#34;:&amp;#34;http&amp;#34;,&amp;#34;number&amp;#34;:80,&amp;#34;protocol&amp;#34;:&amp;#34;HTTP&amp;#34;}}]}}
creationTimestamp: &amp;#34;2020-05-13T07:52:20Z&amp;#34;
generation: 1
name: customer-gateway
namespace: tutorial
resourceVersion: &amp;#34;41370056&amp;#34;
selfLink: /apis/networking.istio.io/v1alpha3/namespaces/tutorial/gateways/customer-gateway
uid: 96e82ed9-e870-493c-941f-bfa83c892b94
spec:
selector:
istio: ingressgateway
servers:
- hosts:
- &amp;#39;*&amp;#39;
port:
name: http
number: 80
protocol: HTTP&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_a_new_gateway">Create a new Gateway&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>First let’s remove the current Gateway&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bach" data-lang="bach">oc delete gateway.networking.istio.io/customer-gateway&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now lets create a new Gateway, but this time we define some names for the hosts section:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; Gateway-ior.yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: customer-gateway
spec:
selector:
istio: ingressgateway
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- www.example.com
- svc.example.com
EOF
oc apply -f Gateway-ior.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>When you now check the routes, 2 new routes have been added:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get routes -n istio-system
NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD
...
tutorial-customer-gateway-kmqrl www.example.com istio-ingressgateway http2 None
tutorial-customer-gateway-ks7q7 svc.example.com istio-ingressgateway http2 None&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To test the connectivity, you need to be sure that the hosts, used in the Gateway, are resolvable.
If they are then you can access your service:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl www.example.com/customer
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 31
curl svc.example.com/customer
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 32&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Authorization (RBAC)</title><link>https://blog.stderr.at/service-mesh/2020/05/authorization-rbac/</link><pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/05/authorization-rbac/</guid><description>&lt;div class="paragraph">
&lt;p>Per default all requests inside a Service Mesh are allowed, which can be a problem security-wise.
To solve this, authorization, which verifies if the user is allowed to perform a certain action, is required.
Istio’s authorization provides access control on mesh-level, namespace-level and workload-level.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With the resource &lt;strong>AuthorizationPolicy&lt;/strong> granular policies can be defined.
These policies are loaded to and verified by the Envoy Proxy which then authorizes a request.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_implicit_enablement">Implicit enablement&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To enable authorization the only thing you need is to do is to define the &lt;strong>AuthorizationPolicy&lt;/strong>. If the resource is not defined, then no access control will be used, instead any traffic is allowed. If &lt;strong>AuthorizationPolicy&lt;/strong> is applied to a workload, then by default any traffic is denied unless it is explicitly allowed.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
This is applicable to Service Mesh version 1.1+
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparing_environment">Preparing Environment&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The following steps will configure an example Role Based Access Control (RBAC). It will start from scratch. If you just want to quickly configure the authorization and have anything else in place, you can start form here: &lt;a href="#_configure_authentication_policy">Configure Authentication Policy&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create a new project&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc new-project tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Be sure that a Service Mesh Member Roll exists for this new project&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; memberroll.yaml
apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
name: default
spec:
members:
- tutorial
EOF
oc apply -f memberroll.yaml -n istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Clone and install the example application&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/redhat-developer-demos/istio-tutorial/ istio-tutorial
oc apply -f istio-tutorial/customer/kubernetes/Deployment.yml -n tutorial
oc apply -f istio-tutorial/customer/kubernetes/Service.yml -n tutorial
oc expose service customer
oc apply -f istio-tutorial/preference/kubernetes/Deployment.yml -n tutorial
oc apply -f istio-tutorial/preference/kubernetes/Service.yml -n tutorial
oc apply -f istio-tutorial/recommendation/kubernetes/Deployment.yml -n tutorial
oc apply -f istio-tutorial/recommendation/kubernetes/Service.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Wait until all pods are running. There should be 2 containers for all pods:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create Gateway and VirtualService&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; Gateway_VirtualService.yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: customer-gateway
spec:
selector:
istio: ingressgateway # use istio default controller
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- &amp;#34;*&amp;#34;
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: customer-gateway
spec:
hosts:
- &amp;#34;*&amp;#34;
gateways:
- customer-gateway
http:
- match:
- uri:
prefix: /customer
rewrite:
uri: /
route:
- destination:
host: customer
port:
number: 8080
EOF
oc apply -f Gateway_VirtualService.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Verify if the application is working
You can either use the run.sh from previous tutorials, or simply try the following curl&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;); echo $GATEWAY_URL
curl $GATEWAY_URL/customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This should return the following line:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Optionally check the connection from inside the customer container&lt;/p>
&lt;div class="paragraph">
&lt;p>get pods name and enter it:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods
NAME READY STATUS RESTARTS AGE
customer-6948b8b959-dhsm9 2/2 Running 0 177m
preference-v1-7fdb89c86b-dvzs9 2/2 Running 0 177m
recommendation-v1-69db8d6c48-cjcpn 2/2 Running 0 177m&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Connect into the container pod and try to reach the different microservices&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc rsh customer-6948b8b959-dhsm9
sh-4.4$ curl customer:8080
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 2
sh-4.4$ curl preference:8080
preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3
sh-4.4$ curl recommendation:8080
recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 4&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_configure_authentication_policy">Configure Authentication Policy&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Enabling User-End authentication&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; authentication-policy.yaml
apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;customerjwt&amp;#34;
spec:
targets:
- name: customer
- name: preference
- name: recommendation
origins:
- jwt:
issuer: &amp;#34;testing@secure.istio.io&amp;#34;
jwksUri: &amp;#34;https://gist.githubusercontent.com/lordofthejars/7dad589384612d7a6e18398ac0f10065/raw/ea0f8e7b729fb1df25d4dc60bf17dee409aad204/jwks.json&amp;#34;
principalBinding: USE_ORIGIN
EOF
oc apply -f authentication-policy.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Access should be denied after a few seconds&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl $GATEWAY_URL/customer
Origin authentication failed.%&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Use token to authenticate&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">token=$(curl https://gist.githubusercontent.com/lordofthejars/a02485d70c99eba70980e0a92b2c97ed/raw/f16b938464b01a2e721567217f672f11dc4ef565/token.simple.jwt -s)
curl -H &amp;#34;Authorization: Bearer $token&amp;#34; $GATEWAY_URL/customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will result in a correct response&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 5&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_configure_role_based_access_control_rbac">Configure Role Based Access Control (RBAC)&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create the resource &lt;strong>AuthorizationPolicy&lt;/strong>&lt;/p>
&lt;div class="paragraph">
&lt;p>This is a new resources, supported since Service Mesh 1.1. It will allow GET method when the role equals to &amp;#34;&lt;em>customer&lt;/em>&amp;#34;&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; AuthorizationPolicy.yaml
apiVersion: &amp;#34;security.istio.io/v1beta1&amp;#34;
kind: &amp;#34;AuthorizationPolicy&amp;#34;
metadata:
name: &amp;#34;customer&amp;#34;
spec:
rules:
- to:
- operation:
methods: [&amp;#34;GET&amp;#34;]
when:
- key: request.auth.claims[role]
values: [&amp;#34;customer&amp;#34;]
EOF
oc apply -f AuthorizationPolicy.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Get a token for the role and retry to connect to the service,&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">token=$(curl https://gist.githubusercontent.com/lordofthejars/f590c80b8d83ea1244febb2c73954739/raw/21ec0ba0184726444d99018761cf0cd0ece35971/token.role.jwt -s)
curl -H &amp;#34;Authorization: Bearer $token&amp;#34; $GATEWAY_URL/customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This results in:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 8&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Let’s verify the setting and change the AuthorizationPolicy.
This will break the authorization, since the token provides roles=customer and we set the Policy to &amp;#34;whereistherole&amp;#34;&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; AuthorizationPolicy-Hack.yaml
apiVersion: &amp;#34;security.istio.io/v1beta1&amp;#34;
kind: &amp;#34;AuthorizationPolicy&amp;#34;
metadata:
name: &amp;#34;customer&amp;#34;
spec:
rules:
- to:
- operation:
methods: [&amp;#34;GET&amp;#34;]
when:
- key: request.auth.claims[role]
values: [&amp;#34;whereistherole&amp;#34;]
EOF
oc replace -f AuthorizationPolicy-Hack.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now try to access the service, with the token, which provides &amp;#34;customer&amp;#34; as role, it will lead to an error:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">token=$(curl https://gist.githubusercontent.com/lordofthejars/f590c80b8d83ea1244febb2c73954739/raw/21ec0ba0184726444d99018761cf0cd0ece35971/token.role.jwt -s)
curl -H &amp;#34;Authorization: Bearer $token&amp;#34; $GATEWAY_URL/customer
RBAC: access denied&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Deploy Example Bookinfo Application</title><link>https://blog.stderr.at/service-mesh/2020/04/deploy-example-bookinfo-application/</link><pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/deploy-example-bookinfo-application/</guid><description>&lt;div class="paragraph">
&lt;p>To test a second application, a bookinfo application shall be deployed as an example.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following section finds it’s origin at:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://istio.io/docs/examples/bookinfo/" target="_blank" rel="noopener">Istio - Bookinfo Application&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/service_mesh_day_two/ossm-example-bookinfo.html" target="_blank" rel="noopener">OpenShift 4 - Example Application&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="listingblock quote">
&lt;div class="content">
&lt;pre>The Bookinfo application displays information about a book, similar to a single catalog entry of an online book store.
Displayed on the page is a description of the book, book details (ISBN, number of pages, and other information), and book reviews.
The Bookinfo application consists of these microservices:
* The productpage microservice calls the details and reviews microservices to populate the page.
* The details microservice contains book information.
* The reviews microservice contains book reviews. It also calls the ratings microservice.
* The ratings microservice contains book ranking information that accompanies a book review.
There are three versions of the reviews microservice:
* Version v1 does not call the ratings Service.
* Version v2 calls the ratings Service and displays each rating as one to five black stars.
* Version v3 calls the ratings Service and displays each rating as one to five red stars.
The end-to-end architecture of the application is shown below.&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/bookinfo.png?width=640px" alt="bookinfo"/>
&lt;/div>
&lt;div class="title">Figure 1. Bookinfo Application End2End Overview&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To use the bookinfo application inside service mesh, no code changes are required. Instead an Envoy proxy is added as a sidecar container to all containers (product, review, details) which intercepts the traffic.&lt;/p>
&lt;/div>
&lt;hr/>
&lt;!-- toc disabled -->
&lt;div class="sect1">
&lt;h2 id="_installation">Installation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Let’s start right away:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create a new project&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc new-project bookinfo&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Add the new project to our Service Mesh&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
name: default
namespace: bookinfo
spec:
controlPlaneRef:
name: basic-install
namespace: istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create the application&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/platform/kube/bookinfo.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create the Gateway and the VirtuaService&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/bookinfo-gateway.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Check if the services and pods are up and running&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get svc,pods
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
service/details ClusterIP 172.30.178.172 &amp;lt;none&amp;gt; 9080/TCP 7m16s
service/productpage ClusterIP 172.30.78.96 &amp;lt;none&amp;gt; 9080/TCP 7m13s
service/ratings ClusterIP 172.30.154.12 &amp;lt;none&amp;gt; 9080/TCP 7m15s
service/reviews ClusterIP 172.30.138.174 &amp;lt;none&amp;gt; 9080/TCP 7m14s
NAME READY STATUS RESTARTS AGE
pod/details-v1-d7db4d55b-mwzsk 2/2 Running 0 7m14s
pod/productpage-v1-5f598fbbf4-svkbc 2/2 Running 0 7m11s
pod/ratings-v1-85957d89d8-v2lrs 2/2 Running 0 7m11s
pod/reviews-v1-67d9b4bcc-x6s2v 2/2 Running 0 7m11s
pod/reviews-v2-67b465c497-zpz6z 2/2 Running 0 7m11s
pod/reviews-v3-7bd659b757-j6rwn 2/2 Running 0 7m11s&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_that_application_is_accessible">Verify that application is accessible&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Export the Gateway URL into a variable&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Verify if the productpage is accessible&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl -s http://${GATEWAY_URL}/productpage | grep -o &amp;#34;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&amp;#34;
&amp;lt;title&amp;gt;Simple Bookstore App&amp;lt;/title&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>You can also access the Productpage in your browser. When you reload the page several times, you will see different results for the Reviews. This comes due to 3 different versions: one without any rating, one with black stars and one with red stars. &lt;a href="http://${GATEWAY_URL}/productpage" class="bare">http://${GATEWAY_URL}/productpage&lt;/a>&lt;/p>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/bookinfo-productpage.png?width=940px" alt="bookinfo productpage"/>
&lt;/div>
&lt;div class="title">Figure 2. Bookinfo Application&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_adding_default_destination_rule">Adding default Destination Rule&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/destination-rule-all-mtls.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will add default routing to all endpoints with same weight. As you can see in Kiali, the &lt;em>Reviews&lt;/em> microservice is contacted equally.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/bookinfo-kiali.png?width=940px" alt="bookinfo kiali"/>
&lt;/div>
&lt;div class="title">Figure 3. Kiali: Bookinfo Application&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Feel free to play with other DestinationRules to controll your traffic.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Service Mesh 1.1 released</title><link>https://blog.stderr.at/service-mesh/2020/04/service-mesh-1.1-released/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/service-mesh-1.1-released/</guid><description>&lt;div class="paragraph">
&lt;p>April 10th 2020 Red Hat released Service Mesh version 1.1 which supports the following versions:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Istio - 1.4.6&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kiali - 1.12.7&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Jaeger - 1.17.1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_update">Update&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To update an operator like Service Mesh, the Operator Life Cycle Manager takes care and automatically updates everything (unless it was configured differently).&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For the Service Mesh 1.1 update consult &lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/service_mesh_install/updating-ossm.html" target="_blank" rel="noopener">Upgrading Red Hat OpenShift Service Mesh&lt;/a>&lt;br/>
It is important to add the version number to the ServiceMeshControlPlane object. The easiest way to do so is:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Log into OpenShift&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select the Namespace &lt;em>istio-system&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Goto _&amp;#34;Installed Operators &amp;gt; Red Hat OpenShift Service Mesh &amp;gt; ServiceMeshControlPlanes &amp;gt; basic-install &amp;gt; YAML&amp;#34;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Under spec add the following:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">spec:
version: v1.1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_notable_changes">Notable Changes&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_servicemeshmember_object">ServiceMeshMember Object&lt;/h3>
&lt;div class="paragraph">
&lt;p>With the ServiceMeshMember object it is now possible that a project administrator can add a service to the service mesh, instead relying on the cluster administrator to configure the ServiceMeshMemberRoll.
To do so create the following object (i.e. under the namespace &lt;em>tutorial&lt;/em>)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
name: default
namespace: tutorial
spec:
controlPlaneRef:
name: basic-install &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: istio-system &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the ServiceMeshControlPlane object&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>name of the service mesh namespace&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Authentication JWT</title><link>https://blog.stderr.at/service-mesh/2020/04/authentication-jwt/</link><pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/authentication-jwt/</guid><description>&lt;div class="paragraph">
&lt;p>Welcome to tutorial 10 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong>, where we will discuss authentication with JWT.
JSON Web Token (JWT) is an open standard that allows to transmit information between two parties securely as a JSON object. It is an authentication token, which is verified and signed and therefore trusted. The signing can be achieved by using a secret or a public/private key pair.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Service Mesh can be used to configure a policy which enables JWT for your services.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparation">Preparation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Be sure that you have at least the Gateway and VirtualService configured:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get istio-io -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Which should return the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME AGE
gateway.networking.istio.io/ingress-gateway-exampleapp 45h
NAME HOST AGE
destinationrule.networking.istio.io/recommendation recommendation 29h
NAME GATEWAYS HOSTS AGE
virtualservice.networking.istio.io/ingress-gateway-exampleapp [ingress-gateway-exampleapp] [*] 45h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Run some texample traffic, to be sure that our application is still working as expected&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 31622
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 33056
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 31623
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 33057
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 31624
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 33058&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_enabling_end_user_authentication">Enabling End-User Authentication&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To test this feature we will need a valid token (JWT). More details can be found at the &lt;a href="https://istio.io/docs/tasks/security/authentication/authn-policy/#end-user-authentication" target="_blank" rel="noopener">Istio example&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All we need to create a Policy object&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;jwt-example&amp;#34;
spec:
targets:
- name: customer
origins:
- jwt:
issuer: &amp;#34;testing@secure.istio.io&amp;#34;
jwksUri: &amp;#34;https://raw.githubusercontent.com/istio/istio/release-1.2/security/tools/jwt/samples/jwks.json&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
principalBinding: USE_ORIGIN&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Path to test a public key&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds the requests will fail with an &amp;#34;authentication failed&amp;#34; error:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: Origin authentication failed.
# 1: Origin authentication failed.
# 2: Origin authentication failed.
# 3: Origin authentication failed.
# 4: Origin authentication failed.
# 5: Origin authentication failed.&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali we see a 100% failure rate.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-JWT.png" alt="Kiali JWT"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali: failing because of authentication error.&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To be able to connect to our application we first need to fetch a valid token and put this into the header while sending curl.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
export TOKEN=$(curl https://raw.githubusercontent.com/istio/istio/release-1.1/security/tools/jwt/samples/demo.jwt -s)
for x in $(seq 1 1000);
do curl --header &amp;#34;Authorization: Bearer $TOKEN&amp;#34; $GATEWAY_URL -s;
done&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali the traffic is now working again and authenticated.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-JWT2.png" alt="Kiali JWT2"/>
&lt;/div>
&lt;div class="title">Figure 2. Kiali: Traffic authenticated.&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_clean_up">Clean Up&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Remove the policy again, to be ready for the next tutorial.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete policy jwt-example -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Mutual TLS Authentication</title><link>https://blog.stderr.at/service-mesh/2020/04/mutual-tls-authentication/</link><pubDate>Wed, 08 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/mutual-tls-authentication/</guid><description>&lt;div class="paragraph">
&lt;p>When more and more microservices are involved in an application, more and more traffic is sent on the network. It should be considered to secure this traffic, to prevent the possibility to inject malicious packets. Mutual TLS/mTLS authentication or two-way authentication offers a way to encrypt service traffic with certificates.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With Red Hat OpenShift Service Mesh, Mutual TLS can be used without the microservice knowing that it is happening. The TLS is managed completely by the Service Mesh Operator between two Envoy proxies using a defined mTLS policy.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Issue 9 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> will explain how to enable Mutual TLS inside the Service Mesh to secure the traffic between the different microservices.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_how_does_it_work">How does it work?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>If a microservice sends a request to a server, it must pass the local sidecar Envoy proxy first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The proxy will intercept the outbound request and starts a mutual TLS handshake with the proxy at the server side. During this handshake the certificates are exchanged and loaded into the proxy containers by Service Mesh.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The client side Envoy starts a mutual TLS handshake with the server side Envoy.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The client proxy does a secure naming check on the server’s certificate to verify that the identity in the certificate is authorized.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A mutual TLS connection is established between the client and the server.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Envoy proxy at the server sides decrypts the traffic and forwards it to the application through a local TCP connection.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparations">Preparations&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Before we can start be sure that the services are setup like in &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Issue #3&lt;/a>.&lt;br/>
In addition, be sure that the following DestinationRule already exists:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
version: v1
name: version-v1
- labels:
version: v2
name: version-v2&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Now we will create a pod, which is running outside of the Service Mesh. It will not have a sidecar proxy and will simply curl our application.&lt;/p>
&lt;div class="paragraph">
&lt;p>Store the following yaml and create the object in our cluster.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
labels:
app: curl
version: v1
name: curl
spec:
replicas: 1
selector:
matchLabels:
app: curl
version: v1
template:
metadata:
labels:
app: curl
version: v1
annotations: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
sidecar.istio.io/proxyCPU: &amp;#34;500m&amp;#34;
sidecar.istio.io/proxyMemory: 400Mi
spec:
containers:
- image: quay.io/maistra_demos/curl:latest
command: [&amp;#34;/bin/sleep&amp;#34;, &amp;#34;3650d&amp;#34;]
imagePullPolicy: Always
name: curl&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>since no sidecar is injected (sidecar.istio.io/inject: &amp;#34;true&amp;#34;), only 1 container will be started.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The traffic coming from the microservice &lt;em>customer&lt;/em> AND from the external client &lt;em>curl&lt;/em> must be simulated. To achieve this the following shell script can be used:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">#!/bin/sh
export CURL_POD=$(oc get pods -n tutorial -l app=curl | grep curl | awk &amp;#39;{ print $1}&amp;#39; )
export CUSTOMER_POD=$(oc get pods -n tutorial -l app=customer | grep customer | awk &amp;#39;{ print $1}&amp;#39; )
echo &amp;#34;A load generating script is running in the next step. Ctrl+C to stop&amp;#34;
while :; do
echo &amp;#34;Executing curl in curl pod&amp;#34;
oc exec -n tutorial $CURL_POD -- curl -s http://preference:8080 &amp;gt; /dev/null
sleep 0.5
echo &amp;#34;Executing curl in customer pod&amp;#34;
oc exec -n tutorial $CUSTOMER_POD -c customer -- curl -s http://preference:8080 &amp;gt; /dev/null
sleep 0.5
done&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>By executing this, it will first execute a curl command out of the &lt;em>curl&lt;/em> pod and then the same curl command out of the &lt;em>customer&lt;/em> container.
&lt;strong>Kepp this script running&lt;/strong>&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_enabling_mutual_tls">Enabling Mutual TLS&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Lets execute the shell script above and verify Kiali. As you notice there are requests coming from the &lt;em>customer&lt;/em> microservice and from the source called &lt;em>unknown&lt;/em>, which is the curl-service running outside the Service Mesh.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_1.png" alt="Kiali mtls 1"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali: traffic coming from customer microserver and external pod&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Enable the policy by creating the following object:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;preference-mutualtls&amp;#34;
spec:
targets:
- name: preference
peers:
- mtls:
mode: STRICT &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We are enforcing mtls for the target preference&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds the curl pod cannot reach the application anymore:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">Executing curl in curl pod
command terminated with exit code 56
Executing curl in customer pod
Executing curl in curl pod
command terminated with exit code 56
Executing curl in customer pod
Executing curl in curl pod
command terminated with exit code 5&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is expected, since the &lt;em>preference&lt;/em> service allows traffic over mutual TLS only. This was enforced by the Policy object (&lt;strong>STRICT&lt;/strong> mode). The &lt;em>customer&lt;/em> service, which is running inside the Service Mesh receives the error &amp;#34;5053 Service Unavalable&amp;#34; since it tries to send traffic, but it does not know yet to use mTLS.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali you will see the following:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_2.png" alt="Kiali mtls 2"/>
&lt;/div>
&lt;div class="title">Figure 2. Kiali: traffic is blocked&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The &lt;em>curl&lt;/em> pod is greyed out, since the traffic it tries to send, never reaches the preference service and is therefor not counted in the metric.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To make &lt;em>customer&lt;/em> aware that mutual TLS shall be used, a DestinationRule must be configured:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;networking.istio.io/v1alpha3&amp;#34;
kind: &amp;#34;DestinationRule&amp;#34;
metadata:
name: &amp;#34;preference-destination-rule&amp;#34;
spec:
host: &amp;#34;preference&amp;#34;
trafficPolicy:
tls:
mode: ISTIO_MUTUAL &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Let’s use mTLS&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This defines that &lt;strong>ISTIO_MUTUAL&lt;/strong> shall be used for the service &lt;em>preference&lt;/em>. The &lt;em>customer&lt;/em> service recognizes this and automatically enables mTLS. After a few minutes the traffic graph in Kiali will show &amp;#34;green&amp;#34; traffic from &lt;em>customer&lt;/em> through &lt;em>preference&lt;/em> to _recommendation:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_3.png" alt="Kiali mtls 3"/>
&lt;/div>
&lt;div class="title">Figure 3. Kiali: traffic for Service Mesh components is fine again.&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_mutual_tls_migration">Mutual TLS Migration&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As you can see in the previous section, the &lt;em>curl&lt;/em> pod cannot reach the application inside the Service Mesh. This happens because &lt;em>prefernce&lt;/em> is strictly enforcing encrypted traffic, but &lt;em>curl&lt;/em> only sends plain text. Luckily, Istio provides a method to gradually monitor the traffic and migrate to mTLS. Instead of STRICT mode PERMISSIVE can be used. Enabling permissive mode, &lt;em>preference&lt;/em> will accept both, encrypted and plain-text traffic.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Replace the Policy object with the following configuration:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;preference-mutualtls&amp;#34;
spec:
targets:
- name: preference
peers:
- mtls:
mode: PERMISSIVE&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f Policy-permissive.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now let’s wait a few minutes and observe Kiali, which should end up with:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_4.png" alt="Kiali mtls 4"/>
&lt;/div>
&lt;div class="title">Figure 4. Kiali: Encrypted and Plain-Text traffic&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see with the lock icon, the traffic between &lt;em>cunstomer&lt;/em> and &lt;em>preference&lt;/em> is encrypted, while the traffic from &lt;em>unknown&lt;/em> (which is our curl pod), is plain-text.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The errors you may see in Kiali happen due a known issue: &lt;a href="https://issues.jboss.org/browse/MAISTRA-1000" class="bare">https://issues.jboss.org/browse/MAISTRA-1000&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_cleanup">Cleanup&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Clean up your environment:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete policy -n tutorial preference-mutualtls
oc delete destinationrule -n tutorial preference-destination-rule&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Fault Injection</title><link>https://blog.stderr.at/service-mesh/2020/04/fault-injection/</link><pubDate>Tue, 07 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/fault-injection/</guid><description>&lt;div class="paragraph">
&lt;p>Tutorial 8 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> tries to cover Fault Injection by using Chaos testing method to verify if your application is running. This is done by adding the property HTTPFaultInjection to the VirtualService. The settings for this property can be for example: delay, to delay the access or abort, to completely abort the connection.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&amp;#34;&lt;em>Adopting microservices often means more dependencies, and more services you might not control. It also means more requests on the network, increasing the possibility for errors. For these reasons, it’s important to test your services’ behavior when upstream dependencies fail.&amp;#34;&lt;/em> [&lt;a href="#source_1">1&lt;/a>]&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparation">Preparation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before we start this tutorial, we need to clean up our cluster. This is especially important when you did the previous training &lt;a href="https://blog.stderr.at/service-mesh/2020/04/limit-egress/external-traffic">Limit Egress/External Traffic&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete deployment recommendation-v3
oc scale deployment recommendation-v2 --replicas=1
oc delete serviceentry worldclockapi-egress-rule
oc delete virtualservice worldclockapi-timeout&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Verify that 2 pods for the recommendation services are running (with 2 containers)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -l app=recommendation -n tutorial
NAME READY STATUS RESTARTS AGE
recommendation-v1-69db8d6c48-h8brv 2/2 Running 0 4d20h
recommendation-v2-6c5b86bbd8-jnk8b 2/2 Running 0 4d19h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_abort_connection_with_http_error_503">Abort Connection with HTTP Error 503&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>For the first example, we will need to modify the VirtualService and the DestinationRule. The VirtualService must be extended with a http fault section, which will abort the traffic 50% of the time.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create the VirtualService&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- fault:
abort:
httpStatus: 503
percent: 50
route:
- destination:
host: recommendation
subset: app-recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f VirtualService-abort.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Existing VirtualService with the name recommendation will be overwritten.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create the DestinationRule&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
app: recommendation
name: app-recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f destinationrule-faultinj.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Existing Destination with the name recommendation will be overwritten.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Check the traffic and verify that 50% of the connections will end with a 503 error:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export INGRESS_GATEWAY=$(oc get route customer -n tutorial -o &amp;#39;jsonpath={.spec.host}&amp;#39;)
sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_clean_up">Clean Up&lt;/h3>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete virtualservice recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_test_slow_connection_with_delay">Test slow connection with Delay&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>More interesting, in my opinion, to test is a slow connection. This can be tested by adding the &lt;em>fixedDelay&lt;/em> property into the VirtualService.
Like in the example below, we will use a VirtualService. This time &lt;strong>delay&lt;/strong> instead of &lt;strong>abort&lt;/strong> is used. The fixDelay defines a delay of 7 seconds for 50% of the traffic.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- fault:
delay:
fixedDelay: 7.000s
percent: 50
route:
- destination:
host: recommendation
subset: app-recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now send traffic into the application, you will see that some answers will have a delay of 7 seconds. Keep sending traffic in a loop.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Even more visible it will be, when you goto &amp;#34;Distributed Tracing&amp;#34; at the Kiali UI, select the service &lt;em>recommendation&lt;/em> and a small lookback of maybe 5min.
You will find that some requests are very fast, while other will tage about 7 seconds.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-delayed-traffic.png" alt="Kiali delayed traffic"/>
&lt;/div>
&lt;div class="title">Figure 1. Jaeger with delayed traffic.&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_retry_on_errors">Retry on errors&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>If a microservice is answering with an error, Service Mesh/Istio will automatically try to reach another pod providing the service. These retries can be modified. In order to make everything visible, we will use Kiali to monitor the traffic.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p> &lt;br/>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>We start by sending traffic into the application. This should be split evenly between v1 and v2 of the recommendation microservice&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 8329: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 11145
# 8330: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 9712
# 8331: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 11146
# 8332: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 9713
# 8333: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 11147&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali this ia visible in the Graphs, using the settings: &amp;#34;Versioned app graph&amp;#34; and &amp;#34;Requests percentage&amp;#34;&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-retry-traffic-split-50.png" alt="Kiali retry traffic split 50"/>
&lt;/div>
&lt;div class="title">Figure 2. Traffic is split by 50% between recommendation v1 nd v2&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>As second step we need to enable the &lt;em>nasty&lt;/em> mode for the microservice v2. This will simulate an outage, respoding with error 503 all the time. This change must be done &lt;strong>inside&lt;/strong> the container:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc exec -it $(oc get pods|grep recommendation-v2|awk &amp;#39;{ print $1 }&amp;#39;|head -1) -c recommendation /bin/bash&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Inside the container use the following command and exit the container again&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl localhost:8080/misbehave&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Kiali will now show that v1 will get 100% of the traffic, while v2 is shown as red. When you select the red square of v2 and then move the mouse over the red cross for the failing application, you will see that the pd itself is ready, but that 100% of the traffic is currently failing.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-retry-traffic-retry.png" alt="Kiali retry traffic retry"/>
&lt;/div>
&lt;div class="title">Figure 3. Traffic for v2 is failing&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>revert the change and fix v2 service&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc exec -it $(oc get pods|grep recommendation-v2|awk &amp;#39;{ print $1 }&amp;#39;|head -1) -c recommendation /bin/bash&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl localhost:8080/behave&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Verify in Kiali that everything is &amp;#34;green&amp;#34; again and that the traffic is split by 50% between v1 and v2.&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_sources">Sources&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a id="source_1">&lt;/a>[1]: &lt;a href="https://istiobyexample.dev/fault-injection/" target="_blank" rel="noopener">Istio By Example - Fault Injection&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Limit Egress/External Traffic</title><link>https://blog.stderr.at/service-mesh/2020/04/limit-egress/external-traffic/</link><pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/limit-egress/external-traffic/</guid><description>&lt;div class="paragraph">
&lt;p>Sometimes services are only available from outside the OpenShift cluster (like external API) which must be reached. Part 7 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> takes care and explains how to control the egress or external traffic. All operations have been successdully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparation">Preparation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before this tutorial can be started, ensure that 3 microservices are deployed (recommendation may have 2 versions) and that the objects Gateway and VirtualService are configured. The status should be like in &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/">Issue #4..6&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>You can verify this the following way:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
curl $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>which should simply print:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7123&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_setup_recommendation_v3">Setup &lt;em>recommendation-v3&lt;/em>&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>We need to deploy version 3 of our recommendation microservice. This will perform an external API call to &lt;a href="http://worldclockapi.com" class="bare">http://worldclockapi.com&lt;/a> to retrieve the current time.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To deploy the Deployment v3:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/recommendation
oc apply -f kubernetes/Deployment-v3.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If you list the pods at this moment, you will see that only one container (Ready 1/1) is started. This happens because the Deployment yaml file is missing an annotation.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_fixing_missing_proxy_sidecar_container">Fixing missing proxy sidecar container&lt;/h3>
&lt;div class="paragraph">
&lt;p>After you applied the Deployment-v3.yml, only 1 container is started. The proxy sidecar is not injected, because an annotation is missing in the configuration for the Deployment.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To fix this use the following command:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc patch deployment recommendation-v3 -n tutorial -p &amp;#39;{&amp;#34;spec&amp;#34;:{&amp;#34;template&amp;#34;:{&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{&amp;#34;sidecar.istio.io/inject&amp;#34;:&amp;#34;true&amp;#34;}}}}}&amp;#39;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will automatically restart the pod with 2 containers.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_destinationrule_and_virtualservice">Create DestinationRule and VirtualService&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Use the following definition to create (overwrite) the DestinationRule for recommendation-v3.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
version: v3
name: version-v3&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Only version 3 is used for now. The other versions are still there, but ignored for our tests.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f DestinationRule_v3.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Define the VirtualService and send 100% of the traffic to v3 of the recommendation microservice.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v3
weight: 100&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
As an alternative, you can also edit the existing VirtualService and add the section for version-v3 with a weight of 100, while changing the weight of v1 and v2 to 0.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_test_egress_traffic">Test egress traffic&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As usual we test our application by sending traffic to it. The following command should print successful connection requests:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 1
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 2
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 3
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 4
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 5&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see 100% of the traffic is sent to v3 &lt;strong>AND&lt;/strong> a new field enters the output. The current time is now shown as well. The information for this field is fetched with an external API call to &lt;a href="http://worldclockapi.com" class="bare">http://worldclockapi.com&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The traffic is simply sent to an external destination. There is not limit yet. Readers of the Istio documentation will miss the object &lt;strong>ServiceEntry&lt;/strong> which somebody should think is required. However, Openshift is currently(?) configured in a way to simply allow ANY traffic. This is defined in a ConfigMap which might be changed to modify the default behavior. However, as soon as ServiceEntry and the appropriate VirtualService is configured, the traffic will be limited as well.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_limitcontrol_external_access">Limit/Control external access&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As you can see above you can simply send egress traffic without any control about what is allowed or not. In order to limit your outgoing traffic a new object called &lt;strong>ServiceEntry&lt;/strong> must be defined as well as a change in your &lt;strong>VirtualService&lt;/strong> will be required.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Define the ServiceEntry and apply it to your cluster:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: worldclockapi-egress-rule
spec:
hosts:
- worldclockapi.com
ports:
- name: http-80
number: 81 &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
protocol: http&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Wrong port 81 is set on purpose for demonstration&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The port &lt;strong>number: 81&lt;/strong> is set on purpose, to prove that the traffic will not work with a wrong ServiceEntry.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc create -f ServiceEntry.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To actually limit the traffic a link between the ServiceEntry and a VirtualService, which defines the external destination, must be created. Moreover, a timeout is set for possible connection errors, to keep the application responding even when the external API is down.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: worldclockapi-timeout &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
spec:
hosts:
- worldclockapi.com &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
http:
- timeout: 3s &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
route:
- destination:
host: worldclockapi.com
weight: 100 &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The name of the object&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The external hostname we want to reach&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The timeout setting in seconds&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The destination route, which is sending 100% of the external traffic to the host above&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VirtualService-worldclockapi.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now run a connection test you will still get an error.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1 $GATEWAY_URL
# customer =&amp;gt; Error: 503 - preference =&amp;gt; Error: 500 ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_fix_serviceentry">Fix ServiceEntry&lt;/h3>
&lt;div class="paragraph">
&lt;p>This happens, because we misconfigured the ServiceEntry on purpose to demonstrate that the traffic is sent to worldclockapi.com:80.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Fix the ServiceEntry object and apply to your cluster:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: worldclockapi-egress-rule
spec:
hosts:
- worldclockapi.com
ports:
- name: http-80
number: 80 &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
protocol: http&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Changed from 81 to 80&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f ServiceEntry.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now the traffic should work and gives you back a connection to microservice and a current time:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 10 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 138
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 139
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 140
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 141
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 142
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 143
# 6: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 144&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_kiali">Verify Kiali&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali_with_external_service.png?width=940px&amp;amp;height=250px" alt="Kiali with external service"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali shows traffic to the external service&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_optional_disallow_any_connections">OPTIONAL: Disallow ANY connections&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
This is a change in the default ConfigMap of the ServiceMesh. Do this on your own risk and always consult the latest documentation of OCP.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As explained above, we are able to connect to an external service without any limitation. The ServiceEntry object together with the VirtualService define the actual destination and would disallow traffic if they are wrongly configured, but if you forget these entries, it would still be possible to establish an egress connection.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In OpenShift a ConfigMap in the &lt;em>istio-system&lt;/em> namespace defines the default behavior. There are two possibilities:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>ALLOW_ANY - outbound traffic to unknown destinations will be allowed, in case there are no services or ServiceEntries for the destination port&lt;/p>
&lt;/li>
&lt;li>
&lt;p>REGISTRY_ONLY - restrict outbound traffic to services defined in the service registry as well&lt;/p>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Let’s Cleanup the ServiceEntry and the VirtualService which have been created above&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete serviceentry worldclockapi-egress-rule
serviceentry.networking.istio.io &amp;#34;worldclockapi-egress-rule&amp;#34; deleted
oc delete virtualservice worldclockapi-timeout
virtualservice.networking.istio.io &amp;#34;worldclockapi-timeout&amp;#34; deleted&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Now traffic to the external service will be allowed again
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Modify the ConfigMap &lt;em>istio&lt;/em> in the namespace &lt;em>istio-system&lt;/em>&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get configmap istio -n istio-system -o yaml | sed &amp;#39;s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g&amp;#39; | oc replace -n istio-system -f -&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Wait a few seconds and try to connect. You will see that the connection is not possible anymore.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
If you now re-create the &lt;strong>ServiceEntry&lt;/strong> the connection will be possible again, since the service is registered to the Service Mesh.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Advanced Routing Example</title><link>https://blog.stderr.at/service-mesh/2020/04/advanced-routing-example/</link><pubDate>Fri, 03 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/advanced-routing-example/</guid><description>&lt;div class="paragraph">
&lt;p>Welcome to part 6 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> Advanced routing, like Canary Deployments, traffic mirroring and loadbalancing are discussed and tested. All operations have been successdully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_advanced_routing">Advanced Routing&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>During &lt;a href="https://blog.stderr.at/service-mesh/2020/04/routing-example">Issue #5&lt;/a> some simple routing was implemented. The traffic was split by 100% to a new version (v2) of the &lt;em>recommendation&lt;/em> microservice.
This section shall give a brief overview of advanced routing possibilities.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_canary_deployments">Canary Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>A canary deployment is a strategy to roll out a new version of your service by using traffic splitting. A small amount of traffic (10%) will be sent to the new version, while most of the traffic will be sent to the old version still. The traffic to the new version can be analysed and if everything works as expected more and more traffic can be sent to the new version.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To enable split traffic, the VirtualService must be update:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v1
weight: 90
- destination:
host: recommendation
subset: version-v2
weight: 10&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VitualService_split_v1_and_v1.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Test the traffic and verify that 10% will be sent to v2&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 100 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1060
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1061
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 2060
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1062
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1063
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If an error is shown, then you most probably forget to configure the DestinationRule as described &lt;a href="https://blog.stderr.at/service-mesh/2020/04/routing-example">here&lt;/a>.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali_Canary_90_10.png?width=940px&amp;amp;height=224px" alt="Kiali Canary 90 10"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali split traffic 90/10&lt;/div>
&lt;/div>
&lt;div style="page-break-after: always;">&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_routing_based_on_user_agent_header">Routing based on user-agent header&lt;/h3>
&lt;div class="paragraph">
&lt;p>It is possible to send traffic to different versions based on the browser type which is calling the application.
In our test application the service &lt;em>customer&lt;/em> is setting the header &lt;strong>baggage-user-agent&lt;/strong> and propagates it to the other services.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
&amp;gt;&amp;gt; headers.putSingle(&amp;#34;baggage-user-agent&amp;#34;, userAgent);
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Create the following file&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- match:
- headers:
baggage-user-agent:
regex: .*Safari.*
route:
- destination:
host: recommendation
subset: version-v2
- route:
- destination:
host: recommendation
subset: version-v1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>and apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VitualService_safari.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In order to test the result, either use the appropriate browser or use &lt;em>curl&lt;/em> to set the user-agent. As expected, request from &lt;em>Safari&lt;/em> are sent to v2, other are sent to v1.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Safari&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl -v -A Safari $GATEWAY_URL
[...]
&amp;gt; User-Agent: Safari
[...]
customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 2365&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Firefox&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl -v -A Firefox $GATEWAY_URL
[...]
&amp;gt; User-Agent: Firefox
[...]
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3762&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div style="page-break-after: always;">&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_mirroring_traffic">Mirroring Traffic&lt;/h3>
&lt;div class="paragraph">
&lt;p>Mirroring Traffic, aka Dark Launch, will duplicate the traffic to another service, allowing you to analyse it before sending production data to it. Responses of the mirrored requests are ignored.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Run the following command and be sure that recommendation-v1 and recommendation-v2 are both running:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pod -n tutorial| grep recommendation
recommendation-v1-69db8d6c48-h8brv 2/2 Running 0 24h
recommendation-v2-6c5b86bbd8-jnk8b 2/2 Running 0 23h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Update the VirtualService, so that version v2 will receive mirrored traffic, while the actual request will be sent to v1:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v1
mirror: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
host: recommendation
subset: version-v2&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>This must be set to &amp;#39;mirror&amp;#39;&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VitualService_mirrored-traffic.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now lets open and follow the logs of recommandation-v2 in order to see that traffic will reach this service, but responses are ignored:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc logs -f $(oc get pods|grep recommendation-v2|awk &amp;#39;{ print $1 }&amp;#39;) -c recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In a second terminal window send some traffic to our service.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 100 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>You will see that only v1 answers, while in the 2nd window, v2 gets the same traffic.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_load_balancing">Load Balancing&lt;/h3>
&lt;div class="paragraph">
&lt;p>In the default OpenShift environment the kube-proxy forwards all requests to pods randomly. With Red Hat ServiceMesh it is possible to add more complexity and let the Envoy proxy handle load balancing for your services.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Three methods are supported:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>random&lt;/p>
&lt;/li>
&lt;li>
&lt;p>round-robin&lt;/p>
&lt;/li>
&lt;li>
&lt;p>least connection&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The round robin function is used by default, when there is no DestinationRule configured. We can use the DestinationRule to use the least connection option to see how the traffic is sent.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Before we start we need to delete the VirtualService for the recommendation microservice&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete virtualservice recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The we scale version v2 to 3:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc scale deployment recommendation-v2 --replicas=3&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds the folling pods should run now:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-jdjlg 2/2 Running 1 25h
preference-v1-7fdb89c86b-nktqn 2/2 Running 0 25h
recommendation-v1-69db8d6c48-h8brv 2/2 Running 0 25h
recommendation-v2-6c5b86bbd8-6lgz6 2/2 Running 0 91s
recommendation-v2-6c5b86bbd8-dnc8b 2/2 Running 0 91s
recommendation-v2-6c5b86bbd8-jnk8b 2/2 Running 0 24h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you send traffic to the application, you would see that 3 quarter are sent to v1 and one is sent to v1.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With the following DestinationRule the traffic will be sent randomly to the application&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
trafficPolicy:
loadBalancer:
simple: RANDOM&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now sent traffic to the service, you will see that the traffic is sent randomly to the versions. (verify the serial number)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 100 $GATEWAY_URL
# 140: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 5729
# 141: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7119
# 142: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 361
# 143: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 362
# 144: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 5730
# 145: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 362
# 146: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7120
# 147: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7121
# 148: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 363
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Routing Example</title><link>https://blog.stderr.at/service-mesh/2020/04/routing-example/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/routing-example/</guid><description>&lt;div class="paragraph">
&lt;p>In part 5 of the &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> tutorials, basic routing, using the objects VirtualService and DesitnationRule, are described. All operations have been successfully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_some_theory">Some Theory&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In this section another version of the &lt;em>recommendation&lt;/em> microservice will be deployed. The traffic to the new version will be controlled with different settings of the VirtualService. Multiple scenarios can be realized with ServiceMesh. In general these are defined as follows ([&lt;a href="#source_1">1&lt;/a>]):&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_blue_green_deployments">Blue-Green Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>In a Blue-Green deployment the old version (green) is kept running, while a new version (blue) is deployed and tested. When testing is successful, the 100% of the traffic is switched to the new version.
If there is any error, the traffic could be switched back to the green version.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_ab_deployments">A/B Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>A/B deployments, in difference to Blue-Green deployments, will enable you to try a new version of the application in a limited way in the production environment. It is possible to specify that the production version gets most of the user requests, while a limited number of requests is sent to the new version. This could be specified by location of the user for example, so that all users from Vienna are sent to the new version, while all others are still using the old version.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_canary_deployments">Canary Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>Canary releases can be used to allow a small, minimum amount of traffic to the new version of your application. This traffic can be increased gradually until all traffic is sent to the new version. If any issues are found, you can roll back and send the traffic to the old version.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>It is assumed that an OpenShift environment is up and running and that Issues #1 - #3 are done at least:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/installation/">Openshift 4 and ServiceMesh 1 - Installation&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/">Openshift 4 and ServiceMesh 2 - Deploy Microservices&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Openshift 4 and ServiceMesh 3 - Ingress Traffic&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prepare_simple_routing">Prepare Simple Routing&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_optional_build_the_recommendation_microservice">OPTIONAL: Build the &lt;em>recommendation&lt;/em> microservice&lt;/h3>
&lt;div class="paragraph">
&lt;p>If you want to locally build the microservice, you must change the source code from version v1 to v2 the following way:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Open the file:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">istio-tutorial/recommendation/java/vertx/src/main/java/com/redhat/developer/demos/recommendation/RecommendationVerticle.java&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>and change the following line from v1 to &lt;strong>v2&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-java" data-lang="java">private static final String RESPONSE_STRING_FORMAT = &amp;#34;recommendation &lt;strong>v2&lt;/strong> from &amp;#39;%s&amp;#39;: %d\n&amp;#34;;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now you can build the image:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd istio-tutorial/recommendation/java/vertx
mvn package
podman build -t example/recommendation:v2 . &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Note the v2 tag&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_create_second_deployment_with_version2">Create second deployment with version2&lt;/h3>
&lt;div class="paragraph">
&lt;p>A deployment with our recommendation:v2 microservice must be created. A service object must not be created this time, as it already exists.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/recommendation/
oc apply -f kubernetes/Deployment-v2.yml -n tutorial
oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you want to &lt;em>diff&lt;/em> v1 and v2 deployment, you will notice that the main change is the image which gets pulled.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-diff" data-lang="diff">diff recommendation/kubernetes/Deployment-v2.yml recommendation/kubernetes/Deployment.yml
6,7c6,7
&amp;lt; version: v2
&amp;lt; name: recommendation-v2
---
&amp;gt; version: v1
&amp;gt; name: recommendation-v1
13c13
&amp;lt; version: v2
---
&amp;gt; version: v1
18c18
&amp;lt; version: v2
---
&amp;gt; version: v1
27c27
&amp;lt; image: quay.io/rhdevelopers/istio-tutorial-recommendation:v2.1
---
&amp;gt; image: quay.io/rhdevelopers/istio-tutorial-recommendation:v1.1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_call_application">Call application&lt;/h3>
&lt;div class="paragraph">
&lt;p>Execute the test command to access the application. Since no rules are defined yet, the traffic is split by 50% to version 1 and version 2 (round robin):&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 10 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 27
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 27
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 28
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 28
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali presents this as well:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-v1-v2-trafficsplit1.png" alt="Kiali v1 v2 trafficsplit1"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali sends 50% to v1 and v2&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_send_all_traffic_to_recommendationv2">Send all traffic to &lt;em>recommendation:v2&lt;/em>&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To route the traffic accordingly a &lt;strong>DestinationRule&lt;/strong> and a &lt;strong>VirtualService&lt;/strong> must be created for &lt;em>recommendation&lt;/em>. While the DesinationRule will add a name to each version, VirtualService specifies the actual destination of the traffic.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_define_destinationrule_for_recommendation">Define DestinationRule for &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The object DestinationRule will define the versions in &lt;em>subsets&lt;/em>.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
version: v1
name: version-v1
- labels:
version: v2
name: version-v2&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Create the object with the command: &lt;em>oc create -f &amp;lt;filename&amp;gt;&lt;/em>&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_define_virtualservice_for_recommendation">Define VirtualService for &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The VirtualService defines that 100% (weight) of the traffic for recomendation (host) will be sent to the subset (version-v2), which is defined in the DefinationRule&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v2
weight: 100&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Create the object with the command: &lt;em>oc create -f &amp;lt;filename&amp;gt;&lt;/em>&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_call_application_2">Call application&lt;/h3>
&lt;div class="paragraph">
&lt;p>If you now call the application, only traffic to v2 should be shown:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 27
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 27
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 28
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 28
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali presents this as well and send 100% of the traffic to &lt;em>recommendation:v2&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-100-v2-trafficsplit2.png" alt="Kiali 100 v2 trafficsplit2"/>
&lt;/div>
&lt;div class="title">Figure 2. Kiali sends 100% to v2&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_sources">Sources&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a id="source_1">&lt;/a>[1]: &lt;a href="https://dzone.com/articles/traffic-management-with-istio-2-grayscale-release" target="_blank" rel="noopener">DZone: Traffic Management With Istio&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Ingress with custom domain</title><link>https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/</guid><description>&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Since Service Mesh 1.1, there is a better way to achieve the following. Especially the manual creation of the route is not required anymore. Check the following article to &lt;a href="https://blog.stderr.at/service-mesh/2020/05/enable-automatic-route-creation">Enable Automatic Route Creation&lt;/a>.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Often the question is how to get traffic into the Service Mesh when using a custom domains. Part 4 our our tutorials series &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> will use a dummy domain &lt;strong>&amp;#34;hello-world.com&amp;#34;&lt;/strong> and explains the required settings which must be done.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_modify_gateway_and_virtualservice">Modify Gateway and VirtualService&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Issue #3&lt;/a> explains how to get ingress traffic into the Service Mesh, by defining the &lt;strong>Gateway&lt;/strong> and the &lt;strong>VirtualService&lt;/strong>. We are currently using the default ingress route defined in the &lt;em>istio_system&lt;/em> project.&lt;br/>
But what if a custom domain shall be used?&lt;br/>
In such case another route must be defined in the &lt;em>istio-system&lt;/em> project and small configuration changes must be applied.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>First lets create a slightly modified &lt;em>Gateway.yaml&lt;/em>:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: ingress-gateway-exampleapp
spec:
selector:
istio: ingressgateway # use istio default controller
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- &amp;#34;hello-world.com&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>add you custom domain here
&lt;div class="paragraph">
&lt;p>The only difference is at the hosts which was changed from &amp;#39;*&amp;#39; to &amp;#39;hello-world.com&amp;#39;&lt;/p>
&lt;/div>&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>As second change, the VirtualService must be modified as well with the custom domain:&lt;/p>
&lt;div class="paragraph">
&lt;p>VirtualService.yaml:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: ingress-gateway-exampleapp
spec:
hosts:
- &amp;#34;hello-world.com&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
gateways:
- ingress-gateway-exampleapp
http:
- match:
- uri:
exact: /
route:
- destination:
host: customer
port:
number: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>add you custom domain here&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Replace current objects in OpenShift:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f Gateway.yaml -n tutorial
oc replace -f VirtualService.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create a new route under the project &lt;em>istio-system&lt;/em>:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: route.openshift.io/v1
kind: Route
metadata:
name: hello-world.com &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: istio-system &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
spec:
host: hello-world.com &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
to:
kind: Service
name: istio-ingressgateway &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
port:
targetPort: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>add you custom domain here&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>the route must be created at istio-system&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>add you custom domain here&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>this is the service as it was created by the operator&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_optional_add_custom_domain_to_local_hosts_file">OPTIONAL: Add custom domain to local hosts file&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The custom domain &lt;strong>hello-world.com&lt;/strong> must be resolvable somehow, pointing to the ingress router of OpenShift.
This can be done, by adding the domain into the local hosts file (with all limitations this brings with it)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># Get IP address of:
oc -n istio-system get route istio-ingressgateway
echo &amp;#34;x.x.x.x hello-world.com&amp;#34; &amp;gt;&amp;gt; /etc/hosts&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_some_example_traffic">Create some example traffic&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>We will reuse the script of &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Issue #3&lt;/a> to simulate traffic.
Since we changed the domain, the connection will go to hello-world.com&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh run-check.sh 1000 hello-world.com&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will send 1000 requests to our application:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6626
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6627
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6628
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6629
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6630
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6631
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Ingress Traffic</title><link>https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/</guid><description>&lt;div class="paragraph">
&lt;p>Part 3 of tutorial series &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> will show you how to create a Gateway and a VirtualService, so external traffic actually reaches your Mesh. It also provides an example script to run some curl in a loop.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_configure_gateway_and_virtualservice_example">Configure Gateway and VirtualService Example&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With the microservices deployed during &lt;a href="https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/">Issue #2&lt;/a>, it makes sense to test the access somehow. In order to bring traffic into the application a Gateway object and a VirtualService object must be created.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;em>Gateway&lt;/em> will be the entry point which forward the traffic to the &lt;em>istio ingressgateway&lt;/em>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: ingress-gateway-exampleapp
spec:
selector:
istio: ingressgateway # use istio default controller
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- &amp;#34;*&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As 2nd object a VirtualService must be created:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: ingress-gateway-exampleapp
spec:
hosts:
- &amp;#34;*&amp;#34;
gateways:
- ingress-gateway-exampleapp
http:
- match:
- uri:
exact: /
route:
- destination:
host: customer
port:
number: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Get all istio-io related objects of your project. These objects represent the network objects of Service Mesh, like Gateway, VirtualService and DestinationRule (explained later)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get istio-io -n tutorial
NAME HOST AGE
destinationrule.networking.istio.io/recommendation recommendation 3d21h
NAME AGE
gateway.networking.istio.io/ingress-gateway 4d15h
NAME GATEWAYS HOSTS AGE
virtualservice.networking.istio.io/ingress-gateway [ingress-gateway] [*] 4d15h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_some_example_traffic">Create some example traffic&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before we start, lets fetch the default route of our Service Mesh:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This should return: &lt;strong>istio-ingressgateway-istio-system.apps.&amp;lt;clustername&amp;gt;&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now, let’s create a shell script to run some curl commands in a loop and can be easily reused for other scenarios:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">#!/bin/bash
numberOfRequests=$1
host2check=$2
if [ $# -eq 0 ]; then
echo &amp;#34;better define: &amp;lt;script&amp;gt; #ofrequests hostname2check&amp;#34;
echo &amp;#34;Example: run.sh 100 hello.com&amp;#34;
let &amp;#34;numberOfRequests=100&amp;#34;
else
let &amp;#34;i = 0&amp;#34;
while [ $i -lt $numberOfRequests ]; do
echo -n &amp;#34;# $i: &amp;#34;; curl $2
let &amp;#34;i=$((i + 1))&amp;#34;
done
fi&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Run the script and check the output:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh run-check.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will send 1000 requests to our application:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3622
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3623
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3624
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3625
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3626
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3627
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_in_kiali">Verify in Kiali&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To verify in Kiali our application, open the URL in your browser and login using your OpenShift credentials.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
If you do not know the URL for Kiali, execute the following command&lt;br/>
oc get route kiali -n istio-system
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Switch the the &lt;strong>Graph&lt;/strong> view and you should see the following picture:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-Example-1.png" alt="Kiali Example 1"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali Graph&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Deploy Microservices</title><link>https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/</guid><description>&lt;div class="paragraph">
&lt;p>The second tutorials explains how to install an example application containing thee microservices. All operations have been successfully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_introduction">Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As quickly explained at &lt;a href="https://blog.stderr.at/service-mesh/2020/03/installation/">Issue #1&lt;/a>, OpenShift 4.3 and the Service Mesh shall be installed already. At this point you should have all 4 operators installed and ready.
The test application used in this scenario is based on Java and contains 3 microservices in the following traffic flow:&lt;/p>
&lt;/div>
&lt;div class="paragraph text-center">
&lt;p>Customer ⇒ Preference ⇒ Recomandation&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The microservices are the same as used at the &lt;a href="https://learn.openshift.com/servicemesh">Interactive Learning Portal&lt;/a>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_deploy_microservices">Deploy microservices&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>First lets create a new project for our tests&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc new-project tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>EITHER&lt;/strong>: Add &lt;em>tutorial&lt;/em> to ServiceMeshMemberRoll&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="admonitionblock tip">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-tip" title="Tip">&lt;/i>
&lt;/td>
&lt;td class="content">
Service Mesh 1.1 now supports the object &lt;strong>ServiceMember&lt;/strong> which can created under the application namespace and which automatically configures the ServiceMemberRoll. However, below description still works.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>+
OpenShift will auto-inject the sidecar proxy to pods of a namespace, if the namespace is configured in the ServiceMeshMemberRoll object which was created for the operator.&lt;/p>
&lt;/div>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>Create the file &lt;em>memberroll.yaml&lt;/em>:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; memberroll.yaml
apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
name: default
spec:
members:
- tutorial
EOF&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Add the namespace to the member roll:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f memberroll.yaml -n istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If you already have namespaces configured for ServiceMeshMemberRoll, better modify the object manually. Custom Resource Definitions (CRD) do not like to be modified on the fly (currently?)
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>OR&lt;/strong>: Create ServiceMeshMember object:
Available since ServiceMesh 1.1&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
name: default
namespace: tutorial
spec:
controlPlaneRef:
name: basic-install
namespace: istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Download the tutorial application locally&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/redhat-developer-demos/istio-tutorial/&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_deploy_microservice_customer">Deploy microservice: &lt;em>customer&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>To deploy the first microservice 2 objects (Deployment and Service) must be created. Moreover, the service will be exposed, since the service &lt;em>customer&lt;/em> is our entry point.&lt;br/>
Verify ~/istio-tutorial/customer/kubernetes/Deployment.yml to check where the actual image is coming from: quay.io/rhdevelopers/istio-tutorial-customer:v1.1&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/customer
oc apply -f kubernetes/Deployment.yml -n tutorial
oc apply -f kubernetes/Service.yml -n tutorial
oc expose service customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check if pods are running with two containers:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The result should look somehow like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-g77bs 2/2 Running 0 52m&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If there is only 1 container running, indicated by READY = 1/1, then most likely the ServiceMeshMemberRoll was not updated with the name &lt;em>tutorial&lt;/em> or contains a wrong project name.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_deploy_microservice_preference">Deploy microservice: &lt;em>preference&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The deployment of the microservice &lt;em>preference&lt;/em> is exactly like it is done for &lt;em>customer&lt;/em>, except that no service must be exposed:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/preference/
oc apply -f kubernetes/Deployment.yml -n tutorial
oc apply -f kubernetes/Service.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check if pods are running with two containers:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The result should look somehow like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-g77bs 2/2 Running 0 4d15h
preference-v1-7fdb89c86b-gkk5g 2/2 Running 0 4d14h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_deploy_microservice_recommendation">Deploy microservice: &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The deployment of the microservice &lt;em>recommendation&lt;/em> is exactly like it is done for &lt;em>preference&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/recommendation/
oc apply -f kubernetes/Deployment.yml -n tutorial
oc apply -f kubernetes/Service.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check if pods are running with two containers:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The result should look somehow like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-g77bs 2/2 Running 0 4d15h
preference-v1-7fdb89c86b-gkk5g 2/2 Running 0 4d14h
recommendation-v1-69db8d6c48-p9w2b 2/2 Running 0 4d14h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_optional_build_the_images">Optional: build the images&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>It is possible (and probably a good training) to build the microservices locally to understand how this works.
In order to achieve this the packages &lt;em>maven&lt;/em> and &lt;em>podman&lt;/em> must be installed.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_build_customer">Build &lt;em>customer&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>Go to the source folder of &lt;em>customer&lt;/em> application and build it:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/projects/istio-tutorial/customer/java/springboot
mvn package&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It will take a few seconds, but it should give &amp;#34;BUILD SUCCESS&amp;#34; as output, if everything worked.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now the image will be built using podman&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">podman build -t example/customer .&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_build_preference">Build &lt;em>preference&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The image build process of the second microservice follows the same flow as &lt;em>customer&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/preference/java/springboot
mvn package
podman build -t example/preference:v1 .&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
the &amp;#34;v1&amp;#34; tag at the image name is important and must be used.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_build_recommendation">Build &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The image build process of the third microservice follows the same flow as &lt;em>preference&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/projects/istio-tutorial/recommendation/java/vertx
mvn package
podman build -t example/recommendation:v1 .&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
the &amp;#34;v1&amp;#34; tag at the image name is important and must be used. Later other versions will be deployed.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Installation</title><link>https://blog.stderr.at/service-mesh/2020/03/installation/</link><pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/installation/</guid><description>&lt;div class="paragraph">
&lt;p>Everything has a start, this blog as well as the following tutorials. This series of tutorials shall provide a brief and working overview about &lt;strong>OpenShift Service Mesh&lt;/strong>. It is starting with the installation and the first steps, and will continue with advanced settings and configuration options.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_openshift_4_x_and_servicemesh">OpenShift 4.x and ServiceMesh&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
&lt;strong>UPDATE&lt;/strong>: At 10th April 2020 Red Hat released Service Mesh version 1.1 which supports:
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Istio - 1.4.6&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kiali - 1.12.7&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Jaeger - 1.17.1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following tutorials for &lt;strong>OpenShift Service Mesh&lt;/strong> are based on the official documentation: &lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/servicemesh-release-notes.html" target="_blank" rel="noopener">OpenShift 4.3 Service Mesh&lt;/a> and on the &lt;a href="https://learn.openshift.com/servicemesh" target="_blank" rel="noopener">Interactive Learning Portal&lt;/a>. All operations have been successfully tested on OpenShift 4.3.
Currently OpenShift supports Istio 1.4.6, which shall be updated in one of the future releases.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To learn the basics of Service Mesh, please consult the documentation as they are not repeated here.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It is assumed that OpenShift has access to external registries, like quay.io.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Other resource I can recommend are:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://istiobyexample.dev/" target="_blank" rel="noopener">Istio By Example&lt;/a>: A very good and brief overview of different topics by Megan O’Keefe.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://istio.io" target="_blank" rel="noopener">Istio&lt;/a>: The Istio documentation&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>At the very beginning OpenShift must be installed. This tutorial is based on OpenShift 4.3 and a Lab installation on Hetzner was used.
Moreover, it is assumed that the &lt;a href="https://mirror.openshift.com/pub/openshift-v4/clients/oc/4.3/" target="_blank" rel="noopener">OpenShift Client&lt;/a> and Git are installed on the local system.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>During the tutorials an example application in the namespace &lt;em>tutorial&lt;/em> will be deployed. This application will contain 3 microservices:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>customer (the entry point)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>preference&lt;/p>
&lt;/li>
&lt;li>
&lt;p>recommendation&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This application is also used at the &lt;a href="https://learn.openshift.com/servicemesh" target="_blank" rel="noopener">Interactive Learning Portal&lt;/a> which can be tested there interactively. However, the training is still based on OpenShift version 3.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_install_red_hat_service_mesh">Install Red Hat Service Mesh&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To deploy Service Mesh on Openshift 4 follow the guide at &lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/service_mesh_install/installing-ossm.html" target="_blank" rel="noopener">Installing Red Hat OpenShift Service Mesh&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In short, multiple operators must be installed:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Elasticsearch&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Jaeger&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kiali&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Service Mesh&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Elasticsearch is a very memory intensive application. Per default it will request 16GB of memory which can be reduced on Lab environments.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_link_jaeger_and_grafana_to_kiali">Link Jaeger and Grafana to Kiali&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In the lab environment it happened that Kiali was not able to auto detect Grafana or Jaeger.
This is visible when the link &lt;em>Distributed Tracing&lt;/em> is missing in the left menu.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To fix this the ServiceMeshControlPlane object in the istio-system namespace must be updated with 3 lines:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">oc edit ServiceMeshControlPlane -n istio-system
kiali: # ADD THE FOLLOWING LINES
dashboard:
grafanaURL: https://grafana-istio-system.apps.&amp;lt;your clustername&amp;gt;
jaegerURL: https://jaeger-istio-system.apps.&amp;lt;your clustername&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This change will take a few minutes to be effective.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item></channel></rss>