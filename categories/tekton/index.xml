<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Tekton on TechBlog about OpenShift/Ansible/Satellite and much more</title><link>https://blog.stderr.at/categories/tekton/</link><description>TechBlog about OpenShift/Ansible/Satellite and much more</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Toni Schmidbauer &amp; Thomas Jungbauer</copyright><lastBuildDate>Thu, 16 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stderr.at/categories/tekton/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenShift Pipelines - Tekton Introduction</title><link>https://blog.stderr.at/openshift-platform/other-topics/2020-04-16-tekton/</link><pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/openshift-platform/other-topics/2020-04-16-tekton/</guid><description>&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;em&gt;OpenShift Pipelines is a cloud-native, continuous integration and delivery (CI/CD) solution for building pipelines using Tekton. Tekton is a flexible, Kubernetes-native, open-source CI/CD framework that enables automating deployments across multiple platforms (Kubernetes, serverless, VMs, etc) by abstracting away the underlying details.&lt;/em&gt; [&lt;a href="#source_1"&gt;1&lt;/a&gt;]&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_openshift_pipelines_features"&gt;OpenShift Pipelines features&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;em&gt;Source: [&lt;a href="#source_1"&gt;1&lt;/a&gt;]&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Standard CI/CD pipeline definition based on Tekton&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build images with Kubernetes tools such as S2I, Buildah, Buildpacks, Kaniko, etc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deploy applications to multiple platforms such as Kubernetes, serverless and VMs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Easy to extend and integrate with existing tools&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scale pipelines on-demand&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Portable across any Kubernetes platform&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Designed for microservices and decentralized teams&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Integrated with the OpenShift Developer Console&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_prerequisites"&gt;Prerequisites&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;OpenShift 4.x cluster. Try yourself at &lt;a href="https://try.openshift.com" class="bare"&gt;https://try.openshift.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt;: &lt;a href="https://github.com/tektoncd/cli#installing-tkn" target="_blank" rel="noopener"&gt;Tekton CLI&lt;/a&gt; - Optional for now, since you could do everything via UI as well.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oc/kubectl CLI or WebUI&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
The Tekton CLI is optional in case you prefer to do everything via the OpenShift WebUI. However, below examples make use of the Tekton CLI and I personally would recommend to at least install it. (Like oc client it is good to have a CLI option as well). In any case, all described action can be done directly via the WebUI as well.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_basic_concepts"&gt;Basic Concepts&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Tekton makes use of several custom resources (CRD).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;These CRDs are:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="black silver-background"&gt;Task&lt;/span&gt;: each step in a pipeline is a task, while a task can contain several steps itself, which are required to perform a specific task. For each Task a pod will be allocated and for each step inside this Task a container will be used. This helps in better scalability and better performance throughout the pipeline process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="black silver-background"&gt;Pipeline&lt;/span&gt;: is a series of tasks, combined to work together in a defined (structured) way&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="black silver-background"&gt;TaskRun&lt;/span&gt;: is the result of a Task, all combined TaskRuns are used in the PipelineRun&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="black silver-background"&gt;PipelineRun&lt;/span&gt;: is the actual execution of a whole Pipeline, containing the results of the pipeline (success, failed…​)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Pipelines and Tasks should be generic and never define possible variables, like input git repository, directly in their definition. For this, the concept of PipelineResources has been created, which defines these parameters and which are used during a PipelineRun.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_installation"&gt;Installation&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;strong&gt;OpenShift Pipeline&lt;/strong&gt; is an operator which can e installed using the following yaml:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; deploy-OpenShift-Pipelines.yaml
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
name: openshift-pipelines-operator
namespace: openshift-operators
spec:
channel: dev-preview
name: openshift-pipelines-operator
source: community-operators
sourceNamespace: openshift-marketplace
EOF&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;oc create -f deploy-OpenShift-Pipelines.yaml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As an alternative, you can also use the WebUI to rollout the operator:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;Search for &amp;#34;OpenShift Pipeline&amp;#34; under OperatorHub and install it&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Select:&lt;/p&gt;
&lt;div class="olist loweralpha"&gt;
&lt;ol class="loweralpha" type="a"&gt;
&lt;li&gt;
&lt;p&gt;All Namespaces: since the operator needs to watch for Tekton Custom Resources across all namespaces.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Channel: Dev Preview&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Approve Strategy: Automatic&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_prepare_a_tutorial_project"&gt;Prepare a tutorial project&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To test our OpenShift Pipelines, we need to deploy an example application. This application let’s you vote what pet you like more: Cats or Dogs? It contais of a backend and a frontend part, which both will be deployed in a namespace.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Let’s first create a new project:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;oc new-project pipelines-tutorial&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The OpenShift Pipeline operator will automatically create a &lt;em&gt;pipeline&lt;/em&gt; serviceaccount with all required permissions to build and push an image and which is used by PipelineRuns:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;oc get sa pipeline
NAME SECRETS AGE
pipeline 2 15s&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_create_a_task"&gt;Create a Task&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A Task is the smallest block of a Pipeline which by itself can contain one or more steps which are executed in order to process a specific element. For each Task a pod is allocated and each step is running in a container inside this pod. Tasks are reusable by other Pipelines. &lt;em&gt;Input&lt;/em&gt; and &lt;em&gt;Output&lt;/em&gt; specifications can be used to interact with other Tasks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Let’s create two tasks &lt;a href="https://github.com/openshift/pipelines-tutorial/blob/master/01_pipeline" target="_blank" rel="noopener"&gt;Source: Pipeline-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; deploy-Example-Tasks.yaml
apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
name: apply-manifests
spec:
inputs:
resources:
- {type: git, name: source}
params:
- name: manifest_dir
description: The directory in source that contains yaml manifests
type: string
default: &amp;#34;k8s&amp;#34;
steps:
- name: apply
image: quay.io/openshift/origin-cli:latest
workingDir: /workspace/source
command: [&amp;#34;/bin/bash&amp;#34;, &amp;#34;-c&amp;#34;]
args:
- |-
echo Applying manifests in $(inputs.params.manifest_dir) directory
oc apply -f $(inputs.params.manifest_dir)
echo -----------------------------------
---
apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
name: update-deployment
spec:
inputs:
resources:
- {type: image, name: image}
params:
- name: deployment
description: The name of the deployment patch the image
type: string
steps:
- name: patch
image: quay.io/openshift/origin-cli:latest
command: [&amp;#34;/bin/bash&amp;#34;, &amp;#34;-c&amp;#34;]
args:
- |-
oc patch deployment $(inputs.params.deployment) --patch=&amp;#39;{&amp;#34;spec&amp;#34;:{&amp;#34;template&amp;#34;:{&amp;#34;spec&amp;#34;:{
&amp;#34;containers&amp;#34;:[{
&amp;#34;name&amp;#34;: &amp;#34;$(inputs.params.deployment)&amp;#34;,
&amp;#34;image&amp;#34;:&amp;#34;$(inputs.resources.image.url)&amp;#34;
}]
}}}}&amp;#39;
EOF&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;oc create -f deploy-Example-Tasks.yaml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Verify that the two tasks have been created using the Tekton CLI:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;tkn task ls
NAME AGE
apply-manifests 52 seconds ago
update-deployment 52 seconds ago&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_create_a_pipeline"&gt;Create a Pipeline&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A pipeline is a set of Tasks, which should be executed in a defined way to achieve a specific goal.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The example Pipeline below uses two resources:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git-repo: defines the Git-Source&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;image: Defines the target at a repository&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It first uses the Task &lt;strong&gt;buildah&lt;/strong&gt;, which is a standard Task the OpenShift operator created automatically. This task will build the image. The resulted image is pushed to an image registry, defined in the &lt;strong&gt;output&lt;/strong&gt; parameter. After that our created tasks &lt;strong&gt;apply-manifest&lt;/strong&gt; and &lt;strong&gt;update-deployment&lt;/strong&gt; are executed. The execution order of these tasks is defined with the &lt;strong&gt;runAfter&lt;/strong&gt; Parameter in the yaml definition.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
The Pipeline should be re-usable accross multiple projects or environments, thats why the resources (git-repo and image) are not defined here. When a Pipeline is executed, these resources will get defined.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; deploy-Example-Pipeline.yaml
apiVersion: tekton.dev/v1alpha1
kind: Pipeline
metadata:
name: build-and-deploy
spec:
resources:
- name: git-repo
type: git
- name: image
type: image
params:
- name: deployment-name
type: string
description: name of the deployment to be patched
tasks:
- name: build-image
taskRef:
name: buildah
kind: ClusterTask
resources:
inputs:
- name: source
resource: git-repo
outputs:
- name: image
resource: image
params:
- name: TLSVERIFY
value: &amp;#34;false&amp;#34;
- name: apply-manifests
taskRef:
name: apply-manifests
resources:
inputs:
- name: source
resource: git-repo
runAfter:
- build-image
- name: update-deployment
taskRef:
name: update-deployment
resources:
inputs:
- name: image
resource: image
params:
- name: deployment
value: $(params.deployment-name)
runAfter:
- apply-manifests
EOF&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;oc create -f deploy-Example-Pipeline.yaml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Verify that the Pipeline has been created using the Tekton CLI:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;tkn pipeline ls
NAME AGE LAST RUN STARTED DURATION STATUS
build-and-deploy 3 seconds ago --- --- --- ---&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_trigger_pipeline"&gt;Trigger Pipeline&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;After the Pipeline has been created, it can be triggered to execute the Tasks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_create_pipelineresources"&gt;Create PipelineResources&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Since the Pipeline is generic, we need to define 2 &lt;strong&gt;PipelineResources&lt;/strong&gt; first, to execute a Pipepline.
Our example application contains a frontend (vote-ui) AND a backend (vote-api), therefore 4 PipelineResources will be created. (2 times git repository to clone the source and 2 time output image)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Quick overview:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ui-repo: will be used as &lt;em&gt;git_repo&lt;/em&gt; in the Pipepline for the Frontend&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ui-image: will be used as &lt;em&gt;image&lt;/em&gt; in the Pipeline for the Frontend&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api-repo: will be used as &lt;em&gt;git_repo&lt;/em&gt; in the Pipepline for the Backend&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api-image: will be used as &lt;em&gt;image&lt;/em&gt; in the Pipeline for the Backend&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; deploy-Example-PipelineResources.yaml
apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
name: ui-repo
spec:
type: git
params:
- name: url
value: http://github.com/openshift-pipelines/vote-ui.git
---
apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
name: ui-image
spec:
type: image
params:
- name: url
value: image-registry.openshift-image-registry.svc:5000/pipelines-tutorial/vote-ui:latest
---
apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
name: api-repo
spec:
type: git
params:
- name: url
value: http://github.com/openshift-pipelines/vote-api.git
---
apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
name: api-image
spec:
type: image
params:
- name: url
value: image-registry.openshift-image-registry.svc:5000/pipelines-tutorial/vote-api:latest
EOF&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;oc create -f deploy-Example-PipelineResources.yaml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The resources can be listed with:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;tkn resource ls
NAME TYPE DETAILS
api-repo git url: http://github.com/openshift-pipelines/vote-api.git
ui-repo git url: http://github.com/openshift-pipelines/vote-ui.git
api-image image url: image-registry.openshift-image-registry.svc:5000/pipelines-tutorial/vote-api:latest
ui-image image url: image-registry.openshift-image-registry.svc:5000/pipelines-tutorial/vote-ui:latest&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_execute_pipelines"&gt;Execute Pipelines&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We start a PipelineRune for the backend and frontend of our application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; deploy-Example-PipelineRun.yaml
apiVersion: tekton.dev/v1alpha1
kind: PipelineRun
metadata:
name: build-deploy-api-pipelinerun
spec:
pipelineRef:
name: build-and-deploy
resources:
- name: git-repo
resourceRef:
name: api-repo
- name: image
resourceRef:
name: api-image
params:
- name: deployment-name
value: vote-api
---
apiVersion: tekton.dev/v1alpha1
kind: PipelineRun
metadata:
name: build-deploy-ui-pipelinerun
spec:
pipelineRef:
name: build-and-deploy
resources:
- name: git-repo
resourceRef:
name: ui-repo
- name: image
resourceRef:
name: ui-image
params:
- name: deployment-name
value: vote-ui
EOF&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;oc create -f deploy-Example-PipelineRun.yaml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The PipelineRuns can be listed with&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;tkn pipelinerun ls
NAME STARTED DURATION STATUS
build-deploy-api-pipelinerun 3 minutes ago --- Running
build-deploy-ui-pipelinerun 3 minutes ago --- Running&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Moreover, the logs can be viewed with the following command and select the appropriate PipelineRun:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash" data-lang="bash"&gt;tkn pipeline logs -f
? Select pipelinerun: [Use arrows to move, type to filter]
&amp;gt; build-deploy-api-pipelinerun started 2 minutes ago
build-deploy-ui-pipelinerun started 2 minutes ago&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_checking_your_application"&gt;Checking your application&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now our Pipeline built and deployed the voting application, where you can vote if you prefere cats or dogs (Cats or course :) )&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Get the route of your project and open the URL in the browser. (Should be something like vote-ui-pipelines-tutorial.apps.yourclustername)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;img src="https://blog.stderr.at/openshift-platform/other-topics/images/pipelines/Tekton-Vote-App.png" alt="Tekton Vote App"/&gt;
&lt;/div&gt;
&lt;div class="title"&gt;Figure 1. Tekton: Example Application&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_openshift_webui"&gt;OpenShift WebUI&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;With the OpenShift Pipeline operator a new menu item is introduced on the WebUI of OpenShift. All Tekton CLI command which are used above, can actually be replaced with the web interface, in case you prefere this. The big advantage is th graphical presentation of Pipelines and their lifetime.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I will not create screenshots for every screen, but for example pipelines:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Under &lt;em&gt;Pipelines&lt;/em&gt; a list of pipelines will be shown.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;img src="https://blog.stderr.at/openshift-platform/other-topics/images/pipelines/Pipelines.png" alt="Pipelines"/&gt;
&lt;/div&gt;
&lt;div class="title"&gt;Figure 2. OpenShift UI: List of Pipelines&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_additional_resources"&gt;Additional Resources&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_sources"&gt;Sources&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a id="source_1"&gt;&lt;/a&gt;[1]: &lt;a href="https://github.com/openshift/pipelines-tutorial" target="_blank" rel="noopener"&gt;OpenShift Pipelines Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://tekton.dev/"&gt;Tekon&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/tektoncd/catalog" target="_blank" rel="noopener"&gt;Tekton Task Catalog&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item></channel></rss>