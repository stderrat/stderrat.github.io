<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>MTLS on TechBlog about OpenShift/Ansible/Satellite and much more</title><link>https://blog.stderr.at/tags/mtls/</link><description>TechBlog about OpenShift/Ansible/Satellite and much more</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Toni Schmidbauer &amp; Thomas Jungbauer</copyright><lastBuildDate>Wed, 08 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stderr.at/tags/mtls/index.xml" rel="self" type="application/rss+xml"/><item><title>Mutual TLS Authentication</title><link>https://blog.stderr.at/service-mesh/2020/04/mutual-tls-authentication/</link><pubDate>Wed, 08 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/mutual-tls-authentication/</guid><description>&lt;div class="paragraph">
&lt;p>When more and more microservices are involved in an application, more and more traffic is sent on the network. It should be considered to secure this traffic, to prevent the possibility to inject malicious packets. Mutual TLS/mTLS authentication or two-way authentication offers a way to encrypt service traffic with certificates.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With Red Hat OpenShift Service Mesh, Mutual TLS can be used without the microservice knowing that it is happening. The TLS is managed completely by the Service Mesh Operator between two Envoy proxies using a defined mTLS policy.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Issue 9 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> will explain how to enable Mutual TLS inside the Service Mesh to secure the traffic between the different microservices.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_how_does_it_work">How does it work?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>If a microservice sends a request to a server, it must pass the local sidecar Envoy proxy first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The proxy will intercept the outbound request and starts a mutual TLS handshake with the proxy at the server side. During this handshake the certificates are exchanged and loaded into the proxy containers by Service Mesh.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The client side Envoy starts a mutual TLS handshake with the server side Envoy.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The client proxy does a secure naming check on the server’s certificate to verify that the identity in the certificate is authorized.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A mutual TLS connection is established between the client and the server.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Envoy proxy at the server sides decrypts the traffic and forwards it to the application through a local TCP connection.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparations">Preparations&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Before we can start be sure that the services are setup like in &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Issue #3&lt;/a>.&lt;br/>
In addition, be sure that the following DestinationRule already exists:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
version: v1
name: version-v1
- labels:
version: v2
name: version-v2&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Now we will create a pod, which is running outside of the Service Mesh. It will not have a sidecar proxy and will simply curl our application.&lt;/p>
&lt;div class="paragraph">
&lt;p>Store the following yaml and create the object in our cluster.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
labels:
app: curl
version: v1
name: curl
spec:
replicas: 1
selector:
matchLabels:
app: curl
version: v1
template:
metadata:
labels:
app: curl
version: v1
annotations: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
sidecar.istio.io/proxyCPU: &amp;#34;500m&amp;#34;
sidecar.istio.io/proxyMemory: 400Mi
spec:
containers:
- image: quay.io/maistra_demos/curl:latest
command: [&amp;#34;/bin/sleep&amp;#34;, &amp;#34;3650d&amp;#34;]
imagePullPolicy: Always
name: curl&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>since no sidecar is injected (sidecar.istio.io/inject: &amp;#34;true&amp;#34;), only 1 container will be started.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The traffic coming from the microservice &lt;em>customer&lt;/em> AND from the external client &lt;em>curl&lt;/em> must be simulated. To achieve this the following shell script can be used:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">#!/bin/sh
export CURL_POD=$(oc get pods -n tutorial -l app=curl | grep curl | awk &amp;#39;{ print $1}&amp;#39; )
export CUSTOMER_POD=$(oc get pods -n tutorial -l app=customer | grep customer | awk &amp;#39;{ print $1}&amp;#39; )
echo &amp;#34;A load generating script is running in the next step. Ctrl+C to stop&amp;#34;
while :; do
echo &amp;#34;Executing curl in curl pod&amp;#34;
oc exec -n tutorial $CURL_POD -- curl -s http://preference:8080 &amp;gt; /dev/null
sleep 0.5
echo &amp;#34;Executing curl in customer pod&amp;#34;
oc exec -n tutorial $CUSTOMER_POD -c customer -- curl -s http://preference:8080 &amp;gt; /dev/null
sleep 0.5
done&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>By executing this, it will first execute a curl command out of the &lt;em>curl&lt;/em> pod and then the same curl command out of the &lt;em>customer&lt;/em> container.
&lt;strong>Kepp this script running&lt;/strong>&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_enabling_mutual_tls">Enabling Mutual TLS&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Lets execute the shell script above and verify Kiali. As you notice there are requests coming from the &lt;em>customer&lt;/em> microservice and from the source called &lt;em>unknown&lt;/em>, which is the curl-service running outside the Service Mesh.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_1.png" alt="Kiali mtls 1"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali: traffic coming from customer microserver and external pod&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Enable the policy by creating the following object:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;preference-mutualtls&amp;#34;
spec:
targets:
- name: preference
peers:
- mtls:
mode: STRICT &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We are enforcing mtls for the target preference&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds the curl pod cannot reach the application anymore:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">Executing curl in curl pod
command terminated with exit code 56
Executing curl in customer pod
Executing curl in curl pod
command terminated with exit code 56
Executing curl in customer pod
Executing curl in curl pod
command terminated with exit code 5&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is expected, since the &lt;em>preference&lt;/em> service allows traffic over mutual TLS only. This was enforced by the Policy object (&lt;strong>STRICT&lt;/strong> mode). The &lt;em>customer&lt;/em> service, which is running inside the Service Mesh receives the error &amp;#34;5053 Service Unavalable&amp;#34; since it tries to send traffic, but it does not know yet to use mTLS.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali you will see the following:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_2.png" alt="Kiali mtls 2"/>
&lt;/div>
&lt;div class="title">Figure 2. Kiali: traffic is blocked&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The &lt;em>curl&lt;/em> pod is greyed out, since the traffic it tries to send, never reaches the preference service and is therefor not counted in the metric.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To make &lt;em>customer&lt;/em> aware that mutual TLS shall be used, a DestinationRule must be configured:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;networking.istio.io/v1alpha3&amp;#34;
kind: &amp;#34;DestinationRule&amp;#34;
metadata:
name: &amp;#34;preference-destination-rule&amp;#34;
spec:
host: &amp;#34;preference&amp;#34;
trafficPolicy:
tls:
mode: ISTIO_MUTUAL &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Let’s use mTLS&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This defines that &lt;strong>ISTIO_MUTUAL&lt;/strong> shall be used for the service &lt;em>preference&lt;/em>. The &lt;em>customer&lt;/em> service recognizes this and automatically enables mTLS. After a few minutes the traffic graph in Kiali will show &amp;#34;green&amp;#34; traffic from &lt;em>customer&lt;/em> through &lt;em>preference&lt;/em> to _recommendation:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_3.png" alt="Kiali mtls 3"/>
&lt;/div>
&lt;div class="title">Figure 3. Kiali: traffic for Service Mesh components is fine again.&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_mutual_tls_migration">Mutual TLS Migration&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As you can see in the previous section, the &lt;em>curl&lt;/em> pod cannot reach the application inside the Service Mesh. This happens because &lt;em>prefernce&lt;/em> is strictly enforcing encrypted traffic, but &lt;em>curl&lt;/em> only sends plain text. Luckily, Istio provides a method to gradually monitor the traffic and migrate to mTLS. Instead of STRICT mode PERMISSIVE can be used. Enabling permissive mode, &lt;em>preference&lt;/em> will accept both, encrypted and plain-text traffic.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Replace the Policy object with the following configuration:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;preference-mutualtls&amp;#34;
spec:
targets:
- name: preference
peers:
- mtls:
mode: PERMISSIVE&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f Policy-permissive.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now let’s wait a few minutes and observe Kiali, which should end up with:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_4.png" alt="Kiali mtls 4"/>
&lt;/div>
&lt;div class="title">Figure 4. Kiali: Encrypted and Plain-Text traffic&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see with the lock icon, the traffic between &lt;em>cunstomer&lt;/em> and &lt;em>preference&lt;/em> is encrypted, while the traffic from &lt;em>unknown&lt;/em> (which is our curl pod), is plain-text.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The errors you may see in Kiali happen due a known issue: &lt;a href="https://issues.jboss.org/browse/MAISTRA-1000" class="bare">https://issues.jboss.org/browse/MAISTRA-1000&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_cleanup">Cleanup&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Clean up your environment:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete policy -n tutorial preference-mutualtls
oc delete destinationrule -n tutorial preference-destination-rule&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item></channel></rss>