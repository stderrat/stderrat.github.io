<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Rekor on TechBlog about OpenShift/Ansible/Satellite and much more</title><link>https://blog.stderr.at/tags/rekor/</link><description>TechBlog about OpenShift/Ansible/Satellite and much more</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Toni Schmidbauer &amp; Thomas Jungbauer</copyright><lastBuildDate>Wed, 28 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stderr.at/tags/rekor/index.xml" rel="self" type="application/rss+xml"/><item><title>Secure Supply Chain</title><link>https://blog.stderr.at/securesupplychain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/securesupplychain/</guid><description/></item><item><title>Introduction to a Secure Supply Chain</title><link>https://blog.stderr.at/securesupplychain/2023-06-15-securesupplychain-intro/</link><pubDate>Wed, 28 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/securesupplychain/2023-06-15-securesupplychain-intro/</guid><description>&lt;div class="paragraph">
&lt;p>The goal of the following (&amp;#34;short&amp;#34;) series is to build a secure CI/CD pipeline step by step using OpenShift Pipelines (based on Tekton).
The whole build process shall pull and build an image, upload it to a development environment and subsequently update the production environment.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The main focus here is security. Several steps and tools shall help to build and deploy a &lt;strong>Secure Supply Chain&lt;/strong>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The whole process is part of a Red Hat workshop which can present to your organization. I did some tweaks and created a step-by-step plan in order
to remember it …​ since I am getting old :)&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_journey_to_secure_supply_chain">The Journey to Secure Supply Chain&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>This series includes the following articles:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step1/">Listen to Events&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step2/">Pipelines&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step3/">SonarQube&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step4/">Verify Git Commit&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step5/">Build and Sign Image&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step6/">Scanning with ACS&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step7/">Generating a SBOM&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step8/">Updating Kubernetes Manifests&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step9/">Linting Kubernetes Manifests&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step10/">The Example Application&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step11/">ACS Deployment Check&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step12/">Verify TLOG Signature&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/securesupplychain/step13/">Bring it to Production&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In order to develop our Secure Supply Chain, we need an &lt;strong>OpenShift 4 Cluster&lt;/strong>. I am currently using OpenShift 4.13.
Moreover, the &lt;strong>OpenShift Pipelines&lt;/strong> operator must be deployed. It is based on &lt;a href="https://tekton.dev/" target="_blank" rel="noopener">Tekton&lt;/a> and provides a Kubernetes-native way to create CI/CD pipelines.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The operator is deployed using the Operator Hub inside your cluster. Simply search for OpenShift Pipelines and install the operator using the default settings.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/intro-install_Tekton_Operator.png?width=220px" alt="OpenShift Pipelines"/>
&lt;/div>
&lt;div class="title">Figure 1. Install OpenShift Pipelines&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Finally, you will need a GitHub account to be able to fork some repositories.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Some steps in the pipeline are working tightly with GitHub, especially the very last one that is talking GitHub’s API. However, any Git-system should work, and probably just minor changes will be required.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Everything else will be installed during the different steps described in the upcoming articles, while we build and tweak our pipeline.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Remember, the big goal of our pipeline is NOT to simply pull, build and push our code, but to integrate certain security tools like code scanning, image scanning and linting.
Otherwise, it would be boring.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_used_tools">Used Tools&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The following list of tools (or specifications) are used for our pipeline. They will be deployed when the appropriate step requires it.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://docs.openshift.com/acs/4.1/welcome/index.html" target="_blank" rel="noopener">Advanced Cluster Security&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.openshift.com/acs/4.1/cli/getting-started-cli.html" target="_blank" rel="noopener">roxctl&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.sonarsource.com/products/sonarqube/" target="_blank" rel="noopener">SonarQube&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.redhat.com/en/technologies/cloud-computing/quay" target="_blank" rel="noopener">Quay - quay.io as public registry&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.sigstore.dev/cosign/overview/" target="_blank" rel="noopener">CoSign (sigstore)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.sigstore.dev/rekor/overview/" target="_blank" rel="noopener">Rekor (sigstore)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://cyclonedx.org/capabilities/sbom/" target="_blank" rel="noopener">Software Bill of Material (SBOM)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.kubelinter.io/#/" target="_blank" rel="noopener">KubeLinter&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://kube-score.com/" target="_blank" rel="noopener">KubeScore&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/adrienverge/yamllint" target="_blank" rel="noopener">YamlLint&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/looztra/kubesplit" target="_blank" rel="noopener">kubesplit&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Step 12 - Verify TLog Signature</title><link>https://blog.stderr.at/securesupplychain/2023-06-27-securesupplychain-step12/</link><pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/securesupplychain/2023-06-27-securesupplychain-step12/</guid><description>&lt;div class="paragraph">
&lt;p>Since the image has been deployed on DEV now, we need to prepare everything for production. Before we start, we need to confirm that the whole signing process has been passed and that our signature has been applied correctly. With CoSign we signed our image and used Rekor to create a transparency log. We will use this log to confirm that the image was signed.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_goals">Goals&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The goals of this step are:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Verify if the image has been signed using Rekor transparency log.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_cosign_public_key">CoSign public key&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before we start, we need a secret in the Namespace &lt;strong>ci&lt;/strong> that provides the PUBLIC key of CoSign. This key was generated in a previous &lt;a href="https://blog.stderr.at/securesupplychain/2023-06-20-securesupplychain-step5/#_cosign_signing_the_image">Step 5 - CoSign - Signing the Image&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">kind: Secret
apiVersion: v1
metadata:
name: cosign-secret &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: ci
data:
cosign.pub: &amp;gt;-
&amp;lt;base64 CoSign PUBLIC key&amp;gt;
type: Opaque&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>base64 decoded PUBLIC key of CoSign&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_the_task">Create the Task&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The following task will use several steps to fetch and parse the transparency log, that has been created. The different tasks are using images from &lt;strong>Redhat-gpte&lt;/strong>. The command line tool &lt;strong>rekor-cli&lt;/strong> will be used to verify the entries in the log.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
name: rekor-verify
namespace: ci
spec:
params:
- default: image-registry-secret &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
name: registrySecret
type: string
- default: cosign-secret &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
name: cosignSecret
type: string
- default: &amp;gt;-
quay.io/placeholder/test:latest
name: image
type: string
- default: &amp;#39;quay.io/tjungbau/pipeline-tools:v1.1.0&amp;#39;
name: pipelinetoolsImage
type: string
steps:
- env:
- name: REGISTRY_SECRET
valueFrom:
secretKeyRef:
key: .dockerconfigjson
name: $(params.registrySecret)
- name: COSIGN_PUBLIC_KEY
valueFrom:
secretKeyRef:
key: cosign.pub
name: $(params.cosignSecret)
image: $(params.pipelinetoolsImage)
name: cosign-verify-image
resources: {}
script: &amp;gt;
mkdir -p /home/cosign/.docker/
echo &amp;#34;${REGISTRY_SECRET}&amp;#34; &amp;gt; /home/cosign/.docker/config.json
echo &amp;#34;${COSIGN_PUBLIC_KEY}&amp;#34; &amp;gt; /workspace/cosign.pub
cosign verify --key /workspace/cosign.pub $(params.image) --output-file
/workspace/cosign.verify
cat /workspace/cosign.verify | jq --raw-output &amp;#39;.[0] | .critical |
.image | .[&amp;#34;docker-manifest-digest&amp;#34;]&amp;#39; &amp;gt; /workspace/cosign.sha
rekor-cli search --sha $(cat /workspace/cosign.sha) --format json &amp;gt;
/workspace/rekor.search
cat /workspace/rekor.search | jq &amp;#39;.UUIDs[0]&amp;#39; | sed &amp;#39;s/\&amp;#34;//g&amp;#39; &amp;gt;
/workspace/rekor.uuid
rekor-cli get --uuid $(cat /workspace/rekor.uuid) --format json &amp;gt;
/workspace/rekor.get
cat /workspace/rekor.get | jq -r .Attestation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Registry pull secret.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>CoSign public key.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_update_the_pipeline">Update the Pipeline&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The Pipeline object must be extended with another Task:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> - name: verify-tlog-signature
params: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
- name: registrySecret &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
value: tjungbau-secure-supply-chain-demo-pull-secret
- name: cosignSecret &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
value: cosign-secret
- name: image
value: &amp;#39;$(params.IMAGE_REPO):$(params.IMAGE_TAG)&amp;#39;
runAfter: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- yaml-lint
- kube-score
- kube-linter
taskRef:
kind: Task
name: rekor-verify&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The parameters required for this task.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Pull secret for quay.io, which was created during step 5.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>CoSign public key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>This task runs after the linting tasks.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_execute_the_pipeline">Execute the Pipeline&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Triggering the pipeline will now check the signature of an image.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The logs should show something like this:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step12-signature_verification.png" alt="Rekor Image Signature Verification"/>
&lt;/div>
&lt;div class="title">Figure 1. Rekor Image Signature Verification&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see: The image has been signed correctly and the transparency logs can be parsed.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_summary">Summary&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Finally, everything has been verified and we can bring everything into production. The final two steps will create a new branch in the Git manifest repository and a pull request that can be manually merged.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Step 13 - Bring it to Production</title><link>https://blog.stderr.at/securesupplychain/2023-06-28-securesupplychain-step13/</link><pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/securesupplychain/2023-06-28-securesupplychain-step13/</guid><description>&lt;div class="paragraph">
&lt;p>If you reached this article, congratulations! You read through tons of pages to build up a Pipeline. The last two steps in our Pipeline are: Creating a new branch and creating a pull request, with the changes of the image tag that must be approved and will be merged then (We will not update the main branch directly!). Finally, we will do a &amp;#34;real&amp;#34; update to the application to see the actual changes.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_goals">Goals&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The goals of this step are:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Create a task that creates a new branch in Git repository.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create a task that creates a pull request in Git repository.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Perform a full End2End run of the Pipeline and approve the pull request.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_a_token_at_github">Create a token at GitHub&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To create a pull request we need to authenticate against the Git api. For this, we will need a token. In GitHub open your personal settings (by clicking on your avatar) and then go to &amp;#34;Developer settings&amp;#34;.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Select &amp;#34;Personal access tokens&amp;#34; and &amp;#34;fine-graining tokens&amp;#34; to create a new token.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-github_pta.png?width=400px" alt="GitHub Personal Access Token"/>
&lt;/div>
&lt;div class="title">Figure 1. GitHub Personal Access Token&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Enter the required fields:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Name: Secure Supply Chain&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Expiration: Whatever your like (max is 1 year)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Repository access: Only select repositories&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select your repository, for example: tjungbauer/securing-software-supply-chain&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Permissions: &amp;#34;Pull requests&amp;#34; &amp;gt; Read and write&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-github_pta_created.png?width=600px" alt="GitHub Personal Access Token Created"/>
&lt;/div>
&lt;div class="title">Figure 2. GitHub Personal Access Token Created&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Save the created token and create the following secret:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">kind: Secret
apiVersion: v1
metadata:
name: github-token
namespace: ci
stringData:
token: &amp;lt;Token Value&amp;gt; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
type: Opaque&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Clear-text token. If already base64 encoded, change &lt;em>stringData&lt;/em> to &lt;em>data&lt;/em>.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_task_create_a_new_branch">Task: Create a new branch&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Since we do not update the main branch directly, we will create a new (feature) branch, that will be used for a pull request and can be deleted after the pull request has been merged.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create the following Task object&lt;/p>
&lt;div class="paragraph">
&lt;p>This Task will use git commands to create a new feature-branch and pushes the changes into that branch.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
name: new-branch-manifest-repo
namespace: ci
spec:
description: &amp;gt;-
This task creates a branch for a PR to point to the image tag created with
the short commit.
params:
- description: Used to tag the built image.
name: image
type: string
- default: main
description: Target branch to push to
name: target-branch
type: string
- default: Tekton Pipeline
description: Git user name for performing the push operation.
name: git_user_name
type: string
- default: tekton@tekton.com
description: Git user email for performing the push operation.
name: git_user_email
type: string
- description: File in which the image configuration is stored.
name: configuration_file
type: string
- description: Repo in which the image configuration is stored.
name: repository
type: string
- default: &amp;#39;registry.redhat.io/openshift-pipelines/pipelines-git-init-rhel8:v1.10.4-4&amp;#39;
name: gitInit
type: string
steps:
- image: $(params.gitInit)
name: git
resources: {}
script: &amp;gt;-
# Setting up the git config.
git config --global user.email &amp;#34;$(params.git_user_email)&amp;#34;
git config --global user.name &amp;#34;$(params.git_user_name)&amp;#34;
# Checkout target branch to avoid the detached HEAD state
TMPDIR=$(mktemp -d)
cd $TMPDIR
git clone $(params.repository) &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
cd securing-software-supply-chain
git checkout -b $(params.target-branch) &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# Set to the short commit value passed as parameter.
# Notice the enclosing &amp;#34; to keep it as a string in the resulting YAML.
IMAGE=\&amp;#34;$(params.image)\&amp;#34;
sed -i &amp;#34;s#\(.*value:\s*\).*#\1 ${IMAGE}#&amp;#34; $(params.configuration_file)
git add $(params.configuration_file) &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
git commit -m &amp;#34;Automatically updated manifest to point to image tag
$IMAGE&amp;#34;
git push origin $(params.target-branch)&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Clone the main repository.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Create a new feature branch.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Add, commit, and push everything to the new branch.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Modify the Pipeline object&lt;/p>
&lt;div class="paragraph">
&lt;p>The Task must be added to the Pipeline, it provides several required parameters.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> - name: create-prod-manifest-branch
params:
- name: image
value: &amp;#39;$(params.IMAGE_REPO):$(params.IMAGE_TAG)&amp;#39;
- name: configuration_file
value: $(params.MANIFEST_FILE_PROD)
- name: repository
value: $(params.MANIFEST_REPO)
- name: git_user_name
value: $(params.COMMIT_AUTHOR)
- name: target-branch
value: feature-for-$(params.COMMIT_SHA)
runAfter:
- acs-deploy-check
- verify-tlog-signature
taskRef:
kind: Task
name: new-branch-manifest-repo&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_task_create_a_pull_request">Task: Create a Pull request&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create the following Task object&lt;/p>
&lt;div class="paragraph">
&lt;p>The following task will take the token and create a new pull request at GitHub:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
name: git-open-pull-request
namespace: ci
spec:
description: &amp;gt;-
This task will open a PR on Github based on several parameters. This could
be useful in GitOps repositories for example.
params:
- default: api.github.com
description: |
The GitHub host, adjust this if you run a GitHub enteprise or Gitea
name: GITHUB_HOST_URL
type: string
- default: &amp;#39;&amp;#39;
description: |
The API path prefix, GitHub Enterprise has a prefix e.g. /api/v3
name: API_PATH_PREFIX
type: string
- description: |
The GitHub repository full name, e.g.: tektoncd/catalog
name: REPO_FULL_NAME
type: string
- default: github
description: &amp;gt;
The name of the kubernetes secret that contains the GitHub token,
default: github
name: GITHUB_TOKEN_SECRET_NAME
type: string
- default: token
description: &amp;gt;
The key within the kubernetes secret that contains the GitHub token,
default: token
name: GITHUB_TOKEN_SECRET_KEY
type: string
- default: Bearer
description: &amp;gt;
The type of authentication to use. You could use the less secure &amp;#34;Basic&amp;#34;
for example
name: AUTH_TYPE
type: string
- description: |
The name of the branch where your changes are implemented.
name: HEAD
type: string
- description: |
The name of the branch you want the changes pulled into.
name: BASE
type: string
- description: |
The body description of the pull request.
name: BODY
type: string
- description: |
The title of the pull request.
name: TITLE
type: string
- default: &amp;#39;registry.access.redhat.com/ubi8/python-38:1&amp;#39;
name: ubi8PythonImage
type: string
results:
- description: Number of the created pull request.
name: NUMBER
type: string
- description: URL of the created pull request.
name: URL
type: string
steps:
- env:
- name: PULLREQUEST_NUMBER_PATH
value: $(results.NUMBER.path)
- name: PULLREQUEST_URL_PATH
value: $(results.URL.path)
image: $(params.ubi8PythonImage)
name: open-pr
resources: {}
script: &amp;gt;-
#!/usr/libexec/platform-python &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
&amp;#34;&amp;#34;&amp;#34;This script will open a PR on Github&amp;#34;&amp;#34;&amp;#34;
import json
import os
import sys
import http.client
github_token = &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
open(&amp;#34;/etc/github-open-pr/$(params.GITHUB_TOKEN_SECRET_KEY)&amp;#34;,
&amp;#34;r&amp;#34;).read()
open_pr_url = &amp;#34;/repos/$(params.REPO_FULL_NAME)/pulls&amp;#34;
data = { &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
&amp;#34;head&amp;#34;: &amp;#34;$(params.HEAD)&amp;#34;,
&amp;#34;base&amp;#34;: &amp;#34;$(params.BASE)&amp;#34;,
&amp;#34;title&amp;#34;: &amp;#34;&amp;#34;&amp;#34;$(params.TITLE)&amp;#34;&amp;#34;&amp;#34;,
&amp;#34;body&amp;#34;: &amp;#34;&amp;#34;&amp;#34;$(params.BODY)&amp;#34;&amp;#34;&amp;#34;
}
print(&amp;#34;Sending this data to GitHub: &amp;#34;)
print(data)
authHeader = &amp;#34;Bearer &amp;#34; + github_token
giturl = &amp;#34;api.&amp;#34;+&amp;#34;$(params.GITHUB_HOST_URL)&amp;#34;
conn = http.client.HTTPSConnection(giturl)
conn.request(
&amp;#34;POST&amp;#34;,
open_pr_url,
body=json.dumps(data),
headers={
&amp;#34;User-Agent&amp;#34;: &amp;#34;OpenShift Pipelines&amp;#34;,
&amp;#34;Authorization&amp;#34;: authHeader.strip(),
&amp;#34;Accept&amp;#34;: &amp;#34;application/vnd.github+json&amp;#34;,
&amp;#34;Content-Type&amp;#34;: &amp;#34;application/json&amp;#34;,
&amp;#34;X-GitHub-Api-Version&amp;#34;: &amp;#34;2022-11-28&amp;#34;
})
resp = conn.getresponse()
if not str(resp.status).startswith(&amp;#34;2&amp;#34;):
print(&amp;#34;Error: %d&amp;#34; % (resp.status))
print(resp.read())
sys.exit(1)
else:
# https://docs.github.com/en/rest/reference/pulls#create-a-pull-request
body = json.loads(resp.read().decode())
open(os.environ.get(&amp;#39;PULLREQUEST_NUMBER_PATH&amp;#39;), &amp;#39;w&amp;#39;).write(f&amp;#39;{body[&amp;#34;number&amp;#34;]}&amp;#39;)
open(os.environ.get(&amp;#39;PULLREQUEST_URL_PATH&amp;#39;), &amp;#39;w&amp;#39;).write(body[&amp;#34;html_url&amp;#34;])
print(&amp;#34;GitHub pull request created for $(params.REPO_FULL_NAME): &amp;#34;
f&amp;#39;number={body[&amp;#34;number&amp;#34;]} url={body[&amp;#34;html_url&amp;#34;]}&amp;#39;)
volumeMounts:
- mountPath: /etc/github-open-pr
name: githubtoken
readOnly: true
volumes:
- name: githubtoken
secret:
secretName: $(params.GITHUB_TOKEN_SECRET_NAME)&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Python script to create the pull request.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The token from the secret object.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The data we will send to GitHub.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Modify the Pipeline object&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> - name: issue-prod-pull-request
params:
- name: GITHUB_HOST_URL
value: $(params.REPO_HOST)
- name: GITHUB_TOKEN_SECRET_NAME
value: github-token
- name: REPO_FULL_NAME
value: $(params.MANIFEST_REPO_NAME)
- name: HEAD
value: feature-for-$(params.COMMIT_SHA)
- name: BASE
value: main
- name: BODY
value: Update prod image for $(params.COMMIT_MESSAGE)
- name: TITLE
value: &amp;#39;Production update: $(params.COMMIT_MESSAGE)&amp;#39;
runAfter:
- create-prod-manifest-branch
taskRef:
kind: Task
name: git-open-pull-request&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_review_the_whole_pipeline">Review the whole Pipeline&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>We did it, we created a Secure Supply Chain using Tekton Tasks. The full Pipeline now looks like this:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-pipeline.png" alt="Pipeline Details"/>
&lt;/div>
&lt;div class="title">Figure 3. Pipeline Details&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The last step will create a pull request on Git. When this request is approved and merged, the update will finally happen in the production environment. This is a manual process to have control what comes in production and what does not.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_execute_full_pipeline_e2e">Execute full Pipeline E2E&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>It is time to execute the whole pipeline now end to end. We will do a real update to the application now, so we can see the differences.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As described in step 10, the DEV and PROD environments are running on the same cluster. In the field, this will probably not happen, but for now, it is good enough. GitOps/Argo CD monitors any changes and automatically updates whenever the Git repository (Kubernetes Manifests) is changed. During the PipelineRun we will update the image tag for DEV, which automatically rolls out and create a Pull request which is waiting for approval and will roll out the changes onto production.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Both environments have a route to access the application. At the moment both will look the same:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-dev_origin.png?width=600px" alt="Globex DEV origin"/>
&lt;/div>
&lt;div class="title">Figure 4. Globex DEV origin&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_update_application">Update application&lt;/h3>
&lt;div class="paragraph">
&lt;p>The repository of Globex UI is forked at: &lt;a href="https://github.com/tjungbauer/globex-ui" class="bare">https://github.com/tjungbauer/globex-ui&lt;/a>. We used it throughout this journey to update the README.md file.
The readme file does not really change anything. So, let’s update the UI itself.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>look for the file &lt;strong>src/index.html&lt;/strong> and add the following line before &lt;code>&amp;lt;/body&amp;gt;&lt;/code>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-html" data-lang="html">&amp;lt;center&amp;gt;&amp;lt;strong&amp;gt;My very important update&amp;lt;/strong&amp;gt;&amp;lt;/center&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Save this change and push it to GitHub.
This will trigger the Pipeline which is running quite long. However, once it is finished, the DEV environment should now show the new line in the UI.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
After the pipeline updated the image tag in Git, the GitOps process must fetch this change. This may take a while. You can speed this up by refreshing the &amp;#34;Application&amp;#34; inside the Argo CD interface. It should then automatically synchronize.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The update can now be seen in the browser. The &amp;#34;important update&amp;#34; is visible at the bottom of the page.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-dev_updated.png?width=600px" alt="Globex DEV updated"/>
&lt;/div>
&lt;div class="title">Figure 5. Globex DEV updated&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The production environment was not yet updated. Instead, a pull request has been created:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-open_pr.png?width=600px" alt="Open pull request"/>
&lt;/div>
&lt;div class="title">Figure 6. Open pull request&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This request can be reviewed and merged. As you can see there was only one change in the files:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-pr_fileschanged.png" alt="Open pull request - changed files"/>
&lt;/div>
&lt;div class="title">Figure 7. Open pull request - changed files&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Merge the pull request and wait until Argo CD fetched the changes and updates the production environment. This is it, the changes are done and promoted to production:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/securesupplychain/images/step13-prod_updated.png?width=600px" alt="Globex PROD updated"/>
&lt;/div>
&lt;div class="title">Figure 8. Globex PROD updated&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>This concludes this journey to a Secure Supply Chain using Tekton (OpenShift Pipelines). Is this the best must-have you need to do? No, it is an example, a demonstration. Feel free to use and modify it. You can also use other tools for the tasks or the pipeline as such. It does not matter if you use Tekton, Jenkins, Gitlab Runner etc. What is important is that you secure your whole supply chain as much as possible.
Any image you create should be signed to ensure that the source can be trusted. Every source code should be verified against best practices and all images should be scanned for vulnerabilities and policy violations during the build AND the deployment process.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>YAUB Yet Another Useless Blog</title><link>https://blog.stderr.at/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/</guid><description>
&lt;h1 class="blog-title gradient-header">Welcome to Yet Another Useless Blog&lt;/h1>
&lt;p>Well we hope the articles here are not totally useless :)&lt;/p>
&lt;p>Who are we, you might ask.
We (Thomas Jungbauer and Toni Schmidbauer) are two old IT guys, working in the business since more than 20 years. At the moment we are architects at Red Hat Austria, mainly responsible helping customers with OpenShift or Ansible architectures. &lt;/p>
&lt;p>The articles in this blog shall help to easily test and understand specific issues so they can be reproduced and tested. We simply wrote down what we saw in the field and of what we thought it might be helpful, so no frustrating searches in documentations or manual testing is required. &lt;/p>
&lt;p>If you have any question, please feel free to send us an e-mail or create a &lt;a href="https://github.com/stderrat/stderrat.github.io/issues" >GitHub issue&lt;/a>&lt;/p></description></item></channel></rss>