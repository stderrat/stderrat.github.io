<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Istio on TechBlog about OpenShift/Ansible/Satellite and much more</title><link>https://blog.stderr.at/tags/istio/</link><description>TechBlog about OpenShift/Ansible/Satellite and much more</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Toni Schmidbauer &amp; Thomas Jungbauer</copyright><lastBuildDate>Sun, 31 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stderr.at/tags/istio/index.xml" rel="self" type="application/rss+xml"/><item><title>Service Mesh</title><link>https://blog.stderr.at/service-mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/</guid><description/></item><item><title>A second look into the Kubernetes Gateway API on OpenShift</title><link>https://blog.stderr.at/openshift/2025/08/a-second-look-into-the-kubernetes-gateway-api-on-openshift/</link><pubDate>Sun, 31 Aug 2025 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/openshift/2025/08/a-second-look-into-the-kubernetes-gateway-api-on-openshift/</guid><description>&lt;div class="paragraph">
&lt;p>This is our second look into the Kubernetes Gateway API an it’s
integration into OpenShift. This post covers TLS configuration.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Kubernetes Gateway API is new implementation of the ingress, load
balancing and service mesh API’s. See
&lt;a href="https://gateway-api.sigs.k8s.io/" target="_blank" rel="noopener">upstream&lt;/a> for more information.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Also the &lt;a href="https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/ingress_and_load_balancing/configuring-ingress-cluster-traffic#nw-ingress-gateway-api-overview_ingress-gateway-api" target="_blank" rel="noopener">OpenShift documentation&lt;/a> provides an overview of the Gateway API and it’s integration.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We demonstrate how to add TLS to our Nginx deployment, how to
implement a shared Gateway and finally how to implement HTTP to HTTPS
redirection with the Gateway API. Furthermore we cover how &lt;em>HTTPRoute&lt;/em>
objects attach to Gateways and dive into ordering of &lt;em>HTTPRoute&lt;/em>
objects.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_references">References&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/openshift/2025/08/gateway-api/">A first look into the Kubernetes Gateway API on OpenShift&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_adding_tls_to_our_nginx_deployment">Adding TLS to our Nginx deployment&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In our fist post we simply exposed a Nginx web server via the
Gateway API. We only enabled HTTP, so let’s try to do the same with
HTTPS now.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Remember we use a DNS wildcard domain &lt;code>*.gtw.ocp.lan.stderr.at&lt;/code> which
points to our Gateway. The gateway is exposed via a &lt;em>Service&lt;/em> of type
&lt;em>LoadBalancer&lt;/em>. We use
&lt;a href="https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/networking_operators/metallb-operator">MetalLB&lt;/a>
for this.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The first step is setting up a wildcard TLS certificate for our custom
domain &lt;em>*.gtw.ocp.lan.stderr.at&lt;/em>. We are using
&lt;a href="https://github.com/OpenVPN/easy-rsa">EasyRSA&lt;/a> here, but use whatever tool you like.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Just for reference this is how we created a wildcard cert with EasyRSA:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ EASYRSA_CERT_EXPIRE=3650 EASYRSA_EXTRA_EXTS=&amp;#34;subjectAltName=DNS:*.gtw.ocp.lan.stderr.at&amp;#34; ./easyrsa gen-req gtw.ocp.lan.stderr.at
$ EASYRSA_CERT_EXPIRE=3650 ./easyrsa sign-req serverClient gtw.ocp.lan.stderr.at&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>EasyRSA stores the public key under &lt;em>pki/issued&lt;/em> and the private key
under &lt;em>pki/private&lt;/em>. We copied the certificate and the private key to
a temporary directory.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Next we need to remove the private key passphrase and create a
Kubernetes secret from the private and pubic key:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ openssl rsa -in gtw.ocp.lan.stderr.at.key -out gtw.ocp.lan.stderr.at-insecure.key
$ oc create secret -n openshift-ingress tls gateway-api --cert=gtw.ocp.lan.stderr.at.crt --key=gtw.ocp.lan.stderr.at-insecure.key&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now it’s time to add a TLS listener to our &lt;em>Gateway&lt;/em> resource in the
&lt;em>openshift-ingress&lt;/em> namespace. Remember for the OpenShift Gateway API implementation, &lt;em>Gateways&lt;/em> have
to be deployed in the &lt;em>openshift-ingress&lt;/em> namespace.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
name: http-gateway
namespace: openshift-ingress
spec:
gatewayClassName: openshift-default
listeners:
- name: http
protocol: HTTP
port: 80
hostname: &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34;
- name: https
protocol: HTTPS &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
port: 443 &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
hostname: &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
tls:
mode: Terminate &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
certificateRefs:
- name: gateway-api &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
allowedRoutes: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
namespaces:
from: All&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We want to support HTTPS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>We use the default HTTPS port 443&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The URLs we support with this listener are the same as for HTTP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>We use edge termination for now, this means HTTP traffic will only be encrypted up to the gateway. From the gateway to our pod we speak plain HTTP.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>This is the name of the TLS secret we created above&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>We accept routes from all namespaces&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Also remember from our first post that we created a
&lt;em>ReferenceGrant&lt;/em> in the namespace where Nginx is running. Otherwise
HTTP routes will not be accepted.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Finally lets try to access our Nginx pod via HTTPS:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ curl -v https://nginx.gtw.ocp.lan.stderr.at
* Host nginx.gtw.ocp.lan.stderr.at:443 was resolved.
* IPv6: (none)
* IPv4: 10.0.0.150
* Trying 10.0.0.150:443...
* ALPN: curl offers h2,http/1.1
* TLSv1.3 (OUT), TLS handshake, Client hello (1):
* CAfile: /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
* CApath: none
* TLSv1.3 (IN), TLS handshake, Server hello (2):
* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):
* TLSv1.3 (IN), TLS handshake, Certificate (11):
* TLSv1.3 (IN), TLS handshake, CERT verify (15):
* TLSv1.3 (IN), TLS handshake, Finished (20):
* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):
* TLSv1.3 (OUT), TLS handshake, Finished (20):
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384 / x25519 / RSASSA-PSS
* ALPN: server accepted h2
* Server certificate:
* subject: CN=gtw.ocp.lan.stderr.at
* start date: Aug 30 10:01:33 2025 GMT
* expire date: Aug 28 10:01:33 2035 GMT
* subjectAltName: host &amp;#34;nginx.gtw.ocp.lan.stderr.at&amp;#34; matched cert&amp;#39;s &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34;
* issuer: CN=tntinfra CA
* SSL certificate verify ok.
* Certificate level 0: Public key type RSA (2048/112 Bits/secBits), signed using sha256WithRSAEncryption
* Certificate level 1: Public key type RSA (2048/112 Bits/secBits), signed using sha256WithRSAEncryption
* Connected to nginx.gtw.ocp.lan.stderr.at (10.0.0.150) port 443
* using HTTP/2
* [HTTP/2] [1] OPENED stream for https://nginx.gtw.ocp.lan.stderr.at/
* [HTTP/2] [1] [:method: GET]
* [HTTP/2] [1] [:scheme: https]
* [HTTP/2] [1] [:authority: nginx.gtw.ocp.lan.stderr.at]
* [HTTP/2] [1] [:path: /]
* [HTTP/2] [1] [user-agent: curl/8.11.1]
* [HTTP/2] [1] [accept: */*]
&amp;gt; GET / HTTP/2
&amp;gt; Host: nginx.gtw.ocp.lan.stderr.at
&amp;gt; User-Agent: curl/8.11.1
&amp;gt; Accept: */*
&amp;gt;
* Request completely sent off
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
&amp;lt; HTTP/2 200
&amp;lt; server: nginx/1.29.1
&amp;lt; date: Sat, 30 Aug 2025 14:30:20 GMT
&amp;lt; content-type: text/html
&amp;lt; content-length: 615
&amp;lt; last-modified: Wed, 13 Aug 2025 14:33:41 GMT
&amp;lt; etag: &amp;#34;689ca245-267&amp;#34;
&amp;lt; accept-ranges: bytes
(output omitted)&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Yes, we can reach our Nginx via HTTPS, and the gateway presents the TLS certificate we created.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Be aware that we are still using the same &lt;em>HTTPRoute&lt;/em> for Nginx from our previous blog post.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Just for completeness here is the &lt;em>HTTPRoute&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
name: nginx-route
spec:
parentRefs:
- name: http-gateway
namespace: openshift-ingress
hostnames: [&amp;#34;nginx.gtw.ocp.lan.stderr.at&amp;#34;]
rules:
- backendRefs:
- name: nginx
namespace: gateway-api-test
port: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Also Remember that we are using a dedicated &lt;em>Gateway&lt;/em> and all
&lt;em>HTTPRoutes&lt;/em> must be in the namespace &lt;em>openshift-ingress&lt;/em>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_moving_to_a_shared_gateway">Moving to a shared gateway&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Up until now we had to create all &lt;em>HTTPRoute&lt;/em> objects in the
&lt;em>openshift-ingress&lt;/em> namespace. The Gateway API support two modes of
operations:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Dedicated gateway: all &lt;em>HTTPRoute&lt;/em> object need to be in the same namespace as the gateway&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Shared gateway: The gateway runs in the &lt;em>openshift-ingress&lt;/em>
namespace and we allow &lt;em>HTTPRoute&lt;/em> objects from all or specific namespaces.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The first step in creating a shared gateway is to modify the gateway resource:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
name: http-gateway
namespace: openshift-ingress
spec:
gatewayClassName: openshift-default
listeners:
- name: http
protocol: HTTP
port: 80
hostname: &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34;
allowedRoutes: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespaces:
from: All&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We now allow &lt;em>HTTPRoute&lt;/em> objects from all namespaces in the cluster&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Next we delete the existing &lt;em>HTTPRoute&lt;/em> for Nginx in the
&lt;em>openshift-ingress&lt;/em> namespaces, and verify that we can’t reach Nginx:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc delete httproutes.gateway.networking.k8s.io -n openshift-ingress nginx-route
httproute.gateway.networking.k8s.io &amp;#34;nginx-route&amp;#34; deleted
$ curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 404 Not Found &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
date: Sat, 30 Aug 2025 15:02:23 GMT
transfer-encoding: chunked&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Our Nginx route stopped working&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Next we apply our modified &lt;em>Gateway&lt;/em> resource in the
&lt;em>openshift-ingress&lt;/em> namespace and the &lt;em>HTTPRoute&lt;/em> object in the
&lt;em>gateway-api-test&lt;/em> namespace.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc apply -n openshift-ingress -f gateway--selector.yaml
gateway.gateway.networking.k8s.io/http-gateway configured
$ oc apply -n gateway-api-test -f httproute.yaml &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
httproute.gateway.networking.k8s.io/nginx-route created
$ curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 200 OK &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
server: nginx/1.29.1
date: Sat, 30 Aug 2025 15:04:34 GMT
content-type: text/html
content-length: 615
last-modified: Wed, 13 Aug 2025 14:33:41 GMT
etag: &amp;#34;689ca245-267&amp;#34;
accept-ranges: bytes&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We create the &lt;em>HTTPRoute&lt;/em> in the gateway-api-test namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>We can reach our Nginx pod again&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So our shared gateway seems to be working. But what if we want to
restrict which namespaces are allowed to create route objects?&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Gateway API allows the following settings under &lt;em>spec.listeners[].allowedRoutes.namespaces.from&lt;/em> field&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;strong>All&lt;/strong>: Allow from all namespaces&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Selector&lt;/strong>: Specify a selector&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Same&lt;/strong>: Only allow &lt;em>HTTPRoutes&lt;/em> in the same namespaces&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>None&lt;/strong>: Do not allow any routes to attach&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>See the API specification &lt;a href="https://gateway-api.sigs.k8s.io/reference/spec/#fromnamespaces">FromNamespaces&lt;/a> for details.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s try to use a more specific selector for our gateway:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
name: http-gateway
namespace: openshift-ingress
spec:
gatewayClassName: openshift-default
listeners:
- name: http
protocol: HTTP
port: 80
hostname: &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34;
allowedRoutes:
namespaces:
from: Selector &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
selector:
matchLabels:
kubernetes.io/metadata.name: gateway-api-test &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Now we are using the Selector option&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Because we do not have a specific label on the namespace we would like to use, let’s use the &lt;em>metadata.name&lt;/em> label Kubernetes created for us&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We create a new yaml file &lt;em>gateway-selector.yaml&lt;/em> and appy the new configuration:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc apply -n openshift-ingress -f gateway-selector.yaml
gateway.gateway.networking.k8s.io/http-gateway configured
$ curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 200 OK
server: nginx/1.29.1
date: Sat, 30 Aug 2025 15:17:17 GMT
content-type: text/html
content-length: 615
last-modified: Wed, 13 Aug 2025 14:33:41 GMT
etag: &amp;#34;689ca245-267&amp;#34;
accept-ranges: bytes&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All good, still working.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Just for testing we modified the namespace name in the Gateway definition to &lt;strong>NOT&lt;/strong> match the namespace of our Nginx deployment and confirmed that we receive a &lt;em>404&lt;/em> not found response.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_implementing_http_to_https_redirect">Implementing HTTP to HTTPS redirect&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As a last test for this post let’s try to implement HTTP to HTTPS redirects.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We deployed the following &lt;em>Gateway&lt;/em> configuration:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
name: http-gateway
namespace: openshift-ingress &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
spec:
gatewayClassName: openshift-default
listeners:
- name: http
protocol: HTTP
port: 80
hostname: &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34;
allowedRoutes:
namespaces:
from: Selector
selector:
matchLabels:
kubernetes.io/metadata.name: gateway-api-test2
- name: https &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
protocol: HTTPS
port: 443
hostname: &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34;
tls:
mode: Terminate
certificateRefs:
- name: gateway-api
allowedRoutes:
namespaces:
from: All&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Always deploy the gateway to the &lt;em>openshift-ingress&lt;/em> namespace for the OpenShift Gateway API implementation&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>We added the HTTPS configuration back&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;a href="https://gateway-api.sigs.k8s.io/guides/http-redirect-rewrite/">upstream&lt;/a> documentation contains an example on how to implements HTTP to HTTPS redirects. We created the following additional &lt;em>HTTPRoute&lt;/em> object in the &lt;em>gateway-api-test&lt;/em> namespace:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
name: http-https-redirect
spec:
parentRefs:
- name: http-gateway &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: openshift-ingress
sectionName: http &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
hostnames:
- nginx.gtw.ocp.lan.stderr.at
rules:
- filters:
- type: RequestRedirect
requestRedirect:
scheme: https
statusCode: 301&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Match our &lt;em>Gateway&lt;/em> &lt;em>http-gateway&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Match the &lt;em>http&lt;/em> section in our gateway&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Just for reference this is the &lt;em>HTTPRoute&lt;/em> object to expose Nginx:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
name: nginx-route
spec:
parentRefs:
- name: http-gateway
namespace: openshift-ingress
hostnames: [&amp;#34;nginx.gtw.ocp.lan.stderr.at&amp;#34;]
rules:
- backendRefs:
- name: nginx
namespace: gateway-api-test
port: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>First we re-applied our &lt;em>Gateway&lt;/em> configuration&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc apply -f gateway-https-selector.yaml
gateway.gateway.networking.k8s.io/http-gateway configured&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s try and verify if our redirect is working, we need to apply both routes:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc apply -f httproute.yaml
httproute.gateway.networking.k8s.io/nginx-route created
$ oc apply -f http-https-redirect-route.yaml
httproute.gateway.networking.k8s.io/http-https-redirect created&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>And test with curl:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 200 OK &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
server: nginx/1.29.1
date: Sat, 30 Aug 2025 15:37:20 GMT
content-type: text/html
content-length: 615
last-modified: Wed, 13 Aug 2025 14:33:41 GMT
etag: &amp;#34;689ca245-267&amp;#34;
accept-ranges: bytes&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Hm, strange we still get 200 OK and &lt;strong>NOT&lt;/strong> a redirect to HTTPS&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_understanding_httproute_ordering">Understanding HTTPRoute ordering&lt;/h3>
&lt;div class="paragraph">
&lt;p>After a longer search through the documentation we found some hints on why this is happening.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s take a more detailed look at our http-to-https route again, as a
&lt;em>HTTPRoute&lt;/em> &lt;strong>attaches&lt;/strong> to a &lt;em>Gateway&lt;/em>, we focus on the &lt;em>parentRefs&lt;/em> in
the &lt;em>HTTPRoute&lt;/em> object. In our current understanding &lt;em>parentRefs&lt;/em> select a &lt;em>Gateway&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
name: http-https-redirect
spec:
parentRefs: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
- name: http-gateway &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
namespace: openshift-ingress &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
sectionName: http &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
hostnames:
- nginx.gtw.ocp.lan.stderr.at
rules:
- filters:
- type: RequestRedirect
requestRedirect:
scheme: https
statusCode: 301&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Ok, this is the &lt;em>parentRefs&lt;/em> section we are looking for&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>&lt;em>name&lt;/em> selects the name of the &lt;em>Gateway&lt;/em> we want to attach to&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>&lt;em>namespace&lt;/em> specifies the namespace where we can find the &lt;em>Gateway&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>&lt;em>sectionName&lt;/em> selects the section in the &lt;em>Gateway&lt;/em> where we want to attach to.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So this &lt;em>HTTPRoute&lt;/em> explicitly attaches to a &lt;em>Gateway&lt;/em> in a
&lt;em>Namespace&lt;/em> that has a &lt;em>Section&lt;/em> http defined.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you look at the Gateway configuration above you will see that we
have a section for HTTP traffic and one for HTTPS traffic.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s compare this with our Nginx &lt;em>HTTPRoute&lt;/em> definition:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
name: nginx-route
spec:
parentRefs: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
- name: http-gateway &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
namespace: openshift-ingress &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
hostnames: [&amp;#34;nginx.gtw.ocp.lan.stderr.at&amp;#34;]
rules:
- backendRefs:
- name: nginx
namespace: gateway-api-test
port: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The &lt;em>parentRefs&lt;/em> section&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The &lt;em>Gateway&lt;/em> we would like to attach to&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The &lt;em>namespace&lt;/em> where the &lt;em>Gateway&lt;/em> is deploy&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Note that &lt;em>Section&lt;/em> is missing in this configuration.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So this &lt;em>HTTPRoute&lt;/em> actually attaches to &lt;strong>both&lt;/strong> sections in our
&lt;em>Gateway&lt;/em> definition, HTTP and HTTPS. Which is not what we want.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>When a client hits the HTTP endpoint we want to redirect the traffic to HTTPS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>When a client hits the HTTPS endpoint we want the traffic to be forward to our Nginx deployment&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We found the following statement
&lt;a href="https://gateway-api.sigs.k8s.io/reference/spec/#httprouterule">statement&lt;/a>
how ordering works in the Gateway API:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre>If ties still exist across multiple Routes, matching precedence MUST be
determined in order of the following criteria, continuing on ties:
The oldest Route based on creation timestamp.&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>When we look at the timestamps of our &lt;em>HTTPRoutes&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">oc get httproute -o jsonpath=&amp;#39;{range .items[*]}{.metadata.name}{&amp;#34;\t&amp;#34;}{.metadata.creationTimestamp}{&amp;#34;\n&amp;#34;}{end}&amp;#39;
http-https-redirect 2025-08-31T09:17:46Z &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
nginx-route 2025-08-31T09:17:40Z &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Creation timestamp of the redirect route&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Creation timestamp of the nginx route&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Nginx &lt;em>HTTPRoute&lt;/em> is &lt;strong>older&lt;/strong> than the HTTP-to-HTTP &lt;em>HTTPRoute&lt;/em>. So
this matches first and a 200 OK is returned.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So let’s try to revers how we applied our &lt;em>HTTPRoutes&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc delete httproutes.gateway.networking.k8s.io --all
httproute.gateway.networking.k8s.io &amp;#34;http-https-redirect&amp;#34; deleted
httproute.gateway.networking.k8s.io &amp;#34;nginx-route&amp;#34; deleted
$ oc apply -f http-to-https-httproute.yaml
httproute.gateway.networking.k8s.io/http-https-redirect created
$ oc apply -f nginx-httproute.yaml
httproute.gateway.networking.k8s.io/nginx-route created
$ oc get httproute -o jsonpath=&amp;#39;{range .items[*]}{.metadata.name}{&amp;#34;\t&amp;#34;}{.metadata.creationTimestamp}{&amp;#34;\n&amp;#34;}{end}&amp;#39;
http-https-redirect 2025-08-31T10:34:55Z &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
nginx-route 2025-08-31T10:35:11Z &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Creation timestamp of the HTTP-to-HTTPS route&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Creation timestamp of the nginx route&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now the HTTP-to-HTTPS route is the oldest route. Let’s try again calling Nginx with curl:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 301 Moved Permanently &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
location: https://nginx.gtw.ocp.lan.stderr.at/
date: Sun, 31 Aug 2025 10:37:13 GMT
transfer-encoding: chunked
$ curl -I https://nginx.gtw.ocp.lan.stderr.at
HTTP/2 200 &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
server: nginx/1.29.1
date: Sun, 31 Aug 2025 10:37:17 GMT
content-type: text/html
content-length: 615
last-modified: Wed, 13 Aug 2025 14:33:41 GMT
etag: &amp;#34;689ca245-267&amp;#34;
accept-ranges: bytes&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The HTTP endpoint returns a redirect&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>the HTTPS endpoint returns 200 OK from Nginx&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So now we have the expected behavior: HTTP is redirect to HTTPS!&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As depending on the time when an object is created is definitely &lt;strong>NOT&lt;/strong>
a good idea, let’s be more specific in our Nginx &lt;em>HTTPRoute&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
name: nginx-route
spec:
parentRefs:
- name: http-gateway
namespace: openshift-ingress
sectionName: https &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
hostnames: [&amp;#34;nginx.gtw.ocp.lan.stderr.at&amp;#34;]
rules:
- backendRefs:
- name: nginx
namespace: gateway-api-test
port: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We explicitly select the &lt;strong>HTTPS&lt;/strong> section in our &lt;em>Gateway&lt;/em> configuration&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Next we delete our &lt;em>HTTPRoutes&lt;/em> again, and re-apply them in the order that didn’t work the first time (Nginx is the oldest route):&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc delete httproutes.gateway.networking.k8s.io --all
httproute.gateway.networking.k8s.io &amp;#34;http-https-redirect&amp;#34; deleted
httproute.gateway.networking.k8s.io &amp;#34;nginx-route&amp;#34; deleted
$ oc apply -f http-to-https-httproute.yaml
httproute.gateway.networking.k8s.io/http-https-redirect created
$ oc get httproute -o jsonpath=&amp;#39;{range .items[*]}{.metadata.name}{&amp;#34;\t&amp;#34;}{.metadata.creationTimestamp}{&amp;#34;\n&amp;#34;}{end}&amp;#39;
http-https-redirect 2025-08-31T10:45:01Z
nginx-route 2025-08-31T10:44:57Z &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
$ curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 301 Moved Permanently &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
location: https://nginx.gtw.ocp.lan.stderr.at/
date: Sun, 31 Aug 2025 10:46:22 GMT
transfer-encoding: chunked
$ curl -I https://nginx.gtw.ocp.lan.stderr.at
HTTP/2 200 &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
server: nginx/1.29.1
date: Sun, 31 Aug 2025 10:46:30 GMT
content-type: text/html
content-length: 615
last-modified: Wed, 13 Aug 2025 14:33:41 GMT
etag: &amp;#34;689ca245-267&amp;#34;
accept-ranges: bytes&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The Nginx route is the oldest route&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The HTTP endpoint returns a redirect to HTTPS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The response from our Nginx deployment&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Finally everything works as expected!&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
A &lt;em>HTTPRoute&lt;/em> attaches to a &lt;em>Gateway&lt;/em>. Always be as specific as
possible which &lt;em>Gateway&lt;/em> to match and which &lt;em>section&lt;/em> in the
&lt;em>Gateway&lt;/em>.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In this blog post we demonstrated to implement TLS with the
Gateway API. We also implemented a shared &lt;em>Gateway&lt;/em> with &lt;em>HTTPRoute&lt;/em>
objects in different namespaces.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Furthermore we configured HTTP to HTTPS redirects and dove into
&lt;em>HTTPRoute&lt;/em> ordering if a route matches multiple listeners in a
&lt;em>Gateway&lt;/em> definition.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>A first look into the Kubernetes Gateway API on OpenShift</title><link>https://blog.stderr.at/openshift/2025/08/a-first-look-into-the-kubernetes-gateway-api-on-openshift/</link><pubDate>Fri, 29 Aug 2025 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/openshift/2025/08/a-first-look-into-the-kubernetes-gateway-api-on-openshift/</guid><description>&lt;div class="paragraph">
&lt;p>This blog post summarizes our first look into the Kubernetes Gateway
API and how it is integrated in OpenShift.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Kubernetes Gateway API is new implementation of the ingress, load
balancing and service mesh API’s. See
&lt;a href="https://gateway-api.sigs.k8s.io/" target="_blank" rel="noopener">upstream&lt;/a> for more information.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Also the &lt;a href="https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/ingress_and_load_balancing/configuring-ingress-cluster-traffic#nw-ingress-gateway-api-overview_ingress-gateway-api" target="_blank" rel="noopener">OpenShift documentation&lt;/a> provides an overview of the Gateway API and it’s integration.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_things_to_consider_when_using_gateway_api_with_openshift">Things to consider when using Gateway API with OpenShift&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Currently UDN (User Defined Networks) with Gateway API are not supported.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Only TLS termination on the edge is supported (no pass-through or re-encrypt), this needs to be confirmed. We can’t find the original source of this statement&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The standard OpenShift ingress controller manages Gateway API Resources&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Gateway API provides a standard on how to get client traffic into a
Kubernetes cluster. Vendors provide an implementation of the API. So
OpenShift provides &lt;strong>ONE&lt;/strong> possible implementation, but there could
be more than one in a cluster.&lt;/p>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>We found the following sentence in the OpenShift documentation
interesting:&lt;/p>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>Because OpenShift Container Platform uses a specific
version of Gateway API CRDs, any use of third-party implementations
of Gateway API must conform to the OpenShift Container Platform
implementation to ensure that all fields work as expected&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_setting_up_gateway_api_on_openshift">Setting up Gateway API on OpenShift&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before you begin, ensure you have the following:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>OpenShift 4.19 or higher with cluster-admin access&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>First you need to create a &lt;code>GatewayClass&lt;/code> object.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Be aware that the &lt;code>GatewayClass&lt;/code> object is &lt;strong>NOT&lt;/strong> namespaced.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: gateway.networking.k8s.io/v1
kind: GatewayClass
metadata:
name: openshift-default
spec:
controllerName: openshift.io/gateway-controller/v1 &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The controller name needs to be exactly as shown. Otherwise the
ingress controller will &lt;strong>NOT&lt;/strong> manage the gateway and associated
resources.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This creates a new pod in the openshift-ingress namespace:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc get po -n openshift-ingress
NAME READY STATUS RESTARTS AGE
istiod-openshift-gateway-7b567bc8b4-4lrt2 1/1 Running 0 12m &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
router-default-6db958cbd-dlbwz 1/1 Running 12 14d&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>this pod got create after applying the gateway class resource&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;code>router-default&lt;/code> is the default openshift ingress pod. The first
difference seems to be the SCC (security context constraint) the pods
are using.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc get po -n openshift-ingress -o jsonpath=&amp;#39;{range .items[*]}{.metadata.name}{&amp;#34;\t&amp;#34;}{.metadata.annotations.openshift\.io/scc}{&amp;#34;\n&amp;#34;}{end}&amp;#39;
istiod-openshift-gateway-7b567bc8b4-4lrt2 restricted-v2
router-default-6db958cbd-dlbwz hostnetwork&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The standard router used host networking for listing on port 80 and 443
on the node where it is running. Our &lt;code>GatewayClass&lt;/code> currently only
provides a pod running Istiod awaiting further configuration. To
actually listen for client request additional configuration is
required.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>A &lt;code>Gateway&lt;/code> is required to listen for client requests. We create the
following gateway:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
name: http-gateway
namespace: openshift-ingress &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
spec:
gatewayClassName: openshift-default
listeners:
- name: http
protocol: HTTP
port: 80
hostname: &amp;#34;*.apps.ocp.lan.stderr.at&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We create this gateway in the same namespace as the istio
deployment. This is required for OpenShift.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This creates an additional pod in the &lt;code>openshift-ingress&lt;/code> namespace:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc get po
NAME READY STATUS RESTARTS AGE
http-gateway-openshift-default-d476664f5-h87mp 1/1 Running 0 36s&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We also got a new service for the our http-gateway&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">➜ oc get svc
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
http-gateway-openshift-default LoadBalancer 172.30.183.48 10.0.0.150 15021:30251/TCP,80:30437/TCP 4m52s&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The interesting thing is the &lt;code>TYPE&lt;/code> of the service. It’s of type
&lt;code>LoadBalancer&lt;/code>. We have
&lt;a href="https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/networking_operators/metallb-operator">MetalLB&lt;/a>
deployed in our cluster, this might be the reason for this. We will
try to configure a gateway without MetalLB in in upcoming post.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Lets take a look at the gateway resource&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc get gtw
NAME CLASS ADDRESS PROGRAMMED AGE
http-gateway openshift-default 10.0.0.150 True 3m&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So this seems to be working. But know we have a problem: the &lt;code>*.apps&lt;/code>
domain that we used for our gateway points already to the default
OpenShift Ingress. We could either&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>redeploy the gateway with a different wildcard domain (e.g. *.gtw…​)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>create a more specific DNS record that points to our new load balancer&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s try to confirm this with &lt;em>curl&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ curl -I http://bla.apps.ocp.lan.stderr.at
HTTP/1.0 503 Service Unavailable
pragma: no-cache
cache-control: private, max-age=0, no-cache, no-store
content-type: text/html&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;code>503&lt;/code> is the response of default OpenShift Ingress.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ curl -I http://10.0.0.150
HTTP/1.1 404 Not Found
date: Fri, 29 Aug 2025 14:31:31 GMT
transfer-encoding: chunked&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Our new gateway returns a &lt;code>404&lt;/code> not found response. We choose the
first option and create another wildcard DNS entry for
&lt;code>*.gtw.ocp.lan.stderr.at&lt;/code>. We re-deployed our gateway with the new hostname:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
name: http-gateway
namespace: openshift-ingress
spec:
gatewayClassName: openshift-default
listeners:
- name: http
protocol: HTTP
port: 80
hostname: &amp;#34;*.gtw.ocp.lan.stderr.at&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>New hostname for resources exposed via our gateway&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc apply -f gateway.yaml
gateway.gateway.networking.k8s.io/http-gateway created&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This also creates a DNSRecord resource:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc describe dnsrecords.ingress.operator.openshift.io -n openshift-ingress http-gateway-c8d7bfc67-wildcard
Name: http-gateway-c8d7bfc67-wildcard
Namespace: openshift-ingress
Labels: gateway.istio.io/managed=openshift.io-gateway-controller-v1
gateway.networking.k8s.io/gateway-name=http-gateway
istio.io/rev=openshift-gateway
Annotations: &amp;lt;none&amp;gt;
API Version: ingress.operator.openshift.io/v1
Kind: DNSRecord
Metadata:
Creation Timestamp: 2025-08-29T14:49:45Z
Finalizers:
operator.openshift.io/ingress-dns
Generation: 1
Owner References:
API Version: v1
Kind: Service
Name: http-gateway-openshift-default
UID: a023de5d-c428-4249-a190-de3cbfeb6964
Resource Version: 141150968
UID: 7a61a867-216e-40b7-88f3-e3934493c477
Spec:
Dns Management Policy: Managed
Dns Name: *.gtw.ocp.lan.stderr.at.
Record TTL: 30
Record Type: A
Targets:
10.0.0.150
Events: &amp;lt;none&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This resource is only internally used by the OpenShift ingress
operator (see &lt;code>oc explain dnsrecord&lt;/code> for details).&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_creating_httproutes_for_exposing_our_service">Creating HTTPRoutes for exposing our service.&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To actually expose a HTTP pod via our new gateway we need:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>A &lt;em>Namespace&lt;/em> to deploy an example pod. We will use a Nginx for this&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A &lt;em>Service&lt;/em> that exposes our Nginx pod&lt;/p>
&lt;/li>
&lt;li>
&lt;p>and finally a &lt;em>HTTPRoute&lt;/em> resource&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For the nginx deployment we used the following manifest:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: v1
kind: Namespace
metadata:
name: gateway-api-test
spec:
finalizers:
- kubernetes
---
apiVersion: apps/v1
kind: Deployment
metadata:
name: nginx-deployment
namespace: gateway-api-test
labels:
app: nginx
spec:
replicas: 1
selector:
matchLabels:
app: nginx
template:
metadata:
labels:
app: nginx
spec:
containers:
- name: nginx
image: quay.io/nginx/nginx-unprivileged:1.29.1
ports:
- containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
name: nginx
namespace: gateway-api-test
spec:
selector:
app: nginx
ports:
- protocol: TCP
port: 8080
targetPort: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s see if our nginx pod got deployed successfully:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc get po,svc -n gateway-api-test
NAME READY STATUS RESTARTS AGE
pod/nginx-deployment-796cdf7474-b7bqz 1/1 Running 0 20s
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
service/nginx ClusterIP 172.30.42.36 &amp;lt;none&amp;gt; 8080/TCP 21s&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>And finally confirm our &lt;code>Service&lt;/code> is working:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc port-forward -n gateway-api-test svc/nginx 8080 &amp;amp;
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
Forwarding from [::1]:8080 -&amp;gt; 8080
$ curl -I localhost:8080
Handling connection for 8080
HTTP/1.1 200 OK
Server: nginx/1.29.1
Date: Fri, 29 Aug 2025 15:45:12 GMT
Content-Type: text/html
Content-Length: 615
Last-Modified: Wed, 13 Aug 2025 14:33:41 GMT
Connection: keep-alive
ETag: &amp;#34;689ca245-267&amp;#34;
Accept-Ranges: bytes&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We received a response from our nginx pod, hurray!&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So next let’s try to create a &lt;code>HTTPRoute&lt;/code> to expose our nginx service to external clients:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
name: nginx-route
spec:
parentRefs:
- name: http-gateway
namespace: openshift-ingress
hostnames: [&amp;#34;nginx.gtw.ocp.lan.stderr.at&amp;#34;]
rules:
- backendRefs:
- name: nginx
namespace: gateway-api-test
port: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>One important point here, the &lt;code>Gateway&lt;/code> actually come in two flavors&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>dedicated gateways, only accepting HTTP routes in the same namespace (&lt;code>openshift-ingress&lt;/code>) in our case.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>shared gateways, which also accept HTTP route objects from other namespaces&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>see &lt;a href="https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/ingress_and_load_balancing/configuring-ingress-cluster-traffic#nw-ingress-gateway-api-deployment_ingress-gateway-api">Gateway API deployment topologies&lt;/a> in the OpenShift documentation for more information.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As this post is already rather long, we focus on the dedicated gateway topology for now.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The HTTP route must be deployed in the same namespace as the
gateway if the dedicated topology is used.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So let’s deploy our &lt;code>HTTPRoute&lt;/code>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc apply -f httproute.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Verify we can reach our nginx pod:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 500 Internal Server Error
date: Fri, 29 Aug 2025 15:57:34 GMT
transfer-encoding: chunked&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This return a &lt;em>500&lt;/em> error, something seems to be wrong with our route,
let’s take a look at the status of the &lt;code>HTTPRoute&lt;/code>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ oc describe gtw http-gateway
.
. (output omitted)
.
Status:
Parents:
Conditions:
Last Transition Time: 2025-08-29T15:54:43Z
Message: Route was valid
Observed Generation: 1
Reason: Accepted
Status: True
Type: Accepted
Last Transition Time: 2025-08-29T15:54:43Z
Message: backendRef nginx/gateway-api-test not accessible to a HTTPRoute in namespace &amp;#34;openshift-ingress&amp;#34; (missing a ReferenceGrant?) &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
Observed Generation: 1
Reason: RefNotPermitted
Status: False &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
Type: ResolvedRefs
Controller Name: openshift.io/gateway-controller/v1
Parent Ref:
Group: gateway.networking.k8s.io
Kind: Gateway
Name: http-gateway
Namespace: openshift-ingress&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Something seems to be wrong as the status is &lt;em>False&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Seems we are missing a ReferenceGrant&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Looking at the
&lt;a href="https://gateway-api.sigs.k8s.io/api-types/referencegrant/" target="_blank" rel="noopener">upstream&lt;/a>
documentation reveals a security feature of the Gateway API. Before a
&lt;code>HTTPRoute&lt;/code> can reach a service in a &lt;em>different&lt;/em> namespace we must
create a &lt;code>ReferenceGrant&lt;/code> in the namespace providing the service.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So let’s try to deploy following &lt;code>ReferenceGrant&lt;/code> in the &lt;em>gateway-api-test&lt;/em> namespace:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: gateway.networking.k8s.io/v1beta1
kind: ReferenceGrant
metadata:
name: nginx
namespace: gateway-api-test
spec:
from:
- group: gateway.networking.k8s.io
kind: HTTPRoute
namespace: openshift-ingress
to:
- group: &amp;#34;&amp;#34;
kind: Service&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Checking the status field of our &lt;code>HTTPRoute&lt;/code> again:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">(output omitted)
Status:
Addresses:
Type: IPAddress
Value: 10.0.0.150
Conditions:
Last Transition Time: 2025-08-29T15:47:07Z
Message: Resource accepted
Observed Generation: 1
Reason: Accepted
Status: True
Type: Accepted
Last Transition Time: 2025-08-29T15:47:08Z
Message: Resource programmed, assigned to service(s) http-gateway-openshift-default.openshift-ingress.svc.cluster.local:80
Observed Generation: 1
Reason: Programmed
Status: True &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
Type: Programmed&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>&lt;em>Status&lt;/em> is now &lt;em>True&lt;/em>&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>and finally calling the nginx pod again via our gateway:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-console" data-lang="console">$ curl -I http://nginx.gtw.ocp.lan.stderr.at
HTTP/1.1 200 OK
server: nginx/1.29.1
date: Fri, 29 Aug 2025 16:01:33 GMT
content-type: text/html
content-length: 615
last-modified: Wed, 13 Aug 2025 14:33:41 GMT
etag: &amp;#34;689ca245-267&amp;#34;
accept-ranges: bytes&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Finally everything seems to be in place and working.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In this blog post we took a first look at the Kubernetes Gateway API
and it’s integration into OpenShift. We enabled the Gateway API via a
&lt;code>GatewayClass&lt;/code> resource, created a simple HTTP Gateway via a
&lt;code>Gateway&lt;/code>, deploy a Nginx pod and a Service and exposed the service
via a &lt;code>HTTPRoute&lt;/code> and a &lt;code>ReferenceGrant&lt;/code>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Hopefully an upcoming blog post will cover how to&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>How to deploy a Gateway without MetalLB&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deploy a TLS secured service&lt;/p>
&lt;/li>
&lt;li>
&lt;p>implement HTTP redirects&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rewriting URL’s (if possible)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>and other possibilities of the Gateway API&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Enable Automatic Route Creation</title><link>https://blog.stderr.at/service-mesh/2020/05/enable-automatic-route-creation/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/05/enable-automatic-route-creation/</guid><description>&lt;div class="paragraph">
&lt;p>Red Hat Service Mesh 1.1 allows you to enable a &amp;#34;&lt;strong>Automatic Route Creation&lt;/strong>&amp;#34; which will take care about the routes for a specific Gateway. Instead of defining * for hosts, a list of domains can be defined. The Istio OpenShift Routing (ior) synchronizes the routes and creates them inside the Istio namespace. If a Gateway is deleted, the routes will also be removed again.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This new features makes the manual creation of the route obsolete, as it was explained here: &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/">Openshift 4 and Service Mesh 4 - Ingress with custom domain&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_enable_automatic_route_creation">Enable Automatic Route Creation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before this feature can be used, it must be enabled. To do so the &lt;strong>ServiceMeshContolPlace&lt;/strong>, typically found in the namespace &lt;em>istio-system&lt;/em> must be modified.
Add the line &lt;strong>ior_enabled: true&lt;/strong> to the &lt;em>istio-ingressgate&lt;/em> configuration.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">...
spec:
istio:
gateways:
istio-egressgateway:
autoscaleEnabled: false
istio-ingressgateway:
autoscaleEnabled: false
ior_enabled: true
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_current_service">Verify current service&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Let’s check our &lt;em>tutorial&lt;/em> application, if it is still working.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc project tutorial
export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
curl $GATEWAY_URL/customer
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 30&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s review and remove the current used Gateway. As you can see the hosts is set to &amp;#39;*&amp;#39;&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">oc get istio-io
oc get gateway.networking.istio.io/customer-gateway -o yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
annotations:
kubectl.kubernetes.io/last-applied-configuration: |
{&amp;#34;apiVersion&amp;#34;:&amp;#34;networking.istio.io/v1alpha3&amp;#34;,&amp;#34;kind&amp;#34;:&amp;#34;Gateway&amp;#34;,&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{},&amp;#34;name&amp;#34;:&amp;#34;customer-gateway&amp;#34;,&amp;#34;namespace&amp;#34;:&amp;#34;tutorial&amp;#34;},&amp;#34;spec&amp;#34;:{&amp;#34;selector&amp;#34;:{&amp;#34;istio&amp;#34;:&amp;#34;ingressgateway&amp;#34;},&amp;#34;servers&amp;#34;:[{&amp;#34;hosts&amp;#34;:[&amp;#34;*&amp;#34;],&amp;#34;port&amp;#34;:{&amp;#34;name&amp;#34;:&amp;#34;http&amp;#34;,&amp;#34;number&amp;#34;:80,&amp;#34;protocol&amp;#34;:&amp;#34;HTTP&amp;#34;}}]}}
creationTimestamp: &amp;#34;2020-05-13T07:52:20Z&amp;#34;
generation: 1
name: customer-gateway
namespace: tutorial
resourceVersion: &amp;#34;41370056&amp;#34;
selfLink: /apis/networking.istio.io/v1alpha3/namespaces/tutorial/gateways/customer-gateway
uid: 96e82ed9-e870-493c-941f-bfa83c892b94
spec:
selector:
istio: ingressgateway
servers:
- hosts:
- &amp;#39;*&amp;#39;
port:
name: http
number: 80
protocol: HTTP&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_a_new_gateway">Create a new Gateway&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>First let’s remove the current Gateway&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bach" data-lang="bach">oc delete gateway.networking.istio.io/customer-gateway&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now lets create a new Gateway, but this time we define some names for the hosts section:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; Gateway-ior.yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: customer-gateway
spec:
selector:
istio: ingressgateway
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- www.example.com
- svc.example.com
EOF
oc apply -f Gateway-ior.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>When you now check the routes, 2 new routes have been added:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get routes -n istio-system
NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD
...
tutorial-customer-gateway-kmqrl www.example.com istio-ingressgateway http2 None
tutorial-customer-gateway-ks7q7 svc.example.com istio-ingressgateway http2 None&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To test the connectivity, you need to be sure that the hosts, used in the Gateway, are resolvable.
If they are then you can access your service:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl www.example.com/customer
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 31
curl svc.example.com/customer
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 32&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Authorization (RBAC)</title><link>https://blog.stderr.at/service-mesh/2020/05/authorization-rbac/</link><pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/05/authorization-rbac/</guid><description>&lt;div class="paragraph">
&lt;p>Per default all requests inside a Service Mesh are allowed, which can be a problem security-wise.
To solve this, authorization, which verifies if the user is allowed to perform a certain action, is required.
Istio’s authorization provides access control on mesh-level, namespace-level and workload-level.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With the resource &lt;strong>AuthorizationPolicy&lt;/strong> granular policies can be defined.
These policies are loaded to and verified by the Envoy Proxy which then authorizes a request.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_implicit_enablement">Implicit enablement&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To enable authorization the only thing you need is to do is to define the &lt;strong>AuthorizationPolicy&lt;/strong>. If the resource is not defined, then no access control will be used, instead any traffic is allowed. If &lt;strong>AuthorizationPolicy&lt;/strong> is applied to a workload, then by default any traffic is denied unless it is explicitly allowed.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
This is applicable to Service Mesh version 1.1+
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparing_environment">Preparing Environment&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The following steps will configure an example Role Based Access Control (RBAC). It will start from scratch. If you just want to quickly configure the authorization and have anything else in place, you can start form here: &lt;a href="#_configure_authentication_policy">Configure Authentication Policy&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create a new project&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc new-project tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Be sure that a Service Mesh Member Roll exists for this new project&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; memberroll.yaml
apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
name: default
spec:
members:
- tutorial
EOF
oc apply -f memberroll.yaml -n istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Clone and install the example application&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/redhat-developer-demos/istio-tutorial/ istio-tutorial
oc apply -f istio-tutorial/customer/kubernetes/Deployment.yml -n tutorial
oc apply -f istio-tutorial/customer/kubernetes/Service.yml -n tutorial
oc expose service customer
oc apply -f istio-tutorial/preference/kubernetes/Deployment.yml -n tutorial
oc apply -f istio-tutorial/preference/kubernetes/Service.yml -n tutorial
oc apply -f istio-tutorial/recommendation/kubernetes/Deployment.yml -n tutorial
oc apply -f istio-tutorial/recommendation/kubernetes/Service.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Wait until all pods are running. There should be 2 containers for all pods:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create Gateway and VirtualService&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; Gateway_VirtualService.yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: customer-gateway
spec:
selector:
istio: ingressgateway # use istio default controller
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- &amp;#34;*&amp;#34;
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: customer-gateway
spec:
hosts:
- &amp;#34;*&amp;#34;
gateways:
- customer-gateway
http:
- match:
- uri:
prefix: /customer
rewrite:
uri: /
route:
- destination:
host: customer
port:
number: 8080
EOF
oc apply -f Gateway_VirtualService.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Verify if the application is working
You can either use the run.sh from previous tutorials, or simply try the following curl&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;); echo $GATEWAY_URL
curl $GATEWAY_URL/customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This should return the following line:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Optionally check the connection from inside the customer container&lt;/p>
&lt;div class="paragraph">
&lt;p>get pods name and enter it:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods
NAME READY STATUS RESTARTS AGE
customer-6948b8b959-dhsm9 2/2 Running 0 177m
preference-v1-7fdb89c86b-dvzs9 2/2 Running 0 177m
recommendation-v1-69db8d6c48-cjcpn 2/2 Running 0 177m&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Connect into the container pod and try to reach the different microservices&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc rsh customer-6948b8b959-dhsm9
sh-4.4$ curl customer:8080
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 2
sh-4.4$ curl preference:8080
preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3
sh-4.4$ curl recommendation:8080
recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 4&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_configure_authentication_policy">Configure Authentication Policy&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Enabling User-End authentication&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; authentication-policy.yaml
apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;customerjwt&amp;#34;
spec:
targets:
- name: customer
- name: preference
- name: recommendation
origins:
- jwt:
issuer: &amp;#34;testing@secure.istio.io&amp;#34;
jwksUri: &amp;#34;https://gist.githubusercontent.com/lordofthejars/7dad589384612d7a6e18398ac0f10065/raw/ea0f8e7b729fb1df25d4dc60bf17dee409aad204/jwks.json&amp;#34;
principalBinding: USE_ORIGIN
EOF
oc apply -f authentication-policy.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Access should be denied after a few seconds&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl $GATEWAY_URL/customer
Origin authentication failed.%&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Use token to authenticate&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">token=$(curl https://gist.githubusercontent.com/lordofthejars/a02485d70c99eba70980e0a92b2c97ed/raw/f16b938464b01a2e721567217f672f11dc4ef565/token.simple.jwt -s)
curl -H &amp;#34;Authorization: Bearer $token&amp;#34; $GATEWAY_URL/customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will result in a correct response&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 5&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_configure_role_based_access_control_rbac">Configure Role Based Access Control (RBAC)&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create the resource &lt;strong>AuthorizationPolicy&lt;/strong>&lt;/p>
&lt;div class="paragraph">
&lt;p>This is a new resources, supported since Service Mesh 1.1. It will allow GET method when the role equals to &amp;#34;&lt;em>customer&lt;/em>&amp;#34;&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; AuthorizationPolicy.yaml
apiVersion: &amp;#34;security.istio.io/v1beta1&amp;#34;
kind: &amp;#34;AuthorizationPolicy&amp;#34;
metadata:
name: &amp;#34;customer&amp;#34;
spec:
rules:
- to:
- operation:
methods: [&amp;#34;GET&amp;#34;]
when:
- key: request.auth.claims[role]
values: [&amp;#34;customer&amp;#34;]
EOF
oc apply -f AuthorizationPolicy.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Get a token for the role and retry to connect to the service,&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">token=$(curl https://gist.githubusercontent.com/lordofthejars/f590c80b8d83ea1244febb2c73954739/raw/21ec0ba0184726444d99018761cf0cd0ece35971/token.role.jwt -s)
curl -H &amp;#34;Authorization: Bearer $token&amp;#34; $GATEWAY_URL/customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This results in:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 8&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Let’s verify the setting and change the AuthorizationPolicy.
This will break the authorization, since the token provides roles=customer and we set the Policy to &amp;#34;whereistherole&amp;#34;&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; AuthorizationPolicy-Hack.yaml
apiVersion: &amp;#34;security.istio.io/v1beta1&amp;#34;
kind: &amp;#34;AuthorizationPolicy&amp;#34;
metadata:
name: &amp;#34;customer&amp;#34;
spec:
rules:
- to:
- operation:
methods: [&amp;#34;GET&amp;#34;]
when:
- key: request.auth.claims[role]
values: [&amp;#34;whereistherole&amp;#34;]
EOF
oc replace -f AuthorizationPolicy-Hack.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now try to access the service, with the token, which provides &amp;#34;customer&amp;#34; as role, it will lead to an error:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">token=$(curl https://gist.githubusercontent.com/lordofthejars/f590c80b8d83ea1244febb2c73954739/raw/21ec0ba0184726444d99018761cf0cd0ece35971/token.role.jwt -s)
curl -H &amp;#34;Authorization: Bearer $token&amp;#34; $GATEWAY_URL/customer
RBAC: access denied&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Deploy Example Bookinfo Application</title><link>https://blog.stderr.at/service-mesh/2020/04/deploy-example-bookinfo-application/</link><pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/deploy-example-bookinfo-application/</guid><description>&lt;div class="paragraph">
&lt;p>To test a second application, a bookinfo application shall be deployed as an example.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following section finds it’s origin at:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://istio.io/docs/examples/bookinfo/" target="_blank" rel="noopener">Istio - Bookinfo Application&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/service_mesh_day_two/ossm-example-bookinfo.html" target="_blank" rel="noopener">OpenShift 4 - Example Application&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="listingblock quote">
&lt;div class="content">
&lt;pre>The Bookinfo application displays information about a book, similar to a single catalog entry of an online book store.
Displayed on the page is a description of the book, book details (ISBN, number of pages, and other information), and book reviews.
The Bookinfo application consists of these microservices:
* The productpage microservice calls the details and reviews microservices to populate the page.
* The details microservice contains book information.
* The reviews microservice contains book reviews. It also calls the ratings microservice.
* The ratings microservice contains book ranking information that accompanies a book review.
There are three versions of the reviews microservice:
* Version v1 does not call the ratings Service.
* Version v2 calls the ratings Service and displays each rating as one to five black stars.
* Version v3 calls the ratings Service and displays each rating as one to five red stars.
The end-to-end architecture of the application is shown below.&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/bookinfo.png?width=640px" alt="bookinfo"/>
&lt;/div>
&lt;div class="title">Figure 1. Bookinfo Application End2End Overview&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To use the bookinfo application inside service mesh, no code changes are required. Instead an Envoy proxy is added as a sidecar container to all containers (product, review, details) which intercepts the traffic.&lt;/p>
&lt;/div>
&lt;hr/>
&lt;!-- toc disabled -->
&lt;div class="sect1">
&lt;h2 id="_installation">Installation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Let’s start right away:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create a new project&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc new-project bookinfo&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Add the new project to our Service Mesh&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
name: default
namespace: bookinfo
spec:
controlPlaneRef:
name: basic-install
namespace: istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create the application&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/platform/kube/bookinfo.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create the Gateway and the VirtuaService&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/bookinfo-gateway.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Check if the services and pods are up and running&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get svc,pods
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
service/details ClusterIP 172.30.178.172 &amp;lt;none&amp;gt; 9080/TCP 7m16s
service/productpage ClusterIP 172.30.78.96 &amp;lt;none&amp;gt; 9080/TCP 7m13s
service/ratings ClusterIP 172.30.154.12 &amp;lt;none&amp;gt; 9080/TCP 7m15s
service/reviews ClusterIP 172.30.138.174 &amp;lt;none&amp;gt; 9080/TCP 7m14s
NAME READY STATUS RESTARTS AGE
pod/details-v1-d7db4d55b-mwzsk 2/2 Running 0 7m14s
pod/productpage-v1-5f598fbbf4-svkbc 2/2 Running 0 7m11s
pod/ratings-v1-85957d89d8-v2lrs 2/2 Running 0 7m11s
pod/reviews-v1-67d9b4bcc-x6s2v 2/2 Running 0 7m11s
pod/reviews-v2-67b465c497-zpz6z 2/2 Running 0 7m11s
pod/reviews-v3-7bd659b757-j6rwn 2/2 Running 0 7m11s&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_that_application_is_accessible">Verify that application is accessible&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Export the Gateway URL into a variable&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Verify if the productpage is accessible&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl -s http://${GATEWAY_URL}/productpage | grep -o &amp;#34;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&amp;#34;
&amp;lt;title&amp;gt;Simple Bookstore App&amp;lt;/title&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>You can also access the Productpage in your browser. When you reload the page several times, you will see different results for the Reviews. This comes due to 3 different versions: one without any rating, one with black stars and one with red stars. &lt;a href="http://${GATEWAY_URL}/productpage" class="bare">http://${GATEWAY_URL}/productpage&lt;/a>&lt;/p>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/bookinfo-productpage.png?width=940px" alt="bookinfo productpage"/>
&lt;/div>
&lt;div class="title">Figure 2. Bookinfo Application&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_adding_default_destination_rule">Adding default Destination Rule&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/destination-rule-all-mtls.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will add default routing to all endpoints with same weight. As you can see in Kiali, the &lt;em>Reviews&lt;/em> microservice is contacted equally.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/bookinfo-kiali.png?width=940px" alt="bookinfo kiali"/>
&lt;/div>
&lt;div class="title">Figure 3. Kiali: Bookinfo Application&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Feel free to play with other DestinationRules to controll your traffic.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Service Mesh 1.1 released</title><link>https://blog.stderr.at/service-mesh/2020/04/service-mesh-1.1-released/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/service-mesh-1.1-released/</guid><description>&lt;div class="paragraph">
&lt;p>April 10th 2020 Red Hat released Service Mesh version 1.1 which supports the following versions:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Istio - 1.4.6&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kiali - 1.12.7&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Jaeger - 1.17.1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_update">Update&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To update an operator like Service Mesh, the Operator Life Cycle Manager takes care and automatically updates everything (unless it was configured differently).&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For the Service Mesh 1.1 update consult &lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/service_mesh_install/updating-ossm.html" target="_blank" rel="noopener">Upgrading Red Hat OpenShift Service Mesh&lt;/a>&lt;br/>
It is important to add the version number to the ServiceMeshControlPlane object. The easiest way to do so is:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Log into OpenShift&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select the Namespace &lt;em>istio-system&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Goto _&amp;#34;Installed Operators &amp;gt; Red Hat OpenShift Service Mesh &amp;gt; ServiceMeshControlPlanes &amp;gt; basic-install &amp;gt; YAML&amp;#34;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Under spec add the following:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">spec:
version: v1.1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_notable_changes">Notable Changes&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_servicemeshmember_object">ServiceMeshMember Object&lt;/h3>
&lt;div class="paragraph">
&lt;p>With the ServiceMeshMember object it is now possible that a project administrator can add a service to the service mesh, instead relying on the cluster administrator to configure the ServiceMeshMemberRoll.
To do so create the following object (i.e. under the namespace &lt;em>tutorial&lt;/em>)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
name: default
namespace: tutorial
spec:
controlPlaneRef:
name: basic-install &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: istio-system &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the ServiceMeshControlPlane object&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>name of the service mesh namespace&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Authentication JWT</title><link>https://blog.stderr.at/service-mesh/2020/04/authentication-jwt/</link><pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/authentication-jwt/</guid><description>&lt;div class="paragraph">
&lt;p>Welcome to tutorial 10 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong>, where we will discuss authentication with JWT.
JSON Web Token (JWT) is an open standard that allows to transmit information between two parties securely as a JSON object. It is an authentication token, which is verified and signed and therefore trusted. The signing can be achieved by using a secret or a public/private key pair.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Service Mesh can be used to configure a policy which enables JWT for your services.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparation">Preparation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Be sure that you have at least the Gateway and VirtualService configured:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get istio-io -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Which should return the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME AGE
gateway.networking.istio.io/ingress-gateway-exampleapp 45h
NAME HOST AGE
destinationrule.networking.istio.io/recommendation recommendation 29h
NAME GATEWAYS HOSTS AGE
virtualservice.networking.istio.io/ingress-gateway-exampleapp [ingress-gateway-exampleapp] [*] 45h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Run some texample traffic, to be sure that our application is still working as expected&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 31622
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 33056
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 31623
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 33057
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 31624
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 33058&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_enabling_end_user_authentication">Enabling End-User Authentication&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To test this feature we will need a valid token (JWT). More details can be found at the &lt;a href="https://istio.io/docs/tasks/security/authentication/authn-policy/#end-user-authentication" target="_blank" rel="noopener">Istio example&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All we need to create a Policy object&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;jwt-example&amp;#34;
spec:
targets:
- name: customer
origins:
- jwt:
issuer: &amp;#34;testing@secure.istio.io&amp;#34;
jwksUri: &amp;#34;https://raw.githubusercontent.com/istio/istio/release-1.2/security/tools/jwt/samples/jwks.json&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
principalBinding: USE_ORIGIN&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Path to test a public key&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds the requests will fail with an &amp;#34;authentication failed&amp;#34; error:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: Origin authentication failed.
# 1: Origin authentication failed.
# 2: Origin authentication failed.
# 3: Origin authentication failed.
# 4: Origin authentication failed.
# 5: Origin authentication failed.&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali we see a 100% failure rate.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-JWT.png" alt="Kiali JWT"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali: failing because of authentication error.&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To be able to connect to our application we first need to fetch a valid token and put this into the header while sending curl.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
export TOKEN=$(curl https://raw.githubusercontent.com/istio/istio/release-1.1/security/tools/jwt/samples/demo.jwt -s)
for x in $(seq 1 1000);
do curl --header &amp;#34;Authorization: Bearer $TOKEN&amp;#34; $GATEWAY_URL -s;
done&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali the traffic is now working again and authenticated.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-JWT2.png" alt="Kiali JWT2"/>
&lt;/div>
&lt;div class="title">Figure 2. Kiali: Traffic authenticated.&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_clean_up">Clean Up&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Remove the policy again, to be ready for the next tutorial.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete policy jwt-example -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Mutual TLS Authentication</title><link>https://blog.stderr.at/service-mesh/2020/04/mutual-tls-authentication/</link><pubDate>Wed, 08 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/mutual-tls-authentication/</guid><description>&lt;div class="paragraph">
&lt;p>When more and more microservices are involved in an application, more and more traffic is sent on the network. It should be considered to secure this traffic, to prevent the possibility to inject malicious packets. Mutual TLS/mTLS authentication or two-way authentication offers a way to encrypt service traffic with certificates.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With Red Hat OpenShift Service Mesh, Mutual TLS can be used without the microservice knowing that it is happening. The TLS is managed completely by the Service Mesh Operator between two Envoy proxies using a defined mTLS policy.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Issue 9 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> will explain how to enable Mutual TLS inside the Service Mesh to secure the traffic between the different microservices.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_how_does_it_work">How does it work?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>If a microservice sends a request to a server, it must pass the local sidecar Envoy proxy first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The proxy will intercept the outbound request and starts a mutual TLS handshake with the proxy at the server side. During this handshake the certificates are exchanged and loaded into the proxy containers by Service Mesh.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The client side Envoy starts a mutual TLS handshake with the server side Envoy.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The client proxy does a secure naming check on the server’s certificate to verify that the identity in the certificate is authorized.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A mutual TLS connection is established between the client and the server.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Envoy proxy at the server sides decrypts the traffic and forwards it to the application through a local TCP connection.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparations">Preparations&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Before we can start be sure that the services are setup like in &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Issue #3&lt;/a>.&lt;br/>
In addition, be sure that the following DestinationRule already exists:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
version: v1
name: version-v1
- labels:
version: v2
name: version-v2&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Now we will create a pod, which is running outside of the Service Mesh. It will not have a sidecar proxy and will simply curl our application.&lt;/p>
&lt;div class="paragraph">
&lt;p>Store the following yaml and create the object in our cluster.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
labels:
app: curl
version: v1
name: curl
spec:
replicas: 1
selector:
matchLabels:
app: curl
version: v1
template:
metadata:
labels:
app: curl
version: v1
annotations: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
sidecar.istio.io/proxyCPU: &amp;#34;500m&amp;#34;
sidecar.istio.io/proxyMemory: 400Mi
spec:
containers:
- image: quay.io/maistra_demos/curl:latest
command: [&amp;#34;/bin/sleep&amp;#34;, &amp;#34;3650d&amp;#34;]
imagePullPolicy: Always
name: curl&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>since no sidecar is injected (sidecar.istio.io/inject: &amp;#34;true&amp;#34;), only 1 container will be started.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The traffic coming from the microservice &lt;em>customer&lt;/em> AND from the external client &lt;em>curl&lt;/em> must be simulated. To achieve this the following shell script can be used:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">#!/bin/sh
export CURL_POD=$(oc get pods -n tutorial -l app=curl | grep curl | awk &amp;#39;{ print $1}&amp;#39; )
export CUSTOMER_POD=$(oc get pods -n tutorial -l app=customer | grep customer | awk &amp;#39;{ print $1}&amp;#39; )
echo &amp;#34;A load generating script is running in the next step. Ctrl+C to stop&amp;#34;
while :; do
echo &amp;#34;Executing curl in curl pod&amp;#34;
oc exec -n tutorial $CURL_POD -- curl -s http://preference:8080 &amp;gt; /dev/null
sleep 0.5
echo &amp;#34;Executing curl in customer pod&amp;#34;
oc exec -n tutorial $CUSTOMER_POD -c customer -- curl -s http://preference:8080 &amp;gt; /dev/null
sleep 0.5
done&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>By executing this, it will first execute a curl command out of the &lt;em>curl&lt;/em> pod and then the same curl command out of the &lt;em>customer&lt;/em> container.
&lt;strong>Kepp this script running&lt;/strong>&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_enabling_mutual_tls">Enabling Mutual TLS&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Lets execute the shell script above and verify Kiali. As you notice there are requests coming from the &lt;em>customer&lt;/em> microservice and from the source called &lt;em>unknown&lt;/em>, which is the curl-service running outside the Service Mesh.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_1.png" alt="Kiali mtls 1"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali: traffic coming from customer microserver and external pod&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Enable the policy by creating the following object:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;preference-mutualtls&amp;#34;
spec:
targets:
- name: preference
peers:
- mtls:
mode: STRICT &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>We are enforcing mtls for the target preference&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds the curl pod cannot reach the application anymore:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">Executing curl in curl pod
command terminated with exit code 56
Executing curl in customer pod
Executing curl in curl pod
command terminated with exit code 56
Executing curl in customer pod
Executing curl in curl pod
command terminated with exit code 5&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is expected, since the &lt;em>preference&lt;/em> service allows traffic over mutual TLS only. This was enforced by the Policy object (&lt;strong>STRICT&lt;/strong> mode). The &lt;em>customer&lt;/em> service, which is running inside the Service Mesh receives the error &amp;#34;5053 Service Unavalable&amp;#34; since it tries to send traffic, but it does not know yet to use mTLS.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali you will see the following:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_2.png" alt="Kiali mtls 2"/>
&lt;/div>
&lt;div class="title">Figure 2. Kiali: traffic is blocked&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The &lt;em>curl&lt;/em> pod is greyed out, since the traffic it tries to send, never reaches the preference service and is therefor not counted in the metric.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To make &lt;em>customer&lt;/em> aware that mutual TLS shall be used, a DestinationRule must be configured:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;networking.istio.io/v1alpha3&amp;#34;
kind: &amp;#34;DestinationRule&amp;#34;
metadata:
name: &amp;#34;preference-destination-rule&amp;#34;
spec:
host: &amp;#34;preference&amp;#34;
trafficPolicy:
tls:
mode: ISTIO_MUTUAL &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Let’s use mTLS&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This defines that &lt;strong>ISTIO_MUTUAL&lt;/strong> shall be used for the service &lt;em>preference&lt;/em>. The &lt;em>customer&lt;/em> service recognizes this and automatically enables mTLS. After a few minutes the traffic graph in Kiali will show &amp;#34;green&amp;#34; traffic from &lt;em>customer&lt;/em> through &lt;em>preference&lt;/em> to _recommendation:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_3.png" alt="Kiali mtls 3"/>
&lt;/div>
&lt;div class="title">Figure 3. Kiali: traffic for Service Mesh components is fine again.&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_mutual_tls_migration">Mutual TLS Migration&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As you can see in the previous section, the &lt;em>curl&lt;/em> pod cannot reach the application inside the Service Mesh. This happens because &lt;em>prefernce&lt;/em> is strictly enforcing encrypted traffic, but &lt;em>curl&lt;/em> only sends plain text. Luckily, Istio provides a method to gradually monitor the traffic and migrate to mTLS. Instead of STRICT mode PERMISSIVE can be used. Enabling permissive mode, &lt;em>preference&lt;/em> will accept both, encrypted and plain-text traffic.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Replace the Policy object with the following configuration:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: &amp;#34;authentication.istio.io/v1alpha1&amp;#34;
kind: &amp;#34;Policy&amp;#34;
metadata:
name: &amp;#34;preference-mutualtls&amp;#34;
spec:
targets:
- name: preference
peers:
- mtls:
mode: PERMISSIVE&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f Policy-permissive.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now let’s wait a few minutes and observe Kiali, which should end up with:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-mtls_4.png" alt="Kiali mtls 4"/>
&lt;/div>
&lt;div class="title">Figure 4. Kiali: Encrypted and Plain-Text traffic&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see with the lock icon, the traffic between &lt;em>cunstomer&lt;/em> and &lt;em>preference&lt;/em> is encrypted, while the traffic from &lt;em>unknown&lt;/em> (which is our curl pod), is plain-text.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The errors you may see in Kiali happen due a known issue: &lt;a href="https://issues.jboss.org/browse/MAISTRA-1000" class="bare">https://issues.jboss.org/browse/MAISTRA-1000&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_cleanup">Cleanup&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Clean up your environment:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete policy -n tutorial preference-mutualtls
oc delete destinationrule -n tutorial preference-destination-rule&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Fault Injection</title><link>https://blog.stderr.at/service-mesh/2020/04/fault-injection/</link><pubDate>Tue, 07 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/fault-injection/</guid><description>&lt;div class="paragraph">
&lt;p>Tutorial 8 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> tries to cover Fault Injection by using Chaos testing method to verify if your application is running. This is done by adding the property HTTPFaultInjection to the VirtualService. The settings for this property can be for example: delay, to delay the access or abort, to completely abort the connection.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&amp;#34;&lt;em>Adopting microservices often means more dependencies, and more services you might not control. It also means more requests on the network, increasing the possibility for errors. For these reasons, it’s important to test your services’ behavior when upstream dependencies fail.&amp;#34;&lt;/em> [&lt;a href="#source_1">1&lt;/a>]&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparation">Preparation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before we start this tutorial, we need to clean up our cluster. This is especially important when you did the previous training &lt;a href="https://blog.stderr.at/service-mesh/2020/04/limit-egress/external-traffic">Limit Egress/External Traffic&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete deployment recommendation-v3
oc scale deployment recommendation-v2 --replicas=1
oc delete serviceentry worldclockapi-egress-rule
oc delete virtualservice worldclockapi-timeout&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Verify that 2 pods for the recommendation services are running (with 2 containers)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -l app=recommendation -n tutorial
NAME READY STATUS RESTARTS AGE
recommendation-v1-69db8d6c48-h8brv 2/2 Running 0 4d20h
recommendation-v2-6c5b86bbd8-jnk8b 2/2 Running 0 4d19h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_abort_connection_with_http_error_503">Abort Connection with HTTP Error 503&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>For the first example, we will need to modify the VirtualService and the DestinationRule. The VirtualService must be extended with a http fault section, which will abort the traffic 50% of the time.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create the VirtualService&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- fault:
abort:
httpStatus: 503
percent: 50
route:
- destination:
host: recommendation
subset: app-recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f VirtualService-abort.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Existing VirtualService with the name recommendation will be overwritten.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create the DestinationRule&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
app: recommendation
name: app-recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f destinationrule-faultinj.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Existing Destination with the name recommendation will be overwritten.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Check the traffic and verify that 50% of the connections will end with a 503 error:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export INGRESS_GATEWAY=$(oc get route customer -n tutorial -o &amp;#39;jsonpath={.spec.host}&amp;#39;)
sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_clean_up">Clean Up&lt;/h3>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete virtualservice recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_test_slow_connection_with_delay">Test slow connection with Delay&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>More interesting, in my opinion, to test is a slow connection. This can be tested by adding the &lt;em>fixedDelay&lt;/em> property into the VirtualService.
Like in the example below, we will use a VirtualService. This time &lt;strong>delay&lt;/strong> instead of &lt;strong>abort&lt;/strong> is used. The fixDelay defines a delay of 7 seconds for 50% of the traffic.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- fault:
delay:
fixedDelay: 7.000s
percent: 50
route:
- destination:
host: recommendation
subset: app-recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now send traffic into the application, you will see that some answers will have a delay of 7 seconds. Keep sending traffic in a loop.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Even more visible it will be, when you goto &amp;#34;Distributed Tracing&amp;#34; at the Kiali UI, select the service &lt;em>recommendation&lt;/em> and a small lookback of maybe 5min.
You will find that some requests are very fast, while other will tage about 7 seconds.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-delayed-traffic.png" alt="Kiali delayed traffic"/>
&lt;/div>
&lt;div class="title">Figure 1. Jaeger with delayed traffic.&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_retry_on_errors">Retry on errors&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>If a microservice is answering with an error, Service Mesh/Istio will automatically try to reach another pod providing the service. These retries can be modified. In order to make everything visible, we will use Kiali to monitor the traffic.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p> &lt;br/>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>We start by sending traffic into the application. This should be split evenly between v1 and v2 of the recommendation microservice&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 8329: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 11145
# 8330: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 9712
# 8331: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 11146
# 8332: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 9713
# 8333: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 11147&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali this ia visible in the Graphs, using the settings: &amp;#34;Versioned app graph&amp;#34; and &amp;#34;Requests percentage&amp;#34;&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-retry-traffic-split-50.png" alt="Kiali retry traffic split 50"/>
&lt;/div>
&lt;div class="title">Figure 2. Traffic is split by 50% between recommendation v1 nd v2&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>As second step we need to enable the &lt;em>nasty&lt;/em> mode for the microservice v2. This will simulate an outage, respoding with error 503 all the time. This change must be done &lt;strong>inside&lt;/strong> the container:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc exec -it $(oc get pods|grep recommendation-v2|awk &amp;#39;{ print $1 }&amp;#39;|head -1) -c recommendation /bin/bash&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Inside the container use the following command and exit the container again&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl localhost:8080/misbehave&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Kiali will now show that v1 will get 100% of the traffic, while v2 is shown as red. When you select the red square of v2 and then move the mouse over the red cross for the failing application, you will see that the pd itself is ready, but that 100% of the traffic is currently failing.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-retry-traffic-retry.png" alt="Kiali retry traffic retry"/>
&lt;/div>
&lt;div class="title">Figure 3. Traffic for v2 is failing&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>revert the change and fix v2 service&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc exec -it $(oc get pods|grep recommendation-v2|awk &amp;#39;{ print $1 }&amp;#39;|head -1) -c recommendation /bin/bash&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl localhost:8080/behave&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Verify in Kiali that everything is &amp;#34;green&amp;#34; again and that the traffic is split by 50% between v1 and v2.&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_sources">Sources&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a id="source_1">&lt;/a>[1]: &lt;a href="https://istiobyexample.dev/fault-injection/" target="_blank" rel="noopener">Istio By Example - Fault Injection&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Limit Egress/External Traffic</title><link>https://blog.stderr.at/service-mesh/2020/04/limit-egress/external-traffic/</link><pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/limit-egress/external-traffic/</guid><description>&lt;div class="paragraph">
&lt;p>Sometimes services are only available from outside the OpenShift cluster (like external API) which must be reached. Part 7 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> takes care and explains how to control the egress or external traffic. All operations have been successdully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_preparation">Preparation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before this tutorial can be started, ensure that 3 microservices are deployed (recommendation may have 2 versions) and that the objects Gateway and VirtualService are configured. The status should be like in &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/">Issue #4..6&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>You can verify this the following way:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)
curl $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>which should simply print:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7123&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_setup_recommendation_v3">Setup &lt;em>recommendation-v3&lt;/em>&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>We need to deploy version 3 of our recommendation microservice. This will perform an external API call to &lt;a href="http://worldclockapi.com" class="bare">http://worldclockapi.com&lt;/a> to retrieve the current time.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To deploy the Deployment v3:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/recommendation
oc apply -f kubernetes/Deployment-v3.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If you list the pods at this moment, you will see that only one container (Ready 1/1) is started. This happens because the Deployment yaml file is missing an annotation.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_fixing_missing_proxy_sidecar_container">Fixing missing proxy sidecar container&lt;/h3>
&lt;div class="paragraph">
&lt;p>After you applied the Deployment-v3.yml, only 1 container is started. The proxy sidecar is not injected, because an annotation is missing in the configuration for the Deployment.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To fix this use the following command:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc patch deployment recommendation-v3 -n tutorial -p &amp;#39;{&amp;#34;spec&amp;#34;:{&amp;#34;template&amp;#34;:{&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{&amp;#34;sidecar.istio.io/inject&amp;#34;:&amp;#34;true&amp;#34;}}}}}&amp;#39;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will automatically restart the pod with 2 containers.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_destinationrule_and_virtualservice">Create DestinationRule and VirtualService&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Use the following definition to create (overwrite) the DestinationRule for recommendation-v3.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
version: v3
name: version-v3&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Only version 3 is used for now. The other versions are still there, but ignored for our tests.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f DestinationRule_v3.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Define the VirtualService and send 100% of the traffic to v3 of the recommendation microservice.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v3
weight: 100&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
As an alternative, you can also edit the existing VirtualService and add the section for version-v3 with a weight of 100, while changing the weight of v1 and v2 to 0.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_test_egress_traffic">Test egress traffic&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As usual we test our application by sending traffic to it. The following command should print successful connection requests:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 1
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 2
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 3
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 4
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-06T18:31+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 5&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see 100% of the traffic is sent to v3 &lt;strong>AND&lt;/strong> a new field enters the output. The current time is now shown as well. The information for this field is fetched with an external API call to &lt;a href="http://worldclockapi.com" class="bare">http://worldclockapi.com&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The traffic is simply sent to an external destination. There is not limit yet. Readers of the Istio documentation will miss the object &lt;strong>ServiceEntry&lt;/strong> which somebody should think is required. However, Openshift is currently(?) configured in a way to simply allow ANY traffic. This is defined in a ConfigMap which might be changed to modify the default behavior. However, as soon as ServiceEntry and the appropriate VirtualService is configured, the traffic will be limited as well.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_limitcontrol_external_access">Limit/Control external access&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As you can see above you can simply send egress traffic without any control about what is allowed or not. In order to limit your outgoing traffic a new object called &lt;strong>ServiceEntry&lt;/strong> must be defined as well as a change in your &lt;strong>VirtualService&lt;/strong> will be required.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Define the ServiceEntry and apply it to your cluster:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: worldclockapi-egress-rule
spec:
hosts:
- worldclockapi.com
ports:
- name: http-80
number: 81 &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
protocol: http&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Wrong port 81 is set on purpose for demonstration&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The port &lt;strong>number: 81&lt;/strong> is set on purpose, to prove that the traffic will not work with a wrong ServiceEntry.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc create -f ServiceEntry.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To actually limit the traffic a link between the ServiceEntry and a VirtualService, which defines the external destination, must be created. Moreover, a timeout is set for possible connection errors, to keep the application responding even when the external API is down.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: worldclockapi-timeout &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
spec:
hosts:
- worldclockapi.com &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
http:
- timeout: 3s &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
route:
- destination:
host: worldclockapi.com
weight: 100 &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The name of the object&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The external hostname we want to reach&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The timeout setting in seconds&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The destination route, which is sending 100% of the external traffic to the host above&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VirtualService-worldclockapi.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now run a connection test you will still get an error.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1 $GATEWAY_URL
# customer =&amp;gt; Error: 503 - preference =&amp;gt; Error: 500 ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_fix_serviceentry">Fix ServiceEntry&lt;/h3>
&lt;div class="paragraph">
&lt;p>This happens, because we misconfigured the ServiceEntry on purpose to demonstrate that the traffic is sent to worldclockapi.com:80.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Fix the ServiceEntry object and apply to your cluster:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: worldclockapi-egress-rule
spec:
hosts:
- worldclockapi.com
ports:
- name: http-80
number: 80 &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
protocol: http&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Changed from 81 to 80&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f ServiceEntry.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now the traffic should work and gives you back a connection to microservice and a current time:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 10 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 138
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 139
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 140
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 141
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 142
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 143
# 6: customer =&amp;gt; preference =&amp;gt; recommendation v3 2020-04-07T07:47+02:00 from &amp;#39;83bbb6d11a7e&amp;#39;: 144&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_kiali">Verify Kiali&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali_with_external_service.png?width=940px&amp;amp;height=250px" alt="Kiali with external service"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali shows traffic to the external service&lt;/div>
&lt;/div>
&lt;hr/>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_optional_disallow_any_connections">OPTIONAL: Disallow ANY connections&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
This is a change in the default ConfigMap of the ServiceMesh. Do this on your own risk and always consult the latest documentation of OCP.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As explained above, we are able to connect to an external service without any limitation. The ServiceEntry object together with the VirtualService define the actual destination and would disallow traffic if they are wrongly configured, but if you forget these entries, it would still be possible to establish an egress connection.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In OpenShift a ConfigMap in the &lt;em>istio-system&lt;/em> namespace defines the default behavior. There are two possibilities:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>ALLOW_ANY - outbound traffic to unknown destinations will be allowed, in case there are no services or ServiceEntries for the destination port&lt;/p>
&lt;/li>
&lt;li>
&lt;p>REGISTRY_ONLY - restrict outbound traffic to services defined in the service registry as well&lt;/p>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Let’s Cleanup the ServiceEntry and the VirtualService which have been created above&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete serviceentry worldclockapi-egress-rule
serviceentry.networking.istio.io &amp;#34;worldclockapi-egress-rule&amp;#34; deleted
oc delete virtualservice worldclockapi-timeout
virtualservice.networking.istio.io &amp;#34;worldclockapi-timeout&amp;#34; deleted&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Now traffic to the external service will be allowed again
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Modify the ConfigMap &lt;em>istio&lt;/em> in the namespace &lt;em>istio-system&lt;/em>&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get configmap istio -n istio-system -o yaml | sed &amp;#39;s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g&amp;#39; | oc replace -n istio-system -f -&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Wait a few seconds and try to connect. You will see that the connection is not possible anymore.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
If you now re-create the &lt;strong>ServiceEntry&lt;/strong> the connection will be possible again, since the service is registered to the Service Mesh.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Advanced Routing Example</title><link>https://blog.stderr.at/service-mesh/2020/04/advanced-routing-example/</link><pubDate>Fri, 03 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/advanced-routing-example/</guid><description>&lt;div class="paragraph">
&lt;p>Welcome to part 6 of &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> Advanced routing, like Canary Deployments, traffic mirroring and loadbalancing are discussed and tested. All operations have been successdully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_advanced_routing">Advanced Routing&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>During &lt;a href="https://blog.stderr.at/service-mesh/2020/04/routing-example">Issue #5&lt;/a> some simple routing was implemented. The traffic was split by 100% to a new version (v2) of the &lt;em>recommendation&lt;/em> microservice.
This section shall give a brief overview of advanced routing possibilities.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_canary_deployments">Canary Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>A canary deployment is a strategy to roll out a new version of your service by using traffic splitting. A small amount of traffic (10%) will be sent to the new version, while most of the traffic will be sent to the old version still. The traffic to the new version can be analysed and if everything works as expected more and more traffic can be sent to the new version.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To enable split traffic, the VirtualService must be update:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v1
weight: 90
- destination:
host: recommendation
subset: version-v2
weight: 10&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VitualService_split_v1_and_v1.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Test the traffic and verify that 10% will be sent to v2&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 100 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1060
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1061
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 2060
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1062
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 1063
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If an error is shown, then you most probably forget to configure the DestinationRule as described &lt;a href="https://blog.stderr.at/service-mesh/2020/04/routing-example">here&lt;/a>.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali_Canary_90_10.png?width=940px&amp;amp;height=224px" alt="Kiali Canary 90 10"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali split traffic 90/10&lt;/div>
&lt;/div>
&lt;div style="page-break-after: always;">&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_routing_based_on_user_agent_header">Routing based on user-agent header&lt;/h3>
&lt;div class="paragraph">
&lt;p>It is possible to send traffic to different versions based on the browser type which is calling the application.
In our test application the service &lt;em>customer&lt;/em> is setting the header &lt;strong>baggage-user-agent&lt;/strong> and propagates it to the other services.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
&amp;gt;&amp;gt; headers.putSingle(&amp;#34;baggage-user-agent&amp;#34;, userAgent);
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Create the following file&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- match:
- headers:
baggage-user-agent:
regex: .*Safari.*
route:
- destination:
host: recommendation
subset: version-v2
- route:
- destination:
host: recommendation
subset: version-v1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>and apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VitualService_safari.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In order to test the result, either use the appropriate browser or use &lt;em>curl&lt;/em> to set the user-agent. As expected, request from &lt;em>Safari&lt;/em> are sent to v2, other are sent to v1.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Safari&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl -v -A Safari $GATEWAY_URL
[...]
&amp;gt; User-Agent: Safari
[...]
customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 2365&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Firefox&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">curl -v -A Firefox $GATEWAY_URL
[...]
&amp;gt; User-Agent: Firefox
[...]
customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3762&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div style="page-break-after: always;">&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_mirroring_traffic">Mirroring Traffic&lt;/h3>
&lt;div class="paragraph">
&lt;p>Mirroring Traffic, aka Dark Launch, will duplicate the traffic to another service, allowing you to analyse it before sending production data to it. Responses of the mirrored requests are ignored.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Run the following command and be sure that recommendation-v1 and recommendation-v2 are both running:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pod -n tutorial| grep recommendation
recommendation-v1-69db8d6c48-h8brv 2/2 Running 0 24h
recommendation-v2-6c5b86bbd8-jnk8b 2/2 Running 0 23h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Update the VirtualService, so that version v2 will receive mirrored traffic, while the actual request will be sent to v1:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v1
mirror: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
host: recommendation
subset: version-v2&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>This must be set to &amp;#39;mirror&amp;#39;&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Apply the change&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f VitualService_mirrored-traffic.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now lets open and follow the logs of recommandation-v2 in order to see that traffic will reach this service, but responses are ignored:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc logs -f $(oc get pods|grep recommendation-v2|awk &amp;#39;{ print $1 }&amp;#39;) -c recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In a second terminal window send some traffic to our service.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 100 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>You will see that only v1 answers, while in the 2nd window, v2 gets the same traffic.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_load_balancing">Load Balancing&lt;/h3>
&lt;div class="paragraph">
&lt;p>In the default OpenShift environment the kube-proxy forwards all requests to pods randomly. With Red Hat ServiceMesh it is possible to add more complexity and let the Envoy proxy handle load balancing for your services.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Three methods are supported:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>random&lt;/p>
&lt;/li>
&lt;li>
&lt;p>round-robin&lt;/p>
&lt;/li>
&lt;li>
&lt;p>least connection&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The round robin function is used by default, when there is no DestinationRule configured. We can use the DestinationRule to use the least connection option to see how the traffic is sent.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Before we start we need to delete the VirtualService for the recommendation microservice&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc delete virtualservice recommendation&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The we scale version v2 to 3:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc scale deployment recommendation-v2 --replicas=3&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds the folling pods should run now:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-jdjlg 2/2 Running 1 25h
preference-v1-7fdb89c86b-nktqn 2/2 Running 0 25h
recommendation-v1-69db8d6c48-h8brv 2/2 Running 0 25h
recommendation-v2-6c5b86bbd8-6lgz6 2/2 Running 0 91s
recommendation-v2-6c5b86bbd8-dnc8b 2/2 Running 0 91s
recommendation-v2-6c5b86bbd8-jnk8b 2/2 Running 0 24h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you send traffic to the application, you would see that 3 quarter are sent to v1 and one is sent to v1.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With the following DestinationRule the traffic will be sent randomly to the application&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
trafficPolicy:
loadBalancer:
simple: RANDOM&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you now sent traffic to the service, you will see that the traffic is sent randomly to the versions. (verify the serial number)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 100 $GATEWAY_URL
# 140: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 5729
# 141: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7119
# 142: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 361
# 143: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 362
# 144: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 5730
# 145: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 362
# 146: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7120
# 147: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 7121
# 148: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 363
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Routing Example</title><link>https://blog.stderr.at/service-mesh/2020/04/routing-example/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/04/routing-example/</guid><description>&lt;div class="paragraph">
&lt;p>In part 5 of the &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> tutorials, basic routing, using the objects VirtualService and DesitnationRule, are described. All operations have been successfully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_some_theory">Some Theory&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In this section another version of the &lt;em>recommendation&lt;/em> microservice will be deployed. The traffic to the new version will be controlled with different settings of the VirtualService. Multiple scenarios can be realized with ServiceMesh. In general these are defined as follows ([&lt;a href="#source_1">1&lt;/a>]):&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_blue_green_deployments">Blue-Green Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>In a Blue-Green deployment the old version (green) is kept running, while a new version (blue) is deployed and tested. When testing is successful, the 100% of the traffic is switched to the new version.
If there is any error, the traffic could be switched back to the green version.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_ab_deployments">A/B Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>A/B deployments, in difference to Blue-Green deployments, will enable you to try a new version of the application in a limited way in the production environment. It is possible to specify that the production version gets most of the user requests, while a limited number of requests is sent to the new version. This could be specified by location of the user for example, so that all users from Vienna are sent to the new version, while all others are still using the old version.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_canary_deployments">Canary Deployments&lt;/h3>
&lt;div class="paragraph">
&lt;p>Canary releases can be used to allow a small, minimum amount of traffic to the new version of your application. This traffic can be increased gradually until all traffic is sent to the new version. If any issues are found, you can roll back and send the traffic to the old version.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>It is assumed that an OpenShift environment is up and running and that Issues #1 - #3 are done at least:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/installation/">Openshift 4 and ServiceMesh 1 - Installation&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/">Openshift 4 and ServiceMesh 2 - Deploy Microservices&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Openshift 4 and ServiceMesh 3 - Ingress Traffic&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prepare_simple_routing">Prepare Simple Routing&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_optional_build_the_recommendation_microservice">OPTIONAL: Build the &lt;em>recommendation&lt;/em> microservice&lt;/h3>
&lt;div class="paragraph">
&lt;p>If you want to locally build the microservice, you must change the source code from version v1 to v2 the following way:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Open the file:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">istio-tutorial/recommendation/java/vertx/src/main/java/com/redhat/developer/demos/recommendation/RecommendationVerticle.java&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>and change the following line from v1 to &lt;strong>v2&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-java" data-lang="java">private static final String RESPONSE_STRING_FORMAT = &amp;#34;recommendation &lt;strong>v2&lt;/strong> from &amp;#39;%s&amp;#39;: %d\n&amp;#34;;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now you can build the image:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd istio-tutorial/recommendation/java/vertx
mvn package
podman build -t example/recommendation:v2 . &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Note the v2 tag&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_create_second_deployment_with_version2">Create second deployment with version2&lt;/h3>
&lt;div class="paragraph">
&lt;p>A deployment with our recommendation:v2 microservice must be created. A service object must not be created this time, as it already exists.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/recommendation/
oc apply -f kubernetes/Deployment-v2.yml -n tutorial
oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you want to &lt;em>diff&lt;/em> v1 and v2 deployment, you will notice that the main change is the image which gets pulled.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-diff" data-lang="diff">diff recommendation/kubernetes/Deployment-v2.yml recommendation/kubernetes/Deployment.yml
6,7c6,7
&amp;lt; version: v2
&amp;lt; name: recommendation-v2
---
&amp;gt; version: v1
&amp;gt; name: recommendation-v1
13c13
&amp;lt; version: v2
---
&amp;gt; version: v1
18c18
&amp;lt; version: v2
---
&amp;gt; version: v1
27c27
&amp;lt; image: quay.io/rhdevelopers/istio-tutorial-recommendation:v2.1
---
&amp;gt; image: quay.io/rhdevelopers/istio-tutorial-recommendation:v1.1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_call_application">Call application&lt;/h3>
&lt;div class="paragraph">
&lt;p>Execute the test command to access the application. Since no rules are defined yet, the traffic is split by 50% to version 1 and version 2 (round robin):&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 10 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 27
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 27
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 28
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 28
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali presents this as well:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-v1-v2-trafficsplit1.png" alt="Kiali v1 v2 trafficsplit1"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali sends 50% to v1 and v2&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_send_all_traffic_to_recommendationv2">Send all traffic to &lt;em>recommendation:v2&lt;/em>&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To route the traffic accordingly a &lt;strong>DestinationRule&lt;/strong> and a &lt;strong>VirtualService&lt;/strong> must be created for &lt;em>recommendation&lt;/em>. While the DesinationRule will add a name to each version, VirtualService specifies the actual destination of the traffic.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_define_destinationrule_for_recommendation">Define DestinationRule for &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The object DestinationRule will define the versions in &lt;em>subsets&lt;/em>.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: recommendation
spec:
host: recommendation
subsets:
- labels:
version: v1
name: version-v1
- labels:
version: v2
name: version-v2&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Create the object with the command: &lt;em>oc create -f &amp;lt;filename&amp;gt;&lt;/em>&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_define_virtualservice_for_recommendation">Define VirtualService for &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The VirtualService defines that 100% (weight) of the traffic for recomendation (host) will be sent to the subset (version-v2), which is defined in the DefinationRule&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: recommendation
spec:
hosts:
- recommendation
http:
- route:
- destination:
host: recommendation
subset: version-v2
weight: 100&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Create the object with the command: &lt;em>oc create -f &amp;lt;filename&amp;gt;&lt;/em>&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_call_application_2">Call application&lt;/h3>
&lt;div class="paragraph">
&lt;p>If you now call the application, only traffic to v2 should be shown:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh ~/run.sh 1000 $GATEWAY_URL
# 0: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 27
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 27
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v2 from &amp;#39;3cbba7a9cde5&amp;#39;: 28
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 28
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Kiali presents this as well and send 100% of the traffic to &lt;em>recommendation:v2&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-100-v2-trafficsplit2.png" alt="Kiali 100 v2 trafficsplit2"/>
&lt;/div>
&lt;div class="title">Figure 2. Kiali sends 100% to v2&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_sources">Sources&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a id="source_1">&lt;/a>[1]: &lt;a href="https://dzone.com/articles/traffic-management-with-istio-2-grayscale-release" target="_blank" rel="noopener">DZone: Traffic Management With Istio&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Ingress with custom domain</title><link>https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/ingress-with-custom-domain/</guid><description>&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Since Service Mesh 1.1, there is a better way to achieve the following. Especially the manual creation of the route is not required anymore. Check the following article to &lt;a href="https://blog.stderr.at/service-mesh/2020/05/enable-automatic-route-creation">Enable Automatic Route Creation&lt;/a>.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Often the question is how to get traffic into the Service Mesh when using a custom domains. Part 4 our our tutorials series &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> will use a dummy domain &lt;strong>&amp;#34;hello-world.com&amp;#34;&lt;/strong> and explains the required settings which must be done.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_modify_gateway_and_virtualservice">Modify Gateway and VirtualService&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Issue #3&lt;/a> explains how to get ingress traffic into the Service Mesh, by defining the &lt;strong>Gateway&lt;/strong> and the &lt;strong>VirtualService&lt;/strong>. We are currently using the default ingress route defined in the &lt;em>istio_system&lt;/em> project.&lt;br/>
But what if a custom domain shall be used?&lt;br/>
In such case another route must be defined in the &lt;em>istio-system&lt;/em> project and small configuration changes must be applied.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>First lets create a slightly modified &lt;em>Gateway.yaml&lt;/em>:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: ingress-gateway-exampleapp
spec:
selector:
istio: ingressgateway # use istio default controller
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- &amp;#34;hello-world.com&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>add you custom domain here
&lt;div class="paragraph">
&lt;p>The only difference is at the hosts which was changed from &amp;#39;*&amp;#39; to &amp;#39;hello-world.com&amp;#39;&lt;/p>
&lt;/div>&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>As second change, the VirtualService must be modified as well with the custom domain:&lt;/p>
&lt;div class="paragraph">
&lt;p>VirtualService.yaml:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: ingress-gateway-exampleapp
spec:
hosts:
- &amp;#34;hello-world.com&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
gateways:
- ingress-gateway-exampleapp
http:
- match:
- uri:
exact: /
route:
- destination:
host: customer
port:
number: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>add you custom domain here&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Replace current objects in OpenShift:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc replace -f Gateway.yaml -n tutorial
oc replace -f VirtualService.yaml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Create a new route under the project &lt;em>istio-system&lt;/em>:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: route.openshift.io/v1
kind: Route
metadata:
name: hello-world.com &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: istio-system &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
spec:
host: hello-world.com &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
to:
kind: Service
name: istio-ingressgateway &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
port:
targetPort: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>add you custom domain here&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>the route must be created at istio-system&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>add you custom domain here&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>this is the service as it was created by the operator&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_optional_add_custom_domain_to_local_hosts_file">OPTIONAL: Add custom domain to local hosts file&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The custom domain &lt;strong>hello-world.com&lt;/strong> must be resolvable somehow, pointing to the ingress router of OpenShift.
This can be done, by adding the domain into the local hosts file (with all limitations this brings with it)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># Get IP address of:
oc -n istio-system get route istio-ingressgateway
echo &amp;#34;x.x.x.x hello-world.com&amp;#34; &amp;gt;&amp;gt; /etc/hosts&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_some_example_traffic">Create some example traffic&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>We will reuse the script of &lt;a href="https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/">Issue #3&lt;/a> to simulate traffic.
Since we changed the domain, the connection will go to hello-world.com&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh run-check.sh 1000 hello-world.com&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will send 1000 requests to our application:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6626
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6627
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6628
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6629
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6630
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 6631
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Ingress Traffic</title><link>https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/ingress-traffic/</guid><description>&lt;div class="paragraph">
&lt;p>Part 3 of tutorial series &lt;strong>OpenShift 4 and Service Mesh&lt;/strong> will show you how to create a Gateway and a VirtualService, so external traffic actually reaches your Mesh. It also provides an example script to run some curl in a loop.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_configure_gateway_and_virtualservice_example">Configure Gateway and VirtualService Example&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With the microservices deployed during &lt;a href="https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/">Issue #2&lt;/a>, it makes sense to test the access somehow. In order to bring traffic into the application a Gateway object and a VirtualService object must be created.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;em>Gateway&lt;/em> will be the entry point which forward the traffic to the &lt;em>istio ingressgateway&lt;/em>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: ingress-gateway-exampleapp
spec:
selector:
istio: ingressgateway # use istio default controller
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- &amp;#34;*&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As 2nd object a VirtualService must be created:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: ingress-gateway-exampleapp
spec:
hosts:
- &amp;#34;*&amp;#34;
gateways:
- ingress-gateway-exampleapp
http:
- match:
- uri:
exact: /
route:
- destination:
host: customer
port:
number: 8080&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Get all istio-io related objects of your project. These objects represent the network objects of Service Mesh, like Gateway, VirtualService and DestinationRule (explained later)&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get istio-io -n tutorial
NAME HOST AGE
destinationrule.networking.istio.io/recommendation recommendation 3d21h
NAME AGE
gateway.networking.istio.io/ingress-gateway 4d15h
NAME GATEWAYS HOSTS AGE
virtualservice.networking.istio.io/ingress-gateway [ingress-gateway] [*] 4d15h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_create_some_example_traffic">Create some example traffic&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before we start, lets fetch the default route of our Service Mesh:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath=&amp;#39;{.spec.host}&amp;#39;)&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This should return: &lt;strong>istio-ingressgateway-istio-system.apps.&amp;lt;clustername&amp;gt;&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now, let’s create a shell script to run some curl commands in a loop and can be easily reused for other scenarios:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">#!/bin/bash
numberOfRequests=$1
host2check=$2
if [ $# -eq 0 ]; then
echo &amp;#34;better define: &amp;lt;script&amp;gt; #ofrequests hostname2check&amp;#34;
echo &amp;#34;Example: run.sh 100 hello.com&amp;#34;
let &amp;#34;numberOfRequests=100&amp;#34;
else
let &amp;#34;i = 0&amp;#34;
while [ $i -lt $numberOfRequests ]; do
echo -n &amp;#34;# $i: &amp;#34;; curl $2
let &amp;#34;i=$((i + 1))&amp;#34;
done
fi&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Run the script and check the output:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">sh run-check.sh 1000 $GATEWAY_URL&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will send 1000 requests to our application:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash"># 0: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3622
# 1: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3623
# 2: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3624
# 3: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3625
# 4: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3626
# 5: customer =&amp;gt; preference =&amp;gt; recommendation v1 from &amp;#39;f11b097f1dd0&amp;#39;: 3627
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_verify_in_kiali">Verify in Kiali&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To verify in Kiali our application, open the URL in your browser and login using your OpenShift credentials.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
If you do not know the URL for Kiali, execute the following command&lt;br/>
oc get route kiali -n istio-system
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Switch the the &lt;strong>Graph&lt;/strong> view and you should see the following picture:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/service-mesh/images/Kiali-Example-1.png" alt="Kiali Example 1"/>
&lt;/div>
&lt;div class="title">Figure 1. Kiali Graph&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Deploy Microservices</title><link>https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/deploy-microservices/</guid><description>&lt;div class="paragraph">
&lt;p>The second tutorials explains how to install an example application containing thee microservices. All operations have been successfully tested on OpenShift 4.3.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_introduction">Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As quickly explained at &lt;a href="https://blog.stderr.at/service-mesh/2020/03/installation/">Issue #1&lt;/a>, OpenShift 4.3 and the Service Mesh shall be installed already. At this point you should have all 4 operators installed and ready.
The test application used in this scenario is based on Java and contains 3 microservices in the following traffic flow:&lt;/p>
&lt;/div>
&lt;div class="paragraph text-center">
&lt;p>Customer ⇒ Preference ⇒ Recomandation&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The microservices are the same as used at the &lt;a href="https://learn.openshift.com/servicemesh">Interactive Learning Portal&lt;/a>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_deploy_microservices">Deploy microservices&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>First lets create a new project for our tests&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc new-project tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>EITHER&lt;/strong>: Add &lt;em>tutorial&lt;/em> to ServiceMeshMemberRoll&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="admonitionblock tip">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-tip" title="Tip">&lt;/i>
&lt;/td>
&lt;td class="content">
Service Mesh 1.1 now supports the object &lt;strong>ServiceMember&lt;/strong> which can created under the application namespace and which automatically configures the ServiceMemberRoll. However, below description still works.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>+
OpenShift will auto-inject the sidecar proxy to pods of a namespace, if the namespace is configured in the ServiceMeshMemberRoll object which was created for the operator.&lt;/p>
&lt;/div>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>Create the file &lt;em>memberroll.yaml&lt;/em>:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; memberroll.yaml
apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
name: default
spec:
members:
- tutorial
EOF&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Add the namespace to the member roll:&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc apply -f memberroll.yaml -n istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If you already have namespaces configured for ServiceMeshMemberRoll, better modify the object manually. Custom Resource Definitions (CRD) do not like to be modified on the fly (currently?)
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>OR&lt;/strong>: Create ServiceMeshMember object:
Available since ServiceMesh 1.1&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
name: default
namespace: tutorial
spec:
controlPlaneRef:
name: basic-install
namespace: istio-system&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Download the tutorial application locally&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/redhat-developer-demos/istio-tutorial/&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_deploy_microservice_customer">Deploy microservice: &lt;em>customer&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>To deploy the first microservice 2 objects (Deployment and Service) must be created. Moreover, the service will be exposed, since the service &lt;em>customer&lt;/em> is our entry point.&lt;br/>
Verify ~/istio-tutorial/customer/kubernetes/Deployment.yml to check where the actual image is coming from: quay.io/rhdevelopers/istio-tutorial-customer:v1.1&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/customer
oc apply -f kubernetes/Deployment.yml -n tutorial
oc apply -f kubernetes/Service.yml -n tutorial
oc expose service customer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check if pods are running with two containers:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The result should look somehow like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-g77bs 2/2 Running 0 52m&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If there is only 1 container running, indicated by READY = 1/1, then most likely the ServiceMeshMemberRoll was not updated with the name &lt;em>tutorial&lt;/em> or contains a wrong project name.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_deploy_microservice_preference">Deploy microservice: &lt;em>preference&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The deployment of the microservice &lt;em>preference&lt;/em> is exactly like it is done for &lt;em>customer&lt;/em>, except that no service must be exposed:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/preference/
oc apply -f kubernetes/Deployment.yml -n tutorial
oc apply -f kubernetes/Service.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check if pods are running with two containers:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The result should look somehow like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-g77bs 2/2 Running 0 4d15h
preference-v1-7fdb89c86b-gkk5g 2/2 Running 0 4d14h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_deploy_microservice_recommendation">Deploy microservice: &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The deployment of the microservice &lt;em>recommendation&lt;/em> is exactly like it is done for &lt;em>preference&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/recommendation/
oc apply -f kubernetes/Deployment.yml -n tutorial
oc apply -f kubernetes/Service.yml -n tutorial&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check if pods are running with two containers:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get pods -w&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The result should look somehow like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">NAME READY STATUS RESTARTS AGE
customer-6948b8b959-g77bs 2/2 Running 0 4d15h
preference-v1-7fdb89c86b-gkk5g 2/2 Running 0 4d14h
recommendation-v1-69db8d6c48-p9w2b 2/2 Running 0 4d14h&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_optional_build_the_images">Optional: build the images&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>It is possible (and probably a good training) to build the microservices locally to understand how this works.
In order to achieve this the packages &lt;em>maven&lt;/em> and &lt;em>podman&lt;/em> must be installed.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_build_customer">Build &lt;em>customer&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>Go to the source folder of &lt;em>customer&lt;/em> application and build it:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/projects/istio-tutorial/customer/java/springboot
mvn package&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It will take a few seconds, but it should give &amp;#34;BUILD SUCCESS&amp;#34; as output, if everything worked.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now the image will be built using podman&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">podman build -t example/customer .&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_build_preference">Build &lt;em>preference&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The image build process of the second microservice follows the same flow as &lt;em>customer&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/istio-tutorial/preference/java/springboot
mvn package
podman build -t example/preference:v1 .&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
the &amp;#34;v1&amp;#34; tag at the image name is important and must be used.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_build_recommendation">Build &lt;em>recommendation&lt;/em>&lt;/h3>
&lt;div class="paragraph">
&lt;p>The image build process of the third microservice follows the same flow as &lt;em>preference&lt;/em>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">cd ~/projects/istio-tutorial/recommendation/java/vertx
mvn package
podman build -t example/recommendation:v1 .&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
the &amp;#34;v1&amp;#34; tag at the image name is important and must be used. Later other versions will be deployed.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Installation</title><link>https://blog.stderr.at/service-mesh/2020/03/installation/</link><pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/service-mesh/2020/03/installation/</guid><description>&lt;div class="paragraph">
&lt;p>Everything has a start, this blog as well as the following tutorials. This series of tutorials shall provide a brief and working overview about &lt;strong>OpenShift Service Mesh&lt;/strong>. It is starting with the installation and the first steps, and will continue with advanced settings and configuration options.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_openshift_4_x_and_servicemesh">OpenShift 4.x and ServiceMesh&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
&lt;strong>UPDATE&lt;/strong>: At 10th April 2020 Red Hat released Service Mesh version 1.1 which supports:
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Istio - 1.4.6&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kiali - 1.12.7&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Jaeger - 1.17.1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following tutorials for &lt;strong>OpenShift Service Mesh&lt;/strong> are based on the official documentation: &lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/servicemesh-release-notes.html" target="_blank" rel="noopener">OpenShift 4.3 Service Mesh&lt;/a> and on the &lt;a href="https://learn.openshift.com/servicemesh" target="_blank" rel="noopener">Interactive Learning Portal&lt;/a>. All operations have been successfully tested on OpenShift 4.3.
Currently OpenShift supports Istio 1.4.6, which shall be updated in one of the future releases.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To learn the basics of Service Mesh, please consult the documentation as they are not repeated here.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It is assumed that OpenShift has access to external registries, like quay.io.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Other resource I can recommend are:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://istiobyexample.dev/" target="_blank" rel="noopener">Istio By Example&lt;/a>: A very good and brief overview of different topics by Megan O’Keefe.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://istio.io" target="_blank" rel="noopener">Istio&lt;/a>: The Istio documentation&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>At the very beginning OpenShift must be installed. This tutorial is based on OpenShift 4.3 and a Lab installation on Hetzner was used.
Moreover, it is assumed that the &lt;a href="https://mirror.openshift.com/pub/openshift-v4/clients/oc/4.3/" target="_blank" rel="noopener">OpenShift Client&lt;/a> and Git are installed on the local system.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>During the tutorials an example application in the namespace &lt;em>tutorial&lt;/em> will be deployed. This application will contain 3 microservices:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>customer (the entry point)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>preference&lt;/p>
&lt;/li>
&lt;li>
&lt;p>recommendation&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This application is also used at the &lt;a href="https://learn.openshift.com/servicemesh" target="_blank" rel="noopener">Interactive Learning Portal&lt;/a> which can be tested there interactively. However, the training is still based on OpenShift version 3.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_install_red_hat_service_mesh">Install Red Hat Service Mesh&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To deploy Service Mesh on Openshift 4 follow the guide at &lt;a href="https://docs.openshift.com/container-platform/4.3/service_mesh/service_mesh_install/installing-ossm.html" target="_blank" rel="noopener">Installing Red Hat OpenShift Service Mesh&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In short, multiple operators must be installed:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Elasticsearch&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Jaeger&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kiali&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Service Mesh&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Elasticsearch is a very memory intensive application. Per default it will request 16GB of memory which can be reduced on Lab environments.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_link_jaeger_and_grafana_to_kiali">Link Jaeger and Grafana to Kiali&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In the lab environment it happened that Kiali was not able to auto detect Grafana or Jaeger.
This is visible when the link &lt;em>Distributed Tracing&lt;/em> is missing in the left menu.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To fix this the ServiceMeshControlPlane object in the istio-system namespace must be updated with 3 lines:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">oc edit ServiceMeshControlPlane -n istio-system
kiali: # ADD THE FOLLOWING LINES
dashboard:
grafanaURL: https://grafana-istio-system.apps.&amp;lt;your clustername&amp;gt;
jaegerURL: https://jaeger-istio-system.apps.&amp;lt;your clustername&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This change will take a few minutes to be effective.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>YAUB Yet Another Useless Blog</title><link>https://blog.stderr.at/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/</guid><description>
&lt;h1 class="blog-title gradient-header">Welcome to Yet Another Useless Blog&lt;/h1>
&lt;p>Well we hope the articles here are not totally useless :)&lt;/p>
&lt;p>Who are we, you might ask.
We (Thomas Jungbauer and Toni Schmidbauer) are two old IT guys, working in the business since more than 20 years. At the moment we are architects at Red Hat Austria, mainly responsible helping customers with OpenShift or Ansible architectures. &lt;/p>
&lt;p>The articles in this blog shall help to easily test and understand specific issues so they can be reproduced and tested. We simply wrote down what we saw in the field and of what we thought it might be helpful, so no frustrating searches in documentations or manual testing is required. &lt;/p>
&lt;p>If you have any question, please feel free to send us an e-mail or create a &lt;a href="https://github.com/stderrat/stderrat.github.io/issues" >GitHub issue&lt;/a>&lt;/p></description></item></channel></rss>