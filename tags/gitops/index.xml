<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>GitOps on TechBlog about OpenShift/Ansible/Satellite and much more</title><link>https://blog.stderr.at/tags/gitops/</link><description>TechBlog about OpenShift/Ansible/Satellite and much more</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Toni Schmidbauer &amp; Thomas Jungbauer</copyright><lastBuildDate>Thu, 17 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stderr.at/tags/gitops/index.xml" rel="self" type="application/rss+xml"/><item><title>What's New</title><link>https://blog.stderr.at/whatss-new/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/whatss-new/</guid><description/></item><item><title>GitOps Episodes</title><link>https://blog.stderr.at/gitopscollection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/</guid><description/></item><item><title>OpenShift</title><link>https://blog.stderr.at/openshift/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/openshift/</guid><description/></item><item><title>Reusable Argo CD Application Helm Template</title><link>https://blog.stderr.at/gitopscollection/2025-07-17-common-template-application/</link><pubDate>Thu, 17 Jul 2025 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2025-07-17-common-template-application/</guid><description>&lt;div class="paragraph">
&lt;p>When working with Argo CD at scale, you often find yourself creating similar Application manifests repeatedly. Each application needs the same basic structure but with different configurations for source repositories, destinations, and sync policies. Additionally, managing namespace metadata becomes tricky when you need to conditionally control whether Argo CD should manage namespace metadata based on sync options.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In this article, I’ll walk you through a reusable Helm template that solves these challenges by providing a flexible, DRY (Don’t Repeat Yourself) approach to creating Argo CD Applications. This template is available in my public Helm Chart library and can easily be used by anyone.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_problem">The Problem&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Traditional Argo CD Application manifests suffer from several issues:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>Repetitive Code&lt;/strong>: Each application requires similar boilerplate YAML&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Configuration Validation&lt;/strong>: Manual validation of required fields across multiple applications&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Maintenance Overhead&lt;/strong>: Changes to common patterns require updates across multiple files&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_but_i_can_do_this_manually_right">But I can do this manually, right?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Of course, nobody prevents you from creating an Argo CD Application manifest manually or using the UI to enter the values there, but sometimes you just want to get things done faster or help your team with a consistent way to create Argo CD Applications. Often teams do not want to learn about a new tool like Argo CD and maybe you want to automate the creation by using a CI/CD pipeline.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_solution_a_reusable_helm_template">The Solution: A Reusable Helm Template&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>I already work with a common template library for all of my Helm Charts. The idea is to have repeatable snippets in my tpl charts and I can reuse them in all other charts. Recently, I started testing the templating of entire Kubernetes manifests.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To address the above issues, I’ve created a comprehensive Helm template that will render an Argo CD Application. But let’s start with the end result.
Your team wants to create a new Argo CD Application. They can do this either via the UI, via the CLI, by creating the YAML file manually, or through pull request or CI/CD integration. Ultimately, the minimum required information is:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>The name of the application&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The namespace of the application&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The source repository&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The destination repository&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So something like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">argocd_applications:
my-app: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: &amp;#34;openshift-gitops&amp;#34;
source: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
repositoryURL: &amp;#34;https://github.com/argoproj/argocd-example-apps.git&amp;#34;
targetRevision: &amp;#34;HEAD&amp;#34;
path: &amp;#34;guestbook&amp;#34;
destination: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
server: &amp;#34;https://kubernetes.default.svc&amp;#34; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
namespace: &amp;#34;guestbook&amp;#34;
my-second-app:
....&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>This key will become the name of the Application&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The source repository, this is the repository that contains the Helm chart or the Kubernetes manifests&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The destination, that defines the cluster and namespace where the application will be deployed&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Either &lt;strong>server&lt;/strong> or &lt;strong>name&lt;/strong> must be set, but not both.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With the above values multiple applications can be created at once.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_integrating_the_template">Integrating the Template&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The values from the above example can be used to create the Application manifest.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All the developers (or CI/CD pipelines) need to do is to define the values and create one template to include the source template.
This will look like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">{{- if .Values.argocd_applications }}
{{- range $name, $config := .Values.argocd_applications }} &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
{{- if $config.enabled | default false }} &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
---
{{- include &amp;#34;tpl.argocdApplication&amp;#34; (dict &amp;#34;name&amp;#34; $name &amp;#34;spec&amp;#34; $config) -}} &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
{{- end }}
{{- end }}
{{- end }}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Iterate over the applications, defining $name and $config&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Only include the application if it is enabled&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Include the template with the name of the application and the specification&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is everything you need to do to create an Argo CD Application. Let’s take a look at the template.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_key_features_of_the_template">Key Features of the template&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_1_flexible_destination_configuration">1. Flexible Destination Configuration&lt;/h3>
&lt;div class="paragraph">
&lt;p>The template supports both server URL and cluster name destinations with &lt;strong>validation&lt;/strong>:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">destination:
{{- if and ($spec.destination.server) ($spec.destination.name) }}
{{ fail &amp;#34;destination.server and destination.name cannot be set at the same time&amp;#34; }}
{{- else }}
{{- if $spec.destination.server }}
server: {{ $spec.destination.server }}
{{- else if $spec.destination.name }}
name: {{ $spec.destination.name }}
{{- else }}
server: https://kubernetes.default.svc
{{- end }}
{{- end }}
namespace: {{ $spec.destination.namespace | required &amp;#34;destination.namespace is required&amp;#34; }}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_2_comprehensive_sync_policy_support">2. Comprehensive Sync Policy Support&lt;/h3>
&lt;div class="paragraph">
&lt;p>The template handles all Argo CD sync policy features:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Automated sync with prune, selfHeal, and allowEmpty options&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Flexible sync options array&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Retry configuration with backoff strategies&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Conditional managed namespace metadata&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_3_conditional_namespace_management">3. Conditional Namespace Management&lt;/h3>
&lt;div class="paragraph">
&lt;p>The intelligent handling of &lt;code>managedNamespaceMetadata&lt;/code>. The template only includes this section when it &lt;strong>CreateNamespace=&lt;/strong> option is set to true:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">{{- if and $spec.syncPolicy.syncOptions (not (has &amp;#34;CreateNamespace=false&amp;#34; $spec.syncPolicy.syncOptions)) }}
{{- if $spec.syncPolicy.managedNamespaceMetadata }}
managedNamespaceMetadata:
{{- with $spec.syncPolicy.managedNamespaceMetadata.labels }}
labels:
{{- toYaml . | nindent 8 }}
{{- end }}
{{- with $spec.syncPolicy.managedNamespaceMetadata.annotations }}
annotations:
{{- toYaml . | nindent 8 }}
{{- end }}
{{- end }}
{{- end }}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_4_other_features">4. Other Features&lt;/h3>
&lt;div class="paragraph">
&lt;p>I created the template to be as flexible as possible. However, I did not include everything in this template, only the most important features (from my point of view). Currently, the following is possible:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Create a template for an Argo CD Application using Git&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create a template for an Argo CD Application using Helm defining all possible Helm parameters, like additional values files or other options.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Using a &lt;strong>single&lt;/strong> source&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Set required annotations and labels&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_5_not_possible_currently">5. Not possible (currently)&lt;/h3>
&lt;div class="paragraph">
&lt;p>Along with the supported features, there are some features that are currently not possible:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Defining multiple sources&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Configure Kustomize settings&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>However, if you feel this needs to be added, please let me know and create an issue. I can then try to add it.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_why_this_approach_works">Why This Approach Works&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_1_dry_principle">1. DRY Principle&lt;/h3>
&lt;div class="paragraph">
&lt;p>Instead of repeating the same YAML structure across multiple applications, you define it once and reuse it everywhere.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_2_intelligent_defaults">2. Intelligent Defaults&lt;/h3>
&lt;div class="paragraph">
&lt;p>The template provides sensible defaults (like &lt;code>openshift-gitops&lt;/code> namespace) while allowing customization when needed.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_3_validation">3. Validation&lt;/h3>
&lt;div class="paragraph">
&lt;p>Built-in validation ensures required fields are present and conflicting configurations are caught early.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_4_conditional_logic">4. Conditional Logic&lt;/h3>
&lt;div class="paragraph">
&lt;p>The template handles complex scenarios like namespace management automatically, reducing the chance of misconfigurations.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_real_world_benefits">Real-World Benefits&lt;/h3>
&lt;div class="paragraph">
&lt;p>In practice, this template has several advantages:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>Consistency&lt;/strong>: All applications follow the same pattern&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Maintainability&lt;/strong>: Changes to common patterns are made in one place&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Safety&lt;/strong>: Validation prevents common misconfigurations&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Flexibility&lt;/strong>: Supports the full range of Argo CD features&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Development Guidelines&lt;/strong>: Ensure all developers are using the same process&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_real_world_examples">Real-World Examples&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_1_define_a_ui_branding">1. Define a UI Branding&lt;/h3>
&lt;div class="paragraph">
&lt;p>I would like to define a top banner in the OpenShift Console.
Everything is defined in the &lt;code>clusters/management-cluster/branding&lt;/code> folder in my git repository.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All I need to do is to define the following values:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">argocd_applications:
my-branding:
enabled: true
namespace: &amp;#34;openshift-gitops&amp;#34;
source:
repositoryURL: &amp;#34;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#34;
targetRevision: &amp;#34;main&amp;#34;
path: &amp;#34;clusters/management-cluster/branding&amp;#34;
destination:
name: in-cluster
namespace: &amp;#34;default&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_2_define_a_ui_branding_with_custom_helm_value">2. Define a UI Branding with custom Helm value&lt;/h3>
&lt;div class="paragraph">
&lt;p>Like above I would like to define a top banner in the OpenShift Console. This time I want to use a custom Helm value to define the background color of the banner.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">argocd_applications:
my-branding-custom-helm:
enabled: true
namespace: &amp;#34;openshift-gitops&amp;#34;
source:
repositoryURL: &amp;#34;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#34;
targetRevision: &amp;#34;main&amp;#34;
path: &amp;#34;clusters/management-cluster/branding&amp;#34;
helm:
parameters:
- name: generic-cluster-config.console.console_banners.topbanner.backgroundcolor
value: &amp;#39;#FF9843&amp;#39;
destination:
name: in-cluster
namespace: &amp;#34;default&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_3_full_blown_example">3. Full-Blown Example&lt;/h3>
&lt;div class="paragraph">
&lt;p>A full example with all features can be found in my Git repository at: &lt;a href="https://github.com/tjungbauer/helm-charts/blob/main/charts/tpl/values_example_ArgoCD-Application.yaml" target="_blank" rel="noopener">values_example_ArgoCD-Application.yaml&lt;/a>&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_what_about_validation">What about Validation?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Above I mentioned that the template is able to validate the values.
This is true for the most important parts.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For example, try to define the following values:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">[...]
destination:
name: in-cluster
server: &amp;#34;https://kubernetes.default.svc&amp;#34;
namespace: &amp;#34;default&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>name&lt;/strong> and &lt;strong>server&lt;/strong> are not allowed to be set at the same time.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Helm (and Argo CD which is using Helm) will validate the values and fail with an error.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">Error: destination.server and destination.name cannot be set at the same time&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>This Argo CD Application template demonstrates how Helm’s templating capabilities can solve real-world GitOps challenges. By combining conditional logic, validation, and sensible defaults, we create a tool that’s both powerful and easy to use.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The conditional namespace management feature alone saves hours of debugging why Argo CD isn’t behaving as expected with namespace metadata. When you combine this with the DRY benefits and built-in validation, you get a robust foundation for managing Argo CD applications at scale.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Whether you’re managing a few applications or hundreds, this template pattern will help you maintain consistency, reduce errors, and improve your team’s GitOps experience.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Using ApplicationSet with Matrix Generator and define individual Namespaces</title><link>https://blog.stderr.at/gitopscollection/2025-04-17-applicationset-defining-namespaces/</link><pubDate>Thu, 17 Apr 2025 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2025-04-17-applicationset-defining-namespaces/</guid><description>&lt;div class="paragraph">
&lt;p>During my day-to-day business, I am discussing the following setup with many customers: &lt;a href="https://blog.stderr.at/gitopscollection/2024-04-02-configure_app_of_apps/">Configure App-of-Apps&lt;/a>. Here I try to explain how I use an ApplicationSet that watches over a folder in Git and automatically adds a new Argo CD Application whenever a new folder is found. This works great, but there is a catch: The ApplicationSet uses the same Namespace &lt;strong>default&lt;/strong> for all Applications. This is not always desired, especially when you have different teams working on different Applications.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Recently I was asked by the customer if this can be fixed and if it is possible to define different Namespaces for each Application. The answer is yes, and I would like to show you how to do this.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_current_situation">The Current Situation&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Currently, I am (or was) using the following ApplicationSet to watch over a folder in Git. The ApplicationSet uses the Matrix Generator to create a new Argo CD Application for each folder found in the Git repository. It also uses the list operator to define the targetCluster:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> generatormatrix:
# Git: Walking through the specific folder and take whatever is there.
- git:
directories:
- path: clusters/management-cluster/*
repoURL: *repourl
revision: *branch
# List: simply define the targetCluster. The name of the cluster must be known by Argo CD
- list:
elements:
# targetCluster is important, this will define on which cluster it will be rolled out.
# The cluster name must be known in Argo CD
- targetCluster: *mgmtclustername&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will create a new Application for any subfolder found in the &lt;strong>clusters/management-cluster/&lt;/strong> folder any every Application in Argo CD will be configured with the same target namespace: &lt;strong>default&lt;/strong>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Technically, this is not a problem, as I define the exact namespace in the different Helm Charts, but it is not always desired.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
I personally recommend defining the Namespace in the Helm Charts, since especially for the cluster configuration, sometimes there is no clear target Namespace or multiple Namespaces are modified.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_what_did_not_work">What did not work&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The first idea was to use the &lt;strong>Matrix&lt;/strong> generator and define the &lt;strong>targetNamespace&lt;/strong> in list.elements and if the namespace is not defined, use a default one. So similar like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> generatormatrix:
# Git: Walking through the specific folder and take whatever is there.
- git:
directories:
- path: clusters/management-cluster/*
repoURL: *repourl
revision: *branch
# List: simply define the targetCluster. The name of the cluster must be known by Argo CD
- list:
elements:
# targetCluster is important, this will define on which cluster it will be rolled out.
# The cluster name must be known in Argo CD
- targetCluster: *mgmtclustername
path: clusters/management-cluster/cert-manager
targetNamespace: cert-manager
- targetCluster: *mgmtclustername
path: clusters/management-cluster/*
targetNamespace: default&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To make is short: &lt;strong>This does not work&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The matrix operator walks over all folders and creates a cartesian product of the elements. This means, it will create a new Application for each folder and each element in the list. So if you have 10 folders and 2 elements in the list, you will end up with 20 Applications.
This is not what we want. We want to create a new Application for each folder and define the targetNamespace in the Git repository.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The second test was the use of the &lt;strong>Merge&lt;/strong> generator. This did not work as well, as it was not possible to define a default Namespace.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_solution">The Solution&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The solution is to use the &lt;strong>Git FILES&lt;/strong> generator and define the &lt;strong>targetNamespace&lt;/strong> in the Git repository. This is done by creating a file called &lt;strong>config.json&lt;/strong> in each subfolder. The content of the file is simple:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-json" data-lang="json">{
&amp;#34;namespace&amp;#34;: &amp;#34;default&amp;#34;,
&amp;#34;environment&amp;#34;: &amp;#34;in-cluster&amp;#34;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The advantage is that it is possible to define multiple parameters in that file. However, the disadvantage is that this file must be created, otherwise the ApplicationSet will ignore the folder and will not create a new Application.
I think this is a small disadvantage, and the file is easy to maintain.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Bringing everything together now opens two possibilities:&lt;/p>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
This will require &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-argocd">helper-argocd&lt;/a> version 2.0.41 or higher.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_option_1_keep_matrix_generator_and_use_git_file_sub_generator">Option 1: Keep Matrix Generator and use Git File sub-generator&lt;/h3>
&lt;div class="paragraph">
&lt;p>The first option simply replaces the git directory generator with the git file generator. The rest of the ApplicationSet remains unchanged.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
I like this option somehow better than the second one, because I can keep everything as I had it before, the only thing is to create the &lt;strong>config.json&lt;/strong> file in each subfolder and change two lines in the ApplicationSet.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> # Switch to set the namespace to &amp;#39;.namespace&amp;#39; ... must be defined in config.json
use_configured_namespace: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# Definition of Matrix Generator. Only 2 generators are supported at the moment
generatormatrix:
# Git: Walking through the specific folder and take whatever is there.
- git:
files: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- path: clusters/management-cluster/**/config.json &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
repoURL: *repourl
revision: *branch
# List: simply define the targetCluster. The name of the cluster must be known by Argo CD
- list:
elements:
# targetCluster is important, this will define on which cluster it will be rolled out.
# The cluster name must be known in Argo CD
- targetCluster: *mgmtclustername&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Switch to use the configured namespace. This is important, otherwise the namespace is set to &amp;#34;default&amp;#34;. This was added for backward compatibility.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The git file generator is used instead of the git directory generator.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The path is changed to the config.json file. The ** is important, as it defines to look into every subfolder.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The config.json can be shortened to:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-json" data-lang="json">{
&amp;#34;namespace&amp;#34;: &amp;#34;default&amp;#34;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_option_2_switch_to_plain_git_file_generator">Option 2: Switch to plain Git File Generator&lt;/h3>
&lt;div class="paragraph">
&lt;p>The second option is to switch to the plain Git generator. This removes the Matrix generator, but also requires defining the targetCluster in the config.json file. This is not a problem, as the config.json file can be used to define multiple parameters.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> generatorgit: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# Git: Walking through the specific folder and take whatever is there.
- files:
- clusters/management-cluster/**/config.json
repourl: *repourl
revision: *branch&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>No Matrix but Git generator instead.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Here the full config.json file is required, otherwise the targetCluster is not defined:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-json" data-lang="json">{
&amp;#34;namespace&amp;#34;: &amp;#34;default&amp;#34;,
&amp;#34;environment&amp;#34;: &amp;#34;in-cluster&amp;#34;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_full_working_example">Full working example&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Source: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/base/argocd-resources-manager/values.yaml" class="bare">https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/base/argocd-resources-manager/values.yaml&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">applicationsets:
######################################
# MATRIX GENERATOR EXAMPLE Git Files #
######################################
# The idea behind the GIT Generate (File) is to walk over a folder, for example /clusters/management-cluster and fetch a config.json from each folder.
# This is more or less similar as the Matrix generator (see below), but reqires a bit more configuration ... the config.json.
# The advantage is that you can configure individual namespaces for example in this config.json and provide an additional information
mgmt-cluster-matrix-gitfiles:
enabled: true
# Description - always usful
description: &amp;#34;ApplicationSet that Deploys on Management Cluster Configuration (using Git Generator)&amp;#34;
# Any labels you would like to add to the Application. Good to filter it in the Argo CD UI.
labels:
category: configuration
env: mgmt-cluster
# Using go text template. See: https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/GoTemplate/
goTemplate: true
argocd_project: *mgmtclustername
environment: *mgmtclustername
# preserve all resources when the application get deleted. This is useful to keep that workload even if Argo CD is removed or severely changed.
preserveResourcesOnDeletion: true
# Switch to set the namespace to &amp;#39;.namespace&amp;#39; ... must be defined in config.json
use_configured_namespace: true
# Definition of Matrix Generator. Only 2 generators are supported at the moment
generatormatrix:
# Git: Walking through the specific folder and take whatever is there.
- git:
files:
- path: clusters/management-cluster/**/config.json
repoURL: *repourl
revision: *branch
# List: simply define the targetCluster. The name of the cluster must be known by Argo CD
- list:
elements:
# targetCluster is important, this will define on which cluster it will be rolled out.
# The cluster name must be known in Argo CD
- targetCluster: *mgmtclustername
syncPolicy:
autosync_enabled: false
# Retrying in case the sync failed.
retries:
# number of failed sync attempt retries; unlimited number of attempts if less than 0
limit: 5
backoff:
# the amount to back off. Default unit is seconds, but could also be a duration (e.g. &amp;#34;2m&amp;#34;, &amp;#34;1h&amp;#34;)
# Default: 5s
duration: 5s
# a factor to multiply the base duration after each failed retry
# Default: 2
factor: 2
# the maximum amount of time allowed for the backoff strategy
# Default: 3m
maxDuration: 3m&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In this blog post I have shown you how to use the ApplicationSet with the Matrix generator and define individual Namespaces for each Application. This is done by using the Git File generator and defining a config.json file in each subfolder. The config.json file can be used to define multiple parameters, but it is required to create the file in each subfolder.
This is a small disadvantage, but I think it is worth the effort. The advantage is that you can define individual Namespaces for each Application, and you can use the same ApplicationSet for all your Applications.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I hope this blog post was helpful and you learned something new. If you have any questions or comments, please feel free to reach out to me.
I am happy to help you.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Using Kustomize to post render a Helm Chart</title><link>https://blog.stderr.at/gitopscollection/2024-10-13-using-post-renderer/</link><pubDate>Sun, 13 Oct 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-10-13-using-post-renderer/</guid><description>&lt;div class="paragraph">
&lt;p>Lately I came across several issues where a given Helm Chart must be modified after it has been rendered by Argo CD.
Argo CD does a &lt;strong>helm template&lt;/strong> to render a Chart. Sometimes, especially when you work with Subcharts or when a specific setting is not yet supported by the Chart, you need to modify it later …​ you need to post-render the Chart.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In this very short article, I would like to demonstrate this on a real-live example I had to do. I would like to inject annotations to a Route objects, so that the certificate can be injected. This is done by the cert-utils operator.
For the post-rendering the Argo CD repo pod will be extended with a sidecar container, that is watching for the repos and patches them if required.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Everything below is using OpenShift Gitops Operator. This is based on Argo CD, but instead of directly modifying the repo Deployment, we will modify the Argo CD Custom Resource.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
In the future it will be easier to inject certificates into a Route, by defining a Secret. This as currently a TechPreview feature (OpenShift 4.17). &lt;a href="https://docs.openshift.com/container-platform/4.17/networking/routes/secured-routes.html#nw-ingress-route-secret-load-external-cert_secured-routes" target="_blank" rel="noopener">Creating a route with externally managed certificate
&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_route_object">The Route Object&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Imagine we have the following Route object, rendered via Helm template:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: route.openshift.io/v1
kind: Route
metadata:
name: my-route
namespace: my-namespace
spec:
host: my.route.apps.cluster.name
port:
targetPort: http
tls:
insecureEdgeTerminationPolicy: Redirect
termination: edge
to:
kind: Service
name: my-service
weight: 100
wildcardPolicy: None&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The cert-manager Operator requested a certificate which can be found in the Secret &amp;#34;my-certificate &amp;#34;.
To let the cert-utils Operator inject the data from the certificate automatically, we need to add annotations to that Route object.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This injection is usually a good idea, since we do not want to define certificate and (private) key directly in the Route object using our Chart.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: route.openshift.io/v1
kind: Route
metadata:
annotations: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
cert-manager.io/cluster-issuer: my-issuer
cert-utils-operator.redhat-cop.io/certs-from-secret: my-certificate&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Two annotations shall be added to the Route object.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
In this example certificates have to be ordered. No wildcard certificate is available.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_post_rendering">Post-Rendering&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>To modify the output after it has been rendered by Argo CD we will use &lt;strong>Kustomize patch feature&lt;/strong>. This means, after the template has been rendered, we send it to Kustomize and let it patch it.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s go through the steps one-by-one:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Create a kustomization.yaml
Place the following file next to your Chart.yaml&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: my-namespace
resources:
- ./all.yaml &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
patches:
- patch: |
- op: add &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
path: /metadata/annotations
value:
cert-manager.io/cluster-issuer: my-issuer
cert-utils-operator.redhat-cop.io/certs-from-secret: my-certificate
target:
kind: Route
name: my-route &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The all.yaml file will be created by the helm template command.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Add the annotations to the Route object.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The name of the Route object.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will patch the Route object. You can test this locally by execute the command:
&lt;strong>helm template . &amp;gt; all.yaml &amp;amp;&amp;amp; kustomize build &amp;amp;&amp;amp; rm all.yaml&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic" start="2">
&lt;li>
&lt;p>Create an empty file called &lt;strong>my-cmp-plugin&lt;/strong> into the folder next to the Chart.yaml
I will explain in a bit why I chose to use this approach.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create the following ConfigMap in the OpenShift GitOps namespace (for example openshift-gitops)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
name: my-cmp-plugin
namespace: openshift-gitops
data:
plugin.yaml: |-
apiVersion: argoproj.io/v1alpha1
kind: ConfigManagementPlugin
metadata:
name: my-cmp-plugin &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
spec:
version: v1.0
init: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
command: [sh, -c, &amp;#39;echo &amp;#34;Initializing my-plugin-cmp...&amp;#34;&amp;#39;, &amp;#39;helm dependency build || true&amp;#39;]
generate: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
command: [sh, -c, &amp;#34;helm template . --name-template $ARGOCD_APP_NAME --namespace $ARGOCD_APP_NAMESPACE --include-crds &amp;gt; all.yaml &amp;amp;&amp;amp; kustomize build&amp;#34;]
discover: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
find:
glob: &amp;#34;**/my-cmp-plugin&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The name of the plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The init command will be executed once, when the plugin is loaded.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The generate command will be executed every time the plugin is called.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The discovery command will be executed to find the plugin.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will execute the command to generate a helm template, pipe the output into all.yaml and let Kustomize patch the output.
The &amp;#34;discovery&amp;#34; part is looking for a specific file in the repository. I thought this might be useful to pin down this plugin to specific repositories only.
However, there are other ways to implement this. You could omit this part and define the name of the plugin inside the Argo CD Application too for example.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic" start="4">
&lt;li>
&lt;p>Patching Argo CD Repo server&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now it is time to patch our repo server specification of the Argo CD custom resource.
The following should do it:&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
As image for the sidecar container, I am using &lt;a href="https://quay.io/repository/gnunn/tools" target="_blank" rel="noopener">Gerald Nunn’s&lt;/a> tool image. You can use your own image, as long as Helm and Kustomize are available.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: ArgoCD
metadata:
name: openshift-gitops
namespace: openshift-gitops
spec:
[...]
repo:
- configMap: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
name: my-cmp-plugin
name: my-cmp-plugin
sidecarContainers: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- name: my-cmp-plugin
command: [/var/run/argocd/argocd-cmp-server]
env:
- name: APP_ENV
value: prod
image: quay.io/gnunn/tools:latest &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
imagePullPolicy: Always
securityContext:
runAsNonRoot: true
volumeMounts: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- mountPath: /var/run/argocd
name: var-files
- mountPath: /home/argocd/cmp-server/plugins
name: plugins
- mountPath: /tmp
name: tmp
- mountPath: /home/argocd/cmp-server/config/plugin.yaml
subPath: plugin.yaml
name: my-cmp-plugin
volumes: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
- configMap:
name: cloudbees-cmp-plugin
name: cloudbees-cmp-plugin&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The name of the ConfigMap that was created in step 2.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The sidecar container specification.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The image that is used for the sidecar container.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The volume mounts for the sidecar container.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The volumes for the sidecar container.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As soon as the repo Pod has been patched a 2nd container inside the Pod will be started as a sidecar. This will take the ConfigMap that was created in step 2 and mount it. As soon as a repo is found where this patch shall be executed, Argo CD will perform the actions defined in the ConfigMap, resulting in the output of the helm template and the patched output of Kustomize.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
apiVersion: route.openshift.io/v1
kind: Route
metadata:
name: my-route
namespace: my-namespace
annotations: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
cert-manager.io/cluster-issuer: my-issuer
cert-utils-operator.redhat-cop.io/certs-from-secret: my-certificate
spec:
host: my.route.apps.cluster.name
port:
targetPort: http
tls:
insecureEdgeTerminationPolicy: Redirect
termination: edge
to:
kind: Service
name: my-service
weight: 100
wildcardPolicy: None&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The annotations that are added to the Route.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is it; this will patch our resource. Such post-renderer can be used for other patches as well. For example, to remove certain items from an object.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_2nd_example">2nd Example&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In my real-live example I had the problem that the &lt;strong>path&lt;/strong> was empty in the Helm Chart and OpenShift automatically removed that, which was shown as out-of-sync in Argo CD.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>So I am using the patch to remove the path.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
Only do this if you are sure the element is really empty!
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I extended the kustomization.yaml with&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> - op: remove
path: /spec/path&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>so it looks like:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: my-namespace
resources:
- ./all.yaml
patches:
- patch: |
- op: add
path: /metadata/annotations
value:
cert-manager.io/cluster-issuer: my-issuer
cert-utils-operator.redhat-cop.io/certs-from-secret: my-certificate
- op: remove &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
path: /spec/path
target:
kind: Route
name: my-route&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The patch that removes the path.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This 2nd patch will completely remove the /spec/path from the Route object named &lt;em>my-route&lt;/em>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_further_information">Further information:&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Example, which was the base of my patch: &lt;a href="https://github.com/gitops-examples/argocd-operator-customization/tree/main/plugin-sidecar" target="_blank" rel="noopener">Plugin Sidecar&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>G.Nunn’s tools image (Thanks for everything): &lt;a href="https://quay.io/repository/gnunn/tools" class="bare">https://quay.io/repository/gnunn/tools&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Managing Certificates using GitOps approach</title><link>https://blog.stderr.at/gitopscollection/2024-07-04-managing-certificates-with-gitops/</link><pubDate>Thu, 04 Jul 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-07-04-managing-certificates-with-gitops/</guid><description>&lt;div class="paragraph">
&lt;p>The article &lt;a href="https://blog.stderr.at/openshift/2023/02/ssl-certificate-management-for-openshift-on-aws/">SSL Certificate Management for OpenShift on AWS&lt;/a> explains how to use the &lt;strong>Cert-Manager Operator&lt;/strong> to request and install a new SSL Certificate.
This time, I would like to leverage the GitOps approach using the Helm Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/cert-manager" target="_blank" rel="noopener">cert-manager&lt;/a> I have prepared to deploy the Operator and order new Certificates.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I will use an ACME Letsencrypt issuer with a DNS challenge. My domain is hosted at AWS Route 53.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>However, any other integration can be easily used.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_before_we_start">Before we start&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Before we start, be sure that Route 53 is configured correctly. The required settings and commands are described at &lt;a href="https://blog.stderr.at/openshift/2023/02/ssl-certificate-management-for-openshift-on-aws/#_configure_an_aws_user_for_accessing_route_53" target="_blank" rel="noopener">Configure an AWS User for Accessing Route 53&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_deploy_the_operator">Deploy the Operator&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The first step is to deploy the Operator to our cluster. This is done using GitOps and the Helm Chart is located at my Helm repository: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/cert-manager" class="bare">https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/cert-manager&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The configuration looks like below. It takes care to:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Deploy the Operator &lt;strong>cert-manager-operator&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Verify if the Operator has been deployed successfully&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Configure Cert-Manager&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>Create a ClusterIssuer using route53 integration. (You can configure any other configuration too)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Patch the Operator with &amp;#34;overrideArgs&amp;#34;. This is required for AWS Route 53 where we need to define which DNS resolvers shall be used.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All these settings are handed over to the appropriate sub-charts. Like &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">helper-operator&lt;/a>, &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">helper-status-checker&lt;/a> and &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/cert-manager" target="_blank" rel="noopener">cert-manager&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"># Install Operator Compliance Operator
# Deploys Operator --&amp;gt; Subscription and Operatorgroup
# Syncwave: 0
helper-operator: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
operators:
compliance-operator:
enabled: true
syncwave: &amp;#39;0&amp;#39;
namespace:
name: cert-manager-operator
create: true
subscription:
channel: stable-v1
approval: Automatic
operatorName: openshift-cert-manager-operator
source: redhat-operators
sourceNamespace: openshift-marketplace
operatorgroup:
create: true
notownnamespace: false
helper-status-checker: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
enabled: true
checks:
- operatorName: cert-manager-operator
namespace:
name: cert-manager-operator
serviceAccount:
name: &amp;#34;status-checker-cert-manager&amp;#34;
cert-manager: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
certManager:
enable_patch: true
overrideArgs: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- &amp;#39;--dns01-recursive-nameservers-only&amp;#39;
- --dns01-recursive-nameservers=ns-362.awsdns-45.com:53,ns-930.awsdns-52.net:53
issuer: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
- name: letsencrypt-prod
type: ClusterIssuer
enabled: true
syncwave: 20
acme:
email: tjungbau@redhat.com
solvers:
- dns01: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
route53:
accessKeyIDSecretRef:
key: access-key-id
name: prod-route53-credentials-secret
region: us-west-1
secretAccessKeySecretRef:
key: secret-access-key
name: prod-route53-credentials-secret
selector:
dnsZones:
- aws.ispworld.at&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Installing the Operator&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Verify if the Operator has been successfully deployed&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Configure the Cert-Manager Operator&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Override the DNS resolver args&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Configure the ClusterIssuer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Use the solver dns01.route53.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the README of the Helm Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/cert-manager" target="_blank" rel="noopener">cert-manager&lt;/a> for additional possibilities in the configuration.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>One additional piece is missing before we can finally start the deployment.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see in the values file above the &lt;strong>accessKey&lt;/strong> and &lt;strong>secretAccessKey&lt;/strong> are stored in the secret named &lt;em>prod-route53-credentials-secret&lt;/em>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This means, that a secret is required with the keys that have been provided by AWS when you configured the Route 53 access:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">kind: Secret
apiVersion: v1
metadata:
name: prod-route53-credentials-secret
namespace: cert-manager &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
data:
access-key-id: &amp;lt;AccessKey&amp;gt;
secret-access-key: &amp;lt;Secret Access Key&amp;gt;
type: Opaque&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Namespace of the Secret, here the Operator is managing the Certificate Controller.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I stored this Secret as SealedSecret and put it into the &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/cert-manager" target="_blank" rel="noopener">cluster configuration folder&lt;/a>. From here, Argo CD will pick it up and deploy it.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
Never, never ever store a Secret object directly in Git. Secret objects are not encrypted but encoded. Everybody could decode the data. With Sealed Secrets or any other Secret Management, you are able to prepare these objects and store or retrieve them.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Finally, with these settings, the Operator can be deployed. This is managed by OpenShift GitOps (Argo CD). As soon as the Operator is ready, we can start requesting certificates as we automatically created the &lt;strong>ClusterIssuer&lt;/strong> (letsencrypt-prod)&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/cert-manager.png?width=640px" alt="Deploying and Configuring Cert-Manager Operator"/>
&lt;/div>
&lt;div class="title">Figure 1. Deploying and Configuring Cert-Manager Operator&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Two certificates are of special interest :&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Default IngressController of OpenShift&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenShift’s API&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Therefore, let’s request and configure them.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_requesting_a_certificate">Requesting a Certificate&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/cert-manager" target="_blank" rel="noopener">cert-manager&lt;/a> can render a Certificate resource as well. I tried to support any possible setting. However, not everything, especially the non-stable ones, is available yet.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The official Cert-Manager documentation explains how to create such &lt;a href="https://cert-manager.io/docs/usage/certificate/" target="_blank" rel="noopener">Certificate Resource&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The chart &lt;a href="https://github.com/tjungbauer/helm-charts/blob/main/charts/cert-manager/values.yaml#L112-L269" target="_blank" rel="noopener">README&lt;/a> explains which settings are supported by the chart.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Not every setting is required and some will set default values. The minimum parameters are: name, namespace, secretName, dnsNames and reference to an issuer.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_requesting_ingresscontroller_certificate">Requesting IngressController Certificate&lt;/h3>
&lt;div class="paragraph">
&lt;p>The default IngressController of OpenShift listens on the wildcard domain *.apps.clustername.basedomain. In my examples, you will see *.apps.ocp.aws.ispworld.at&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The IngressController configuration must be modified to reference the Secret object the cert-manager will generate once the Certificate has been successfully requested. The cluster configuration &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/ingresscontroller/values.yaml" target="_blank" rel="noopener">Ingresscontroller&lt;/a> defines the required parameters:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
# -- Define ingressControllers
# Multiple might be defined.
ingresscontrollers: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# -- Name of the IngressController. OpenShift initial IngressController is called &amp;#39;default&amp;#39;.
- name: default
# -- Enable the configuration
# @default -- false
enabled: true
# -- Number of replicas for this IngressController
# @default -- 2
replicas: 3
# -- The name of the secret that stores the certificate information for the IngressController
# @default -- N/A
defaultCertificate: router-certificate &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# -- Bind IngressController to specific nodes
# Here as example for Infrastructure nodes.
# @default -- empty
#nodePlacement:
# NodeSelector that shall be used.
# nodeSelector: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
# key: node-role.kubernetes.io/infra
# value: &amp;#39;&amp;#39;
# # -- Tolerations, required if the nodes are tainted.
# tolerations:
# - effect: NoSchedule
# key: node-role.kubernetes.io/infra
# operator: Equal
# value: reserved
# - effect: NoExecute
# key: node-role.kubernetes.io/infra
# operator: Equal
# value: reserved
certificates:
enabled: true
# List of certificates
certificate: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- name: router-certificate
enabled: true
namespace: openshift-ingress
syncwave: &amp;#34;0&amp;#34;
secretName: router-certificate &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
dnsNames: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
- apps.ocp.aws.ispworld.at
- &amp;#39;*.apps.ocp.aws.ispworld.at&amp;#39;
# Reference to the issuer that shall be used.
issuerRef: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
name: letsencrypt-prod
kind: ClusterIssuer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Configuration for the IngressController&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Reference to the Secret that will store the Certificate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Optional tolerations that can be configured for the IngressController&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>List of Certificates to order&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>List of domainnames for the IngressController. Here 2 are used, the wildcard domain and the base domain of that wildcard.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Reference to the issuer (in this case ClusterIssuer)&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will request the Certificate:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
name: router-certificate
namespace: openshift-ingress
spec:
dnsNames:
- apps.ocp.aws.ispworld.at
- &amp;#39;*.apps.ocp.aws.ispworld.at&amp;#39;
duration: 2160h0m0s
issuerRef:
kind: ClusterIssuer
name: letsencrypt-prod
privateKey:
algorithm: RSA
encoding: PKCS1
rotationPolicy: Always
secretName: router-certificate&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
It may take a while until the Certificate request is approved.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The IngressController will update the reference to the secret and restart the ingress pods:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: operator.openshift.io/v1
kind: IngressController
metadata:
name: default
namespace: openshift-ingress-operator
spec:
[...]
defaultCertificate:
name: router-certificate&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Once all pods have been successfully restarted, open a new browser, or reload or open a private window to verify the certificate that is provided by the application.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_requesting_apiserver_certificate">Requesting APIServer Certificate&lt;/h3>
&lt;div class="paragraph">
&lt;p>Requesting the certificate for the OpenShift API follows the same rules as for the IngressController.
The example can be found at: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/clusterconfig-apiserver/values.yaml" target="_blank" rel="noopener">Clusterconfig APIServer&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The values file may look like the following for example:&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
In this case, not only the Certificate is requested but the ETCD encryption is also enabled. The reason for that is, that both settings are done in the same Kubernetes resource (apiserver). If we split this up into 2 Argo CD Applications one of them will always show a warning that the same resource is managed by another Argo CD Application.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">---
# -- Using subchart generic-cluster-config
generic-cluster-config:
apiserver: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
enabled: true
# audit configuration
audit:
profile: Default
# Configure a custom certificate for the API server
custom_cert:
enabled: true
cert_names: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- api.ocp.aws.ispworld.at
secretname: api-certificate &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
etcd_encryption: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
enabled: true
encryption_type: aesgcm &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
# -- Namespace where Job is executed that verifies the status of the encryption
namespace: kube-system
serviceAccount:
create: true
name: &amp;#34;etcd-encryption-checker&amp;#34; &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
cert-manager: &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
enabled: true
certificates:
enabled: true
# List of certificates
certificate:
- name: api-certificate
enabled: true
namespace: openshift-config
syncwave: &amp;#34;0&amp;#34;
secretName: api-certificate
dnsNames:
- api.ocp.aws.ispworld.at
# Reference to the issuer that shall be used.
issuerRef:
name: letsencrypt-prod
kind: ClusterIssuer&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Settings for the APIServer object.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The name of the domain the certificate will be responsible for.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Reference to the Secret that will store the Certificate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Enable ETCD encryption&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Tpee of encryption&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Service Account that will be created and used by a Job that will verify when and if the encryption has been finished successfully.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Settings for the Certificate. Similar to the settings of the IngressController.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The configuration is more or less similar to the IngressController. Again the APIServer will restart and once done, the Certificate is used by the cluster.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With this, very short, article I have tried to easily explain how to deploy the Cert-Manager Operator and request Certificates. Different Helm Charts are used, but the main one is &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/cert-manager" target="_blank" rel="noopener">cert-manager&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The cluster configuration repository &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops" class="bare">https://github.com/tjungbauer/openshift-clusterconfig-gitops&lt;/a> then use this chart to configure the required resources.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With the support of this Helm Chart anybody in the Cluster can request Certificates which are then managed by the Cert-Manager Operator.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Update Cluster Version using GitOps approach</title><link>https://blog.stderr.at/gitopscollection/2024-06-07-update-cluster-version-with-gitops/</link><pubDate>Fri, 07 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-06-07-update-cluster-version-with-gitops/</guid><description>&lt;div class="paragraph">
&lt;p>During a GitOps journey at one point, the question arises, how to update a cluster? Nowadays it is very easy to update a cluster using CLI or WebUI, so why bother with GitOps in that case? The reason is simple: Using GitOps you can be sure that all clusters are updated to the correct, required version and the version of each cluster is also managed in Git.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All you need is the &lt;strong>channel&lt;/strong> you want to use and the desired cluster &lt;strong>version&lt;/strong>. Optionally, you can define the exact image SHA. This might be required when you are operating in a restricted environment.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_overview">Overview&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Since OpenShift 4 it is very easy to update a cluster. It can either be done using the Web UI &lt;strong>Administration → Cluster Settings&lt;/strong> or via the command line using the command &lt;code>oc adm upgrade&lt;/code>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>There are 2 main configurations for an upgrade:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>channel&lt;/strong>: This declares the update strategy tied to versions of OpenShift.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The &lt;strong>desired version&lt;/strong>: This is the target version the cluster should be updated to.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To get the current clusterversion you can use the following command:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">❯ oc get clusterversion
NAME VERSION AVAILABLE PROGRESSING SINCE STATUS
version 4.14.1 True False 4m38s Cluster version is 4.14.1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Here we can see that the version is currently &lt;strong>4.14.1&lt;/strong> and no upgrade is currently progressing.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now we want to update to the latest possible version.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_where_to_find_the_available_updates">Where to find the available updates?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Before you start the update, you will need to fetch the possible available updates.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This information can be gathered with the command &lt;code>oc adm upgrade&lt;/code> or &lt;code>oc get clusterversion/version -o yaml&lt;/code>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The output will look like the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">Cluster version is 4.14.1
Upstream is unset, so the cluster will use an appropriate default.
Channel: stable-4.14 (available channels: candidate-4.14, eus-4.14, fast-4.14, stable-4.14, candidate-4.15, fast-4.15, stable-4.15) &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
Recommended updates: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
VERSION IMAGE
4.14.27 quay.io/openshift-release-dev/ocp-release@sha256:4d30b359aa6600a89ed49ce6a9a5fdab54092bcb821a25480fdfbc47e66af9ec
4.14.26 quay.io/openshift-release-dev/ocp-release@sha256:4fe7d4ccf4d967a309f83118f1a380a656a733d7fcee1dbaf4d51752a6372890
[...]&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Current Channel and available channels&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>List of available updates&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The command describes the current channel (stable-4.14) and a list of possible updates.
(The list is much longer).&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The latest available version is &lt;strong>4.14.27&lt;/strong> and the list of possible channels is all the 4.14 channels, but also 4.15 channels. This means we could change the channel here as well.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
It is your responsibility to find the &lt;strong>correct and supported upgrade paths&lt;/strong>. Not all upgrades to any version are supported. Also, do not rely on consecutive path numbers, some versions were never available.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_channels">Channels&lt;/h3>
&lt;div class="paragraph">
&lt;p>Channels help users to define the timing and level of support for their environment. The following channels typically exist:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>fast&lt;/strong>: This channel is fully supported but not yet fully tested and can be used to quickly update to the latest GA release. For example, when a certain bug is triggered in the current version.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>stable&lt;/strong>: This is the latest stable version. Versions here are added after enough data points have been collected and therefore have some delay.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>candidate&lt;/strong>: This channel offers &lt;strong>unsupported&lt;/strong> early access to specific versions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>eus&lt;/strong>: All even-numbered versions offer an Externed Update Support (EUS) channel. They allow EUS-to-EUS updates and have a longer support phase.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_helm_chart_update_clusterversion">Helm Chart - update-clusterversion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Now we want to update the version to the latest of the current channel &lt;strong>4.14.27&lt;/strong> and change the channel to &lt;strong>stable-4.15&lt;/strong>.
The Helm Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/update-clusterversion" target="_blank" rel="noopener">update-clusterversion&lt;/a> has been created to help with a cluster update.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It will modify the clusterversion resource.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The required values are quite simple:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">channel: stable-4.15
desiredVersion: 4.14.27
image: &amp;#39;&amp;#39;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
Be sure that you choose the correct and available updates.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is everything we need. As soon as this is synchronized into the cluster, the update process will be started by the cluster.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_gitops_synchronization">GitOps Synchronization&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>When we verify the current version in the OpenShift UI, we will see the possibility of an upgrade:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/clusterversion.png?width=720px" alt="Cluster before the update process starts"/>
&lt;/div>
&lt;div class="title">Figure 1. Cluster before the update process starts&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In OpenShift GitOps we have the Application to start the update process:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/clusterversion-sync.png?width=720px" alt="Syncing new version"/>
&lt;/div>
&lt;div class="title">Figure 2. Syncing new version&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>After a few seconds OpenShift will start with the update:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/clusterversion-update-progressing.png?width=720px" alt="Progressing Cluster Update"/>
&lt;/div>
&lt;div class="title">Figure 3. Progressing Cluster Update&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This can also be verified via the command line&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">❯ oc get clusterversion
NAME VERSION AVAILABLE PROGRESSING SINCE STATUS
version 4.14.1 True True 95s Working towards 4.14.27: 116 of 860 done (13% complete), waiting on etcd, kube-apiserver&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Eventually, the cluster update process finishes successfully. We are now on version &lt;strong>4.14.27&lt;/strong> and using the channel &lt;strong>stable-4.15&lt;/strong>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We can see that the next upgrade with be to version 4.15.15. This means we can directly upgrade to this version. This is possible because we switched the channel to stable-4.15.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Other channels, like candidate-4.15 might offer different, but not recommended, versions.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">❯ oc adm upgrade
Cluster version is 4.14.27
Upstream is unset, so the cluster will use an appropriate default.
Channel: stable-4.15 (available channels: candidate-4.14, candidate-4.15, eus-4.14, fast-4.14, fast-4.15, stable-4.14, stable-4.15)
Recommended updates:
VERSION IMAGE
4.15.15 quay.io/openshift-release-dev/ocp-release@sha256:bb1182cd9001d6811dea8c5823235c17b9a316cce3bb13c51325250c14b46787&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_what_about_the_sha_for_the_image">What about the SHA for the image?&lt;/h3>
&lt;div class="paragraph">
&lt;p>The SHA for the image field in the ClusterVersion resource is required in certain scenarios to provide a precise reference to the container image that represents the OpenShift version you want to update to.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Such scenarios could be for example:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Offline or Restricted Networks
In environments where clusters are running in offline or restricted network conditions, specifying the exact image SHA ensures that the cluster updates to a specific, known image that has been pre-pulled and is available within the network.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Precise Version Control
Using the SHA ensures that the exact image version is used for the update, providing a higher level of precision and control.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Custom or Private Registries
If you are using custom or private container registries, specifying the image SHA can help avoid ambiguities and ensure that the correct image is pulled from the correct registry.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Specific Compliance or Security Requirements
Some regulations might require precise specification of container images, including SHAs, to ensure traceability and verifiability of the software components being deployed.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With this very simple method, it is easy to manage the version of multiple clusters via GitOps. Especially, where there is a bigger cluster fleet it will become essential to ensure which cluster has which version.
Disconnected environments can also use the &lt;strong>image&lt;/strong> setting to specify the exact SHA of an available update.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The current Helm Chart is very small and limited. It was created to quickly show the main use case: a simple and straightforward cluster upgrade.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Other possible options that might be required in the future. If you find anything missing, please let me know.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Please note, to always verify which version and channel is available and always consult the official documentation before an upgrade to find the latest release notes.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>References: &lt;a href="https://docs.openshift.com/container-platform/4.15/updating/understanding_updates/intro-to-updates.html" target="_blank" rel="noopener">Updating Clusters&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Multiple Sources for Applications in Argo CD</title><link>https://blog.stderr.at/gitopscollection/2024-06-02-multisources-for-application-in-argocd/</link><pubDate>Sun, 02 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-06-02-multisources-for-application-in-argocd/</guid><description>&lt;div class="paragraph">
&lt;p>Argo CD or OpenShift GitOps uses Applications or ApplicationSets to define the relationship between a source (Git) and a cluster. Typically, this is a 1:1 link, which means one Application is using one source to compare the cluster status. This can be a limitation. For example, if you are working with Helm Charts and a Helm repository, you do not want to re-build (or re-release) the whole chart just because you made a small change in the values file that is packaged into the repository. You want to separate the configuration of the chart with the Helm package.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The most common scenarios for multiple sources are (see: &lt;a href="https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/" target="_blank" rel="noopener">Argo CD documentation&lt;/a>):&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Your organization wants to use an external/public Helm chart&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You want to override the Helm values with your own local values&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You don’t want to clone the Helm chart locally as well because that would lead to duplication and you would need to monitor it manually for upstream changes.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This small article describes three different ways with a working example and tries to cover the advantages and disadvantages of each of them. They might be opinionated but some of them proved to be easier to use and manage.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_option_1_multisource_by_argo_cd">Option 1: Multisource by Argo CD&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
Specifying multiple sources for an application is a &lt;strong>beta feature&lt;/strong>.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The first option I would like to demonstrate is the &amp;#34;official way&amp;#34; by Argo CD. It was introduced in Argo CD version 2.6 and while this option is still in the Beta phase, it is one of the most requested features and was added to the release candidate of version 2.11. The &lt;a href="https://blog.argoproj.io/argo-cd-v2-11-release-candidate-b83ba3008ba5" target="_blank" rel="noopener">article by Argo CD&lt;/a> gives more details of this release. The official documentation by Argo CD can be found &lt;a href="https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/" target="_blank" rel="noopener">here&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In my &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/base/init_app_of_apps/" target="_blank" rel="noopener">repository&lt;/a> I am using this option as an example to create the App-of-Apps. The App-of-Apps created an Application, that uses multiple sources.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>The values files from &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/base/argocd-resources-manager/values.yaml" class="bare">https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/base/argocd-resources-manager/values.yaml&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Helm Chart &lt;strong>helper-argocd&lt;/strong> from &lt;a href="https://charts.stderr.at/" class="bare">https://charts.stderr.at/&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s see the working example:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
name: argocd-resources-manager
namespace: openshift-gitops
spec:
destination:
namespace: openshift-gitops
server: &amp;#39;https://kubernetes.default.svc&amp;#39;
info:
- name: Description
value: &amp;gt;-
This is the starting point which will initialize all applicationsets or
argocd applications
project: default
sources: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
- chart: helper-argocd &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
helm:
valueFiles: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
- $values/base/argocd-resources-manager/values.yaml
repoURL: &amp;#39;https://charts.stderr.at/&amp;#39; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
targetRevision: 2.0.28 &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
- ref: values &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
repoURL: &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39;
targetRevision: main
syncPolicy:
automated:
prune: true
selfHeal: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Using &lt;strong>sources&lt;/strong> instead of singular source&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>I want to use the Helm Chart &lt;strong>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-argocd" target="_blank" rel="noopener">helper-argocd&lt;/a>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The chart will use the values file(s) from github.com/tjungbauer/openshift-clusterconfig-gitops/base/argocd-resources-manager/values.yaml. $value (can only be specified at the beginning of the path) resolves to the root of the values file repository&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The URL of the Helm Chart repository&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The version of the Helm chart helper-argocd&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>The reference to the values file, defining the repository URL and target revision.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Argo CD does not currently support using another Helm chart as a source for value files.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With this option, it is possible to separate the values files from the Helm Chart itself. Whenever I want to change something in the configuration, I simply change the values file without being required to release a new Chart version.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Advantages&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Allows easily to define an Application with multiple sources, using Argo CD features.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>No additional tool (see other options below) is required&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Was added to the release candidate of Argo CD v2.11&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Disadvantages&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Currently a Beta feature and thus is not supported and has some limitations, such as lacking support of CLI and UI.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Does not allow using additional local specifications. At least as far as I know.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Can be complex to configure and manage&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_option_2_wrapper_helm_chart">Option 2: Wrapper Helm Chart&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With this option, which I extensively use, a wrapper Helm Chart is used to define local values files while calling additional (sub) Helm Charts as a dependency. This wrapper could simply define the values files and nothing else (being &lt;a href="https://blog.stderr.at/gitopscollection/2024-04-25-installing-compliance-operator/#_why_empty_helm_charts/" target="_blank" rel="noopener">empty instead&lt;/a>) or even define additional files, such as Sealed Secrets or things that are not provided by the sub-charts.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>An example of an empty chart would be: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/setup-acs" target="_blank" rel="noopener">setup-acs&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An example of a chart that defines additional local files would be: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/generic-clusterconfig" target="_blank" rel="noopener">generic-clusterconfig&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The first one is using sub-charts to build the required specifications:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">dependencies:
- name: rhacs-setup
version: ~1.0.0
repository: https://charts.stderr.at/
- name: helper-operator
version: ~1.0.23
repository: https://charts.stderr.at/
- name: helper-status-checker
version: ~4.0.0
repository: https://charts.stderr.at/
condition: helper-status-checker.enabled&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-acs/values.yaml" target="_blank" rel="noopener">values file&lt;/a> specifies the configuration for these sub-charts.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The second example also uses sub-charts, but additionally defines local files such as a SealedSecret for htpasswd.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see throughout my &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster" target="_blank" rel="noopener">repository&lt;/a> I am using this option almost all the time. It proved to be quite simple, especially if you prefer working with Helm Charts such as I do.
However, you must take care of the settings in the values file. Specifications you would like to be presented in a sub-chart must be put into the correct place.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For example:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Everything underneath&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-operator:
operators:
rhacs-operator:
[...]&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>will be used by the chart &lt;strong>helper-operator&lt;/strong>. While everything underneath:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-status-checker:
enabled: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>will be used by the chart &lt;strong>helper-status-checker&lt;/strong>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Advantages&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Easy to use, at least for myself&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Allows defining additional, local files that are not provided by the sub-charts&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Disadvantages&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>A wrapper Chart must be created, that at least defines: Chart.yaml, templates folder and values.yaml&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The configuration must be done correctly and all settings for a sub-chart must be forwarded to the sub-chart.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_option_3_using_kustomize_with_helm_enabled">Option 3: Using Kustomize with Helm enabled&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The third option I would like to show is using Kustomize. This tool can be used to call a Helm Chart when the option &lt;strong>--enable-helm&lt;/strong> is activated in Argo CD. I am using one example for the &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/ingresscontroller" target="_blank" rel="noopener">IngressController&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Here the values file is placed into the local folder and the Kustomize.yaml is configured as:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
helmCharts:
- name: ingresscontroller
repo: https://charts.stderr.at
valuesFile: values.yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This simply defines the use of the chart &lt;strong>ingresscontroller&lt;/strong> from the Helm repository with the local values file.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Unlike Option #2 you do not need to take care about the settings for sub-charts and which settings are passed to which chart. Like Option #2 you can also define additional files that shall be rendered using out-of-the-box Kustomize possibilities.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Advantages&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Easy to use&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Allows defining additional, local files that are not provided by the sub-charts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>No need to take care of sub-charts and correctly pass the settings to a sub-chart&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Disadvantages&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>combines two different tools, which might become confusing&lt;/p>
&lt;/li>
&lt;li>
&lt;p>requires specific option to be enabled &lt;strong>--enable-helm&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As this short article demonstrates, there are multiple ways to work with multiple sources and therefore to separate the values file from the actual Helm Chart. There might be even more options, but these are the ones I was seeing at customers.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Which one do I use? When you look at my &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops" target="_blank" rel="noopener">repository&lt;/a> you see that I mainly use Option #2. Actually, I completely moved from Option #3 to Option #2 a few months ago, because this proved to be clearer for customers, especially when they are new to Kustomize and Helm. That way, only one tool is used and must be managed. Option #3 proved to be more complex in such a case.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>What about Option #1? While I am using it to showcase this feature it is still in a TechPreview phase. However, I do not think that it will completely replace the other options, because it is more complex to configure.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>However, in the end, it is all about personal preferences. Use the tool that you feel most comfortable with :).&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Installing OpenShift Logging using GitOps</title><link>https://blog.stderr.at/gitopscollection/2024-05-24-install-openshift-logging/</link><pubDate>Fri, 24 May 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-05-24-install-openshift-logging/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;a href="https://docs.openshift.com/container-platform/4.15/observability/logging/logging_release_notes/logging-5-9-release-notes.html" target="_blank" rel="noopener">OpenShift Logging&lt;/a> is one of the more complex things to install and configure on an OpenShift cluster. Not because the service or Operators are so complex to understand, but because of the dependencies logging has. Besides the logging operator itself, the Loki operator is required, the Loki operator requires access to an object storage, that might be configured or is already available.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In this article, I would like to demonstrate the configuration of the full stack using an object storage from OpenShift Data Foundation. This means:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Installing the logging operator into the namespace openshift-logging&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Installing the Loki operator into the namespace openshift-operators-redhat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Creating a new BackingStore and BucketClass&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Generating the Secret for Loki to authenticate against the object storage&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Configuring the LokiStack resource&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Configuring the ClusterLogging resource&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All steps will be done automatically. In case you have S3 storage available, or you are not using OpenShift Data Foundation, the setup will be a bit different. For example, you do not need to create a BackingStore or the Loki authentication Secret.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>OpenShift 4&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Argo CD (OpenShift GitOps) deployed&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenShift Data Foundation (ODF) deployed and ready to provide object storage.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Enough available compute resources to deploy LokiStack. Verify the official &lt;a href="https://docs.openshift.com/container-platform/4.15/observability/logging/log_storage/installing-log-storage.html" target="_blank" rel="noopener">OpenShift Logging documentation&lt;/a> to see which option might need which resources.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
For ODF it would be enough to deploy object storage only, instead of the full storage stack based on Ceph. In this case, the so-called &lt;strong>MultiCloudObjectGateway&lt;/strong> option is used, which creates (virtualizes) object storage on top of an existing StorageClass
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
If ODF object storage based on Noobaa should be used, then it makes sense to think about the data retention process, which will take care of removing old data from the storage. It is recommended to configure this directly on the object storage, because this is much more compute-friendly, then letting OpenShift Logging take care of that. The configuration depends on the object storage vendor. In the case of Noobaa, I have prepared a separate article: &lt;a href="https://blog.stderr.at/openshift/2024/02/openshift-data-foundation-noobaa-bucket-data-retention-lifecycle/">Noobaa Bucket Data Retention Lifecycle&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_introduction">Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The main resources of OpenShift Logging are the three custom resources: &lt;strong>ClusterLogging&lt;/strong>, &lt;strong>ClusterLogForwarder&lt;/strong> and &lt;strong>LokiStack&lt;/strong>. The first two are provided by the OpenShift Logging Operator, the last one is provided by the Loki Operator. ClusterLogForwarder is an optional configuration. It allows us to forward logs to external destinations, such as Splunk, or to forward the OpenShift audit logs to Loki. (They are not stored by default). The LokiStack resource requires an available object storage to be able to start its workloads.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In my case, I would like to configure everything automatically. This means, that I also want to configure the object or S3 storage and create the required authentication secret for Loki without manual intervention. This can be easily done using ODF.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;a href="https://blog.stderr.at/gitopscollection/2024-04-02-configure_app_of_apps/">Configure App-of-Apps&lt;/a> installed an Argo CD Application called &lt;strong>in-cluster-setup-openshift-logging&lt;/strong>:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup-openshift-logging.png?width=720px" alt="Argo CD Application: setup-openshift-logging"/>
&lt;/div>
&lt;div class="title">Figure 1. Argo CD Application: setup-openshift-logging&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This Argo CD Application uses the following path to find the Helm Chart: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-openshift-logging" target="_blank" rel="noopener">setup-openshift-logging&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This Helm chart is a &lt;strong>wrapper chart&lt;/strong> that uses sub-charts as dependencies to install and configure the operator as well as to do some OpenShift Jobs on top, for example, creating the required Secret for LokiStack.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The deployment workflow will go through the sub-charts and look like the following:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/logging-deployment-flow.png" alt="Deployment Workflow"/>
&lt;/div>
&lt;div class="title">Figure 2. Deployment Workflow&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>While this looks quite huge and complex, the idea of the sub-charts is quite simple: Do a small specific task, that can be reused by other charts. For example, the NetworkObservability Operator also required an object storage and Loki. I can easily reuse the sub-charts without repeating the logic behind them.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_installing_openshift_logging_stack">Installing OpenShift Logging Stack&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_analyzing_chart_yaml">Analyzing Chart.yaml&lt;/h3>
&lt;div class="paragraph">
&lt;p>Let’s examine the &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-openshift-logging/Chart.yaml" target="_blank" rel="noopener">Chart.yaml&lt;/a> file to see which dependencies are used:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The file looks like the following. The Chart has a lot of dependencies on sub-charts, that have been created to make specific, small and defined operations re-useable for multiple Charts. A total number of 6 sub-charts are used:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">dependencies:
- name: helper-operator &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
version: ~1.0.18
repository: https://charts.stderr.at/
- name: helper-status-checker &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
version: ~4.0.0
repository: https://charts.stderr.at/
condition: helper-status-checker.enabled
- name: openshift-logging &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
version: ~2.0.0
repository: https://charts.stderr.at/
- name: helper-loki-bucket-secret &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
version: ~1.0.0
repository: https://charts.stderr.at/
condition: helper-loki-bucket-secret.enabled
- name: helper-objectstore &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
version: ~1.0.0
repository: https://charts.stderr.at/
condition: helper-objectstore.enabled
- name: helper-lokistack &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
version: ~1.0.0
repository: https://charts.stderr.at/
condition: helper-lokistack.enabled&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Status Checker&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/openshift-logging" target="_blank" rel="noopener">OpenShift Logging&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-loki-bucket-secret" target="_blank" rel="noopener">Helper Loki Bucket Secret&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-objectstore" target="_blank" rel="noopener">Helper Objectstore&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-lokistack" target="_blank" rel="noopener">Helper Lokistack&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the READMEs of the different Charts for detailed information on how to configure them.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuration_of_the_chart">Configuration of the Chart&lt;/h3>
&lt;div class="paragraph">
&lt;p>To configure OpenShift Logging the &lt;strong>&lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-openshift-logging/values.yaml" target="_blank" rel="noopener">values file&lt;/a>&lt;/strong> of the wrapper Chart must be prepared accordingly.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The important thing here is, that any value that should be bypassed to a sub-chart is defined under the name of the sub-chart. For example, everything under &lt;strong>helper-operator:&lt;/strong> will be sent to the helper-operator Chart and is used there for its configuration.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s walk through the configuration for each sub-chart in the order they are required:&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_installing_the_operator">Installing the Operator&lt;/h3>
&lt;div class="paragraph">
&lt;p>The first thing to do is to deploy the Operators themselves. For OpenShift Logging two Operators are required:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>OpenShift Logging&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Loki&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Loki might be installed already due to a different dependency. Maybe you have deployed the Network Observability Operator previously. In that case, OpenShift Logging is required only.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Helm Chart &lt;strong>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">helper-operator&lt;/a>&lt;/strong> is responsible for deploying the Operators. In the following example, I will deploy both Operators (Logging and Loki) and enable the console plugin for the OpenShift Logging operator:&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The console plugin will only work when the whole stack, this means when Logging itself, has been rolled out.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-operator:
console_plugins: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
enabled: true
plugins: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- logging-view-plugin
operators:
cluster-logging-operator: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
enabled: true &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
syncwave: &amp;#39;0&amp;#39; &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
namespace: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
name: openshift-logging
create: true
subscription: &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
channel: stable
source: redhat-operators
approval: Automatic
operatorName: cluster-logging
sourceNamespace: openshift-marketplace
operatorgroup: &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
create: true
notownnamespace: false
loki-operator: &lt;i class="conum" data-value="9">&lt;/i>&lt;b>(9)&lt;/b>
enabled: true
namespace: &lt;i class="conum" data-value="10">&lt;/i>&lt;b>(10)&lt;/b>
name: openshift-operators-redhat
create: true
subscription: &lt;i class="conum" data-value="11">&lt;/i>&lt;b>(11)&lt;/b>
channel: stable-5.8
approval: Automatic
operatorName: loki-operator
source: redhat-operators
sourceNamespace: openshift-marketplace
operatorgroup: &lt;i class="conum" data-value="12">&lt;/i>&lt;b>(12)&lt;/b>
create: true
notownnamespace: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Activate Console Plugin. This will trigger a Kubernetes Job, that will modify the current list of console plugins and add the new plugin to it.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>List of plugins that should be added by the Job. The name of that plugin must be known. In the case of OpenShift Logging it is called &lt;strong>logging-view-plugin&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Key of the first operator: &lt;strong>cluster-logging-operator&lt;/strong>. Everything below here will define the settings for the Logging Operator.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Is this Operator enabled yes/no.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Syncwave for the Operator deployment. (Subscription and OperatorGroup etc.) This should be early enough for other tasks.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>The Namespace where the Operator shall be deployed and if this namespace shall be created.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Configuration of the Subscription resource. This defines the channel (version) that shall be used and whether the approval of the installPlan shall happen automatically or not.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>Configuration of the OperatorGroup. Typically, you will need one when you create a new Namespace. &lt;em>Notownnamespace&lt;/em> defines whether or not the targetNamespace is configured for this Operator or if the Operator is available in any Namespace.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="9">&lt;/i>&lt;b>9&lt;/b>&lt;/td>
&lt;td>Key of the second Operator: &lt;strong>loki-operator&lt;/strong>. Everything below here will define the settings for the Logging Operator.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="10">&lt;/i>&lt;b>10&lt;/b>&lt;/td>
&lt;td>The Namespace where the Operator shall be deployed, must be &lt;strong>openshift-operators-redhat&lt;/strong> and if this namespace shall be created.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="11">&lt;/i>&lt;b>11&lt;/b>&lt;/td>
&lt;td>Configuration of the Subscription resource. This defines the channel (version) that shall be used and whether the approval of the installPlan shall happen automatically or not.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="12">&lt;/i>&lt;b>12&lt;/b>&lt;/td>
&lt;td>Configuration of the OperatorGroup&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
The &lt;strong>approval&lt;/strong> setting can either be &lt;em>Automatic&lt;/em> or &lt;em>Manual&lt;/em>. If the Operator requires approval to be installed, then this must either be done manually (via WebUI or CLI) or using the &lt;strong>helper-status-checker&lt;/strong> chart which automatically can approve existing installPlans (explained in the next section). This is helpful, to automatically deploy the first version of the Operator without the need for manual intervention.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the README at &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a> to find additional possible configurations. Also, verify the separate article &lt;a href="https://blog.stderr.at/openshift/2023/03/operator-installation-with-argo-cd/">Operator Installation with Argo CD&lt;/a> to understand why I am verifying the status of the Operator installation.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_verifying_the_operator_deployment">Verifying the Operator Deployment&lt;/h3>
&lt;div class="paragraph">
&lt;p>An Operator deployment can take some time and before you continue to configure the operator’s CRDs you must be sure that the installation finished successfully. Otherwise, the synchronization in Argo CD will fail because the CRD is not ready.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>There are mainly two tactics to really verify the status of the Operator:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Simply retry a failed sync in Argo CD. This can be done automatically x-times.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Verify if the Operator installation succeeded by starting a Kubernetes Job that monitors the status.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
(Custom) Health checks in Argo CD proved to be not 100% accurate because sometimes the Operator says it is &amp;#34;Ready&amp;#34; but the CRD still cannot be configured for some seconds. Looking at you Compliance Operator …​.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I chose the second option, simply because I could also add a second Job that approved pending installPlans in case the deployment was set to manual approval.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Helm Chart &lt;strong>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">helper-status-checker&lt;/a>&lt;/strong> has two main purposes:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Start a Kubernetes Job to verify the status of one or multiple Operator installation(s)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Optional: start a Kubernetes Job to approve the installPlan(s)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>An example configuration, that verifies two Operators, looks like the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-status-checker:
enabled: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
approver: false &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# List of checks that shall be performed.
checks:
- operatorName: cluster-logging &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
# -- OPTIONAL: Name of subscription that shall be approved. In some cases the name of the Subscription is different to the name of the operator.
# @default --operatorName
subscriptionName: cluster-logging-operator &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
namespace: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
name: openshift-logging
serviceAccount: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
name: &amp;#34;status-checker-logging&amp;#34;
- operatorName: loki-operator &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
namespace:
name: openshift-operators-redhat
serviceAccount:
name: &amp;#34;status-checker-loki&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Enable the status checker.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Enable the installPlan approver. Only required if the approval strategy for an Operator is set to &lt;em>Manual&lt;/em>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Verify the status of the first Operator &lt;strong>cluster-logging&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Sometimes the name of the Subscription differs from the Operator name. Logging is such a case. To be able to find which Subscription should be verified, the subscriptionName must be defined here.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Namespace for OpenShift Logging&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Name of the ServiceAccount that will be created to verify the status of the logging operator.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Settings for the 2nd operator: Loki. This one is running in a different Namespace and must be verified there.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the README at &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Operator Status Checker&lt;/a> to find additional possible configurations.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>At this stage, the Operators have been deployed and they have been verified if the deployment was finished successfully.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now the real complex part can start…​&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_creating_a_new_backingstore_for_openshift_data_foundation">Creating a new BackingStore for OpenShift Data Foundation&lt;/h3>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If you want to use a different storage solution or you have a bucket already, you can skip this section and simply create the LokiStack Secret manually.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In the case that ODF is used and a BackingStore together with a BucketClass shall be created another sub-chart called &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-objectstore" target="_blank" rel="noopener">Helper ObjectStore&lt;/a> can be used.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It will help you to create a:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>BackingStore&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BucketClass&lt;/p>
&lt;/li>
&lt;li>
&lt;p>StorageClass&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BucketClaim&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This fully automates the creation of the bucket and the required Class when using ODF. As a prerequisite, OpenShift Data Foundation (ODF) must be configured and available of course.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
This is completely optional. If you want to use a different storage solution and have the buckets ready, you can simply create the Secret that Loki requires to authenticate at the storage. In this case, you can ignore this and the next section.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following example will create a BackingStore with the size of 700Gi for our OpenShift Logging. A bucket named &lt;strong>logging-bucket&lt;/strong> is created and can be used to store the logs.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-objectstore:
enabled: true
syncwave: 1 &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
backingstore_name: logging-backingstore &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
backingstore_size: 700Gi &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
limits_cpu: 500m &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
limits_memory: 2Gi
pvPool: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
numOfVolumes: 1
type: pv-pool
baseStorageClass: gp3-csi &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
storageclass_name: logging-bucket-storage-class &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
bucket: &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
enabled: true
name: logging-bucket
namespace: openshift-logging
syncwave: 2
storageclass: logging-bucket-storage-class&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Syncwave to create the BackingStore.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the Backingstore.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Size of the BackingStore. 700Gi is good enough for testing Logging. Keep in mind that data retention should be configured separately for &lt;a href="https://blog.stderr.at/openshift/2024/02/openshift-data-foundation-noobaa-bucket-data-retention-lifecycle/">Noobaa&lt;/a>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Limit for CPU and Memory for the Noobaa (BackingStore) pod. They might need to be adjusted since the original ones are quite small for bigger buckets.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Pool of Persistent Volumes. Currently &lt;strong>pv-pool&lt;/strong> is supported by the chart only.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>The basic storage class that shall be used to virtualize ODF object storage on.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>The name of the StorageClass that will be created and used by the BackingStore.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>The configuration of the Bucket and its namespace and storageClass (defined at &amp;lt;7&amp;gt;)&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Eventually, the BackingClass and the BucketClaim are created and ready.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/logging-objectstore.png?width=720px" alt="Ready BackingStore and bound BucketClaim"/>
&lt;/div>
&lt;div class="title">Figure 3. Ready BackingStore and bound BucketClaim&lt;/div>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_custom_argo_cd_health_check_for_backingstore">Custom Argo CD Health Check for BackingStore&lt;/h4>
&lt;div class="paragraph">
&lt;p>The creation of the BackingStore is a process that will take several minutes. Storage must be prepared, and several services must be started. To let Argo CD wait until the BackingStore is fully operational, instead of blindly continuing with the deployment of Loki and Logging, a custom &lt;strong>Health Check&lt;/strong> in Argo CD might help.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following health check should be placed into the Argo CD resource. Be aware, that there might be others already defined.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The status of the BackingStore resource inside Argo CD will continue &lt;em>progressing&lt;/em> until the status of the resource becomes &lt;em>Ready&lt;/em>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Due to different syncwaves, Argo CD will wait for the Ready-status before it continues deploying Loki and Logging.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> resourceHealthChecks:
- check: |
hs = {}
if obj.status ~= nil then
if obj.status.phase ~= nil then
if obj.status.phase == &amp;#34;Ready&amp;#34; then
hs.status = &amp;#34;Healthy&amp;#34;
hs.message = obj.status.phase
return hs
end
end
end
hs.status = &amp;#34;Progressing&amp;#34;
hs.message = &amp;#34;Waiting for BackinbgStore to complete&amp;#34;
return hs
group: noobaa.io
kind: BackingStore&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_generating_secret_for_lokistack">Generating Secret for LokiStack&lt;/h3>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
If you want to use a different storage solution or you have a bucket already, you can skip this section and simply create the LokiStack Secret manually.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Creating the BackingStore and the BucketClaim will generate a Secret and a ConfigMap inside the target namespace. These hold the information about the connection to the object storage.
Both resources are named as the bucket.
The Secret contains the keys: AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY while the ConfigMap stores the information about the URL, region etc.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>While this is all we need to connect to the object store, Loki itself unfortunately requires a different Secret with a specific format.
Before Loki can be configured, this Secret must be created, containing the keys: access_key_id, access_key_secret, bucketnames, endpoint and region (could be empty)&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To automate the process another Helm Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-loki-bucket-secret" target="_blank" rel="noopener">Helper Loki Bucket Secret&lt;/a> has been created (we have too few charts) that has the only task to wait until the object store has been created, read the ConfigMap and the Secret and create the required Secret for Loki for us. Easy …​&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-loki-bucket-secret:
enabled: true
syncwave: 3
namespace: openshift-logging &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
secretname: logging-loki-s3 &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
bucket:
name: logging-bucket &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Namespace we are working in&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The name of the Secret that shall be created&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The name of the bucket that was created in the previous step to find the source information.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>A Kubernetes Job is created, that will mount the created Secret and ConfigMap, read their values and create the Secret we need. It will simply execute the following command:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">oc create secret generic {{ .secretname }} --from-literal access_key_id=${bucket_user} \
--from-literal access_key_secret=${bucket_secret} \
--from-literal bucketnames=${bucket_name} \
--from-literal endpoint=https://${bucket_host} \
--from-literal region=${bucket_region} \&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
This is completely optional. If you want to use a different storage solution and have the buckets ready, you can simply create the Secret (Sealed or inside a Vault) and put it into the wrapper chart. In this case, you can ignore this section.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuring_the_lokistack">Configuring the LokiStack&lt;/h3>
&lt;div class="paragraph">
&lt;p>Up until now, all we did was the deployment of the Operators, verifying if they were ready, creating the object storage and the Secret that will be required by Loki. At this point, we can configure Loki by creating the resource LokiStack. This will start a lot of Pods (depending on your selected size). Loki itself then takes care to push the logs into the object store and to query them etc.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Believe it or not, but there is another Helm Chart called &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-lokistack" target="_blank" rel="noopener">Helper LokiStack&lt;/a> this will configure the service as we need.
The configuration can become very big and the following example shows the main settings. Please consult the README of the Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-lokistack" target="_blank" rel="noopener">Helper LokiStack&lt;/a> or the values file from our wrapper chart &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-openshift-logging/values.yaml#L234-L395" target="_blank" rel="noopener">setup-openshift-logging&lt;/a>. Especially, the pod placement using tolerations might be interesting, as it must be set per component individually.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-lokistack:
enabled: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
name: logging-loki
namespace: openshift-logging
syncwave: 3
# -- This is for log streams only, not the retention of the object store. Data retention must be configured on the bucket.
global_retention_days: 4
storage: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# -- Size defines one of the supported Loki deployment scale out sizes.
# Can be either:
# - 1x.demo
# - 1x.extra-small (Default)
# - 1x.small
# - 1x.medium
# @default -- 1x.extra-small
size: 1x.extra-small
# Secret for object storage authentication. Name of a secret in the same namespace as the LokiStack custom resource.
secret: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
name: logging-loki-s3
# -- Storage class name defines the storage class for ingester/querier PVCs.
# @default -- gp3-csi
storageclassname: gp3-csi &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
# -- Mode defines the mode in which lokistack-gateway component will be configured.
# Can be either: static (default), dynamic, openshift-logging, openshift-network
# @default -- static
mode: openshift-logging &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
# -- Control pod placement for LokiStack components. You can define a list of tolerations for the following components:
# compactor, distributer, gateway, indexGateway, ingester, querier, queryFrontend, ruler
podPlacements: {}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Basic settings, like Namespace, name of the resource and syncwave.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Size of the LokiStack. Depending on the selected size more or less compute resources will be required. &lt;strong>1x.demo&lt;/strong> is for testing only and is not supported for production workload.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Name of the Secret that was created in the previous step (or manually)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>StorageClass that is required for additional workload. This is NOT the object storage.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Mode for the LokiStack Gateway to store the data. Possible values are static, dynamic, openshift-logging and openshift-network.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_custom_argo_cd_health_check_for_lokistack">Custom Argo CD Health Check for LokiStack&lt;/h4>
&lt;div class="paragraph">
&lt;p>As for the BackingStore resource, the LokiStack resource can take a couple of minutes before it is ready. Moreover, it can easily break when there are not enough computing resources available in the cluster. Therefore, I suggest creating another custom health check for Argo CD, to let it wait until the resource is ready. Only when it is ready, Argo CD will continue with the synchronization. Add the following to the &lt;strong>resourceHealthChecks&lt;/strong> in your Argo CD resource.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> - check: |
hs = {}
if obj.status ~= nil and obj.status.conditions ~= nil then
for i, condition in ipairs(obj.status.conditions) do
if condition.type == &amp;#34;Degraded&amp;#34; and condition.reason == &amp;#34;MissingObjectStorageSecret&amp;#34; then &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
hs.status = &amp;#34;Degraded&amp;#34;
hs.message = &amp;#34;Missing Bucket Secret&amp;#34;
end
if condition.type == &amp;#34;Pending&amp;#34; and condition.reason == &amp;#34;PendingComponents&amp;#34; and condition.status == &amp;#34;True&amp;#34; then &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
hs.status = &amp;#34;Progressing&amp;#34;
hs.message = &amp;#34;Some LokiStack components pending on dependencies&amp;#34;
end
if condition.type == &amp;#34;Ready&amp;#34; and condition.reason == &amp;#34;ReadyComponents&amp;#34; then &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
hs.status = &amp;#34;Healthy&amp;#34;
hs.message = &amp;#34;All components are ready&amp;#34;
end
end
return hs
end
hs.status = &amp;#34;Progressing&amp;#34; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
hs.message = &amp;#34;Waiting for LokiStack to deploy.&amp;#34;
return hs
group: loki.grafana.com
kind: LokiStack&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>In LokiStack resources, if the fields &amp;#39;status.conditions.condition.type&amp;#39; is &amp;#34;Degraded&amp;#34; and &amp;#39;status.conditions.condition.reason&amp;#39; is MissingObjectStoreSecret then set the synchronization in Argo CD to &lt;strong>Degraded&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>In LokiStack resources, if the fields &amp;#39;status.conditions.condition.type&amp;#39; is &amp;#34;Pending&amp;#34; and &amp;#39;status.conditions.condition.reason&amp;#39; is PendingComponents and &amp;#39;status.conditions.condition.status&amp;#39; is True then set the synchronization in Argo CD to &lt;strong>Progressing&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>In LokiStack resources, if the fields &amp;#39;status.conditions.condition.type&amp;#39; is &amp;#34;Ready&amp;#34; and &amp;#39;status.conditions.condition.reason&amp;#39; is ReadyComponents then set the synchronization in Argo CD to &lt;strong>Healthy&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Per default set the status to &lt;strong>Progressing&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuring_clusterlogging">Configuring ClusterLogging&lt;/h3>
&lt;div class="paragraph">
&lt;p>Finally, the time …​ or should I say syncwave …​ has come to actually deploy the Logging components. The Operators are deployed, the object storage has been created and LokiStack is running.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following settings will start the deployment of the ClusterLogging resource. As usual, please read the README of the Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/openshift-logging" target="_blank" rel="noopener">OpenShift Logging&lt;/a> to find additional settings, such as tolerations etc.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">openshift-logging:
loggingConfig:
enabled: true
syncwave: &amp;#39;4&amp;#39; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
logStore: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
type: lokistack
lokistack: logging-loki
visualization: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
type: ocp-console
collection: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
type: vector&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The next syncwave, should be after LokiStack deployment.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Define the logStore (LokiStack) and its type (Loki or Elasticsearch). Please note that Elasticsearch as storage is deprecated and will be removed in the future. In my chart, I already removed the support for Elasticsearch&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Type of virtualisation: should be &lt;strong>ocp-console&lt;/strong> since Kibana and Elasticsearch are deprecated.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Type of collection: should be &lt;strong>vector&lt;/strong> since Fluentd and Elasticsearch are deprecated.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will deploy the ClusterLogging resource and OpenShift Logging is finally deployed. In the WebUI of OpenShift, you should now see at Observe &amp;gt; Logs the log files for the cluster.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/logging-installed.png?width=940px" alt="OpenShift Logging"/>
&lt;/div>
&lt;div class="title">Figure 4. OpenShift Logging&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For individual Pods, a new tab called Aggregated Logs is available too:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/logging-podtab.png?width=940px" alt="Aggregated Logs tab"/>
&lt;/div>
&lt;div class="title">Figure 5. Aggregated Logs tab&lt;/div>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_custom_argo_cd_health_check_for_clusterlogging">Custom Argo CD Health Check for ClusterLogging&lt;/h4>
&lt;div class="paragraph">
&lt;p>One last thing to mention is the 3rd health check for Argo CD I usually configure that provides a proper response in the UI when the Logging stack is in a healthy state. The following will verify if the status is &amp;#34;Ready&amp;#34;:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> - check: |
hs = {}
hs.status = &amp;#34;Progressing&amp;#34;
hs.message = &amp;#34;Progressing ClusterLogging&amp;#34;
if obj.status ~= nil and obj.status.conditions ~= nil then
for i, condition in ipairs(obj.status.conditions) do
if condition.type == &amp;#34;Ready&amp;#34; then
hs.status = &amp;#34;Healthy&amp;#34;
hs.message = &amp;#34;ClusterLogging is ready&amp;#34;
end
end
return hs
end
return hs
group: logging.openshift.io
kind: ClusterLogging&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_tips_and_tricks">Tips and Tricks&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Anchors in yaml files&lt;/strong>: Several parameters in the values file will repeat themselves. For example, the name of the LokiStack resource. Typically, I define this as an anchor on the top of the yaml files and then reference it inside the file. This way I see these anchors at the top and can easily change them there:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For example:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">lokistack: &amp;amp;lokistackname logging-loki
[...]
helper-lokistack:
[...]
name: *lokistackname
openshift-logging:
loggingConfig:
[...]
logStore:
lokistack: *lokistackname&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Object Storage Data Retention&lt;/strong>: The object storage is configured with a size of 700Gi, but without any lifecycle management. For object storage, the lifecycle (or data retention) is done on the bucket itself, not by the service. Please read the article &lt;a href="https://blog.stderr.at/openshift/2024/02/openshift-data-foundation-noobaa-bucket-data-retention-lifecycle/">Noobaa Bucket Data Retention Lifecycle&lt;/a> to find out how to configure the data retention.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>OpenShift Logging with all its dependencies, especially when you also want to use OpenShift Data Foundation and automate the bucket creation, is for sure one of the most complex Argo CD Applications I have created. I wanted to create one Application that completely deploys Logging for me, without manual interference. It will become much easier when you do not need to create the ODF bucket and the Secret for Loki. However, in such a case you define the Bucket somewhere else and must create the Secret manually (and put it into the wrapper Helm Chart for example). So probably the effort just shifts to somewhere else.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I hope this article was somehow understandable. I am always happy for Feedback, GitHub issues or Pull Requests.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>One last thing, OpenShift Logging also supports the &lt;strong>forwarding of logs&lt;/strong>. This is currently not supported by the Helm Chart per se. I would suggest creating such a resource and storing it in the wrapper Chart. Just be sure that the syncwave is after the ClusterLogging deployment and it will install the resource accordingly.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Configure Buckets in MinIO using GitOps</title><link>https://blog.stderr.at/gitopscollection/2024-05-17-configure-minio-buckets/</link><pubDate>Fri, 17 May 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-05-17-configure-minio-buckets/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;a href="https://min.io/" target="_blank" rel="noopener">MinIO&lt;/a> is a simple, S3-compatible object storage, built for high-performance and large-scale environments. It can be installed as an Operator to Openshift. In addition, to a command line tool, it provides a WebUI where all settings can be done, especially creating and configuring new buckets. Currently, this is not possible in a declarative GitOps-friendly way.
Therefore, I created the Helm chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator" target="_blank" rel="noopener">minio configurator&lt;/a>, that will start a Kubernetes Job, which will take care of the configuration.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Honestly, when I say I have created it, the truth is, that it is based on an existing &lt;a href="https://github.com/bitnami/charts/tree/main/bitnami/minio" target="_blank" rel="noopener">MinIO Chart by Bitnami&lt;/a>, that does much more than just set up a bucket. I took out the bucket configuration part, streamlined it a bit and added some new features, which I required.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This article shall explain how to achieve this.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Argo CD (OpenShift GitOps) deployed&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MinIO including a deployed tenant that is waiting for buckets&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_introduction">Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>After MinIO and the Tenant have been deployed, we can &lt;strong>configure and update&lt;/strong> a bucket, users, policies and more. Since I do not want to do this manually, the Helm Chart that will be described here creates a Kubernetes Job that leverages the &lt;strong>mc command line tool&lt;/strong> to execute certain tasks automatically. The chart will take care of:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>creating a lifecycle policy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>creating an access policy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>creating a new user/group. User credentials might be added directly to the values file or, better, are imported as a secret&lt;/p>
&lt;/li>
&lt;li>
&lt;p>attaching policies to a user/group&lt;/p>
&lt;/li>
&lt;li>
&lt;p>creating a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>set a quota for a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>set tags for a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>enable versioning for a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>enable object locking for a bucket (&lt;strong>be aware&lt;/strong> that this can only be enabled during the bucket creation)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>enable bucket replication to a target cluster/bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>execute possible extra commands that are configured in the values file&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To perform all these tasks Bitnami released a container image: &lt;strong>docker.io/bitnami/minio:2024.5.1-debian-12-r0&lt;/strong>
They are updating this image regularly.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Actually, the image can be used to deploy the minio server. At this moment, we are interested in the command line tool only. Bitnami also managing a &lt;em>minio-client&lt;/em> image, that can be tested and used. However, I left the original image, which is working very well.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_values">The Values&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
All settings are explained in more detail at: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator" class="bare">https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
The Job and everything that is required, are executed inside the Tenant namespace. In the following examples, this will be &lt;strong>minio-tenant-namespace&lt;/strong>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_basic_settings">Basic Settings&lt;/h3>
&lt;div class="paragraph">
&lt;p>The basic settings are the following. They will define the namespace of the Tenant, the name of the ServiceAccount, the URL of the tenant, Argo CD Hook settings and the image that shall be used for the deployment.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">name: minio-provisioner &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: minio-tenant-namespace &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
synwave: 5 &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
argoproj: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
hook: Sync
hook_delete_policy: HookSucceeded
image:
url: docker.io/bitnami/minio:2024.5.1-debian-12-r0 &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
# Information of the Minio Cluster
miniocluster: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
url: minio-tenant-api-url
port: 443
skip_tls_verification: true &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
# Specifies whether a ServiceAccount should be created
serviceAccount: &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
create: true
name: &amp;#34;minio-provisioner&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the Kubernetes provisioner Job resource.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Namespace of the MinIO Tenant.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Syncwave of the provisioner Job.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Possible Argo CD hook configuration.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The container image the provisioner Job will use.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>The URL of the minio console. This will be used to set the &amp;#34;alias&amp;#34; for the mc command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Skip verification of TLS for the mc command. This will disable the TLS check for any mc command the Job will execute.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>Information about the ServiceAccount&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_authentication_settings">Authentication Settings&lt;/h3>
&lt;div class="paragraph">
&lt;p>To be able to authenticate against MinIO credentials must be provided. This happens, typically, in the form of a Secret:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">auth:
useCredentialsFiles: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
secretName: minio-provisioner &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Shall a secret mounted as a file be used (preferred)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the Secret&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Secret itself requires specific keys and should look like the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">kind: Secret
apiVersion: v1
metadata:
name: minio-provisioner &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: minio-tenant-namespace &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
data:
root-password: &amp;lt;base64 string&amp;gt; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
root-user: &amp;lt;base64 string&amp;gt; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
type: Opaque&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the Secret as mentioned in the minio-configurator values files&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the Namespace as mentioned in the minio-configurator values files&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Password to access MinIO&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>User to access MinIO&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
The Secret must exist upfront and is not created by the Helm Chart. Either pick it from a Vault or create a Sealed Secret to be able to store it in Git.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The credentials are called &lt;strong>root-&lt;/strong>. Any user that has permission to configure buckets is sufficient here. Still, the keys must be named that way.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_creating_minio_policies">Creating MinIO Policies&lt;/h3>
&lt;div class="paragraph">
&lt;p>MinIO uses Policy-Based Access Control to define which actions can be performed on certain resources by an authenticated user.
A policy can be created by the command &lt;strong>mc admin policy&lt;/strong>. Our Kubernetes Job will take the configuration from the values file and mount the information as a JSON file, that will be imported into MinIO.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following specification shows the example for OpenShift Logging:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">provisioning:
enabled: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
policies:
- name: openshift-logging-access-policy &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
statements:
- resources: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
- &amp;#34;arn:aws:s3:::openshift-logging&amp;#34;
- &amp;#34;arn:aws:s3:::openshift-logging/*&amp;#34;
effect: &amp;#34;Allow&amp;#34; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
actions:
- &amp;#34;s3:*&amp;#34; &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>In general, enable the provisioning or not&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the policy. Multiple can be defined and assigned to a user or group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Define the resources the policy should manage access to.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Define the effect: Allow or Deny (default)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The actions that are allowed. Here: any s3: action&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Multiple policies can be defined in the values file, and it is very important to exactly define the resources, the effect and the actions.
The above configuration will allow the user that has the policy assigned:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>All s3 actions to the bucket openshift-logging and everything inside this bucket (thus two resources)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All actions are defined at: &lt;a href="https://min.io/docs/minio/linux/administration/identity-access-management/policy-based-access-control.html#minio-policy" target="_blank" rel="noopener">MinIO Access Management&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Another example would be the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> policies:
- name: custom-bucket-specific-policy
statements:
- resources:
- &amp;#34;arn:aws:s3:::my-bucket&amp;#34;
actions:
- &amp;#34;s3:GetBucketLocation&amp;#34;
- &amp;#34;s3:ListBucket&amp;#34;
- &amp;#34;s3:ListBucketMultipartUploads&amp;#34;
- resources:
- &amp;#34;arn:aws:s3:::my-bucket/*&amp;#34;
effect: &amp;#34;Allow&amp;#34;
actions:
- &amp;#34;s3:AbortMultipartUpload&amp;#34;
- &amp;#34;s3:DeleteObject&amp;#34;
- &amp;#34;s3:GetObject&amp;#34;
- &amp;#34;s3:ListMultipartUploadParts&amp;#34;
- &amp;#34;s3:PutObject&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This policy defines the actions in a fine granular way:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>To the bucket &lt;strong>my-bucket&lt;/strong> we have three allowed actions (GetBucketLocation, ListBucket and ListBucketMultipartUploads)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>To everything inside the bucket (/*) we can also Delete, Get, Put objects etc.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_creating_a_user">Creating a User&lt;/h3>
&lt;div class="paragraph">
&lt;p>The policy that has been created must be assigned to a user (or a group) to be effective. Such a user requires a username, a password and a list of policies that shall be assigned.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The required information can be added directly to the values file like this:&lt;/p>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
&lt;strong>This is NOT the recommended way!&lt;/strong>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> # users:
# - username: test-username &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# password: test-password &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# disabled: false &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
# policies: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
# - readwrite
# - consoleAdmin
# - diagnostics
# # When set to true, it will replace all policies with the specified.
# # When false, the policies will be added to the existing.
# setPolicies: false
# @default -- []&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Username&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>clear text password&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Shall the user be created or not&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>List of policies that shall be assigned&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As mentioned above: Defining a list of users directly in the values file is &lt;strong>not recommended&lt;/strong> as it would mean that the passwords are stored in clear text.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Instead, a list of Secrets can be defined:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> usersExistingSecrets:
- minio-users&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The defined Secrets require a specific structure and can be encrypted and stored in Git or a Vault.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The data structure is the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
name: minio-users &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
type: Opaque
stringData:
username1: | &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
username=username &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
password=password &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
disabled=false &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
policies=openshift-logging-access-policy,readwrite,consoleAdmin,diagnostics &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
setPolicies=false &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the Secret as referenced in the values file.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>List of users, distinguished by the key &amp;#34;username1&amp;#34;, &amp;#34;username2&amp;#34;, etc.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Username&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Password&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Enabled or disabled&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>List of policies to assign to the user&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Replace or add the policies to an (existing) user.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_built_in_policies">Built-In Policies&lt;/h4>
&lt;div class="paragraph">
&lt;p>MinIO provides several &lt;a href="https://min.io/docs/minio/linux/administration/identity-access-management/policy-based-access-control.html#built-in-policies" target="_blank" rel="noopener">Built-In Policies&lt;/a> that can be attached to a user or group.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following policies will always exist: (Please verify the official documentation for further information)&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>consoleAdmin&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants complete access to all S3 and administrative API operations against all resources on the MinIO deployment.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:*&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:*&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>readonly&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants read-only permissions on any object on the MinIO deployment. The GET action must apply to a specific object without requiring any listing.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:GetBucketLocation&lt;/p>
&lt;/li>
&lt;li>
&lt;p>s3:GetObject&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>readwrite&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants read and write permissions for all buckets and objects on the MinIO server.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:*&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>diagnostics&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants permission to perform diagnostic actions on the MinIO deployment.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>admin:ServerTrace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:Profiling&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:ConsoleLog&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:ServerInfo&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:TopLocksInfo&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:OBDInfo&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:BandwidthMonitor&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:Prometheus&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>writeonly&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants write-only permissions to any namespace (bucket and path to object) the MinIO deployment.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:PutObject&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_provisioning_groups">Provisioning Groups&lt;/h3>
&lt;div class="paragraph">
&lt;p>Users can be combined into groups and instead of assigning policies to individual users, we can assign them to a whole group.
The idea is the same as for users, except, that we define a list of members for that group:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> groups
- name: test-group &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
disabled: false &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
members: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
- username
policies: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- readwrite
# When set to true, it will replace all policies with the specified.
# When false, the policies will be added to the existing.
setPolicies: false &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Enabled or disabled.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>List of users that are members of this group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>List of policies that are assigned to this group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Replace or add the policies to an (existing) user.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configure_the_bucket">Configure the Bucket&lt;/h3>
&lt;div class="paragraph">
&lt;p>Finally, we can configure the bucket itself. A bucket will have a specific configuration, a lifecycle a quota etc.
A list of buckets with different configurations can be defined in the values files.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The only mandatory information is the name of the bucket. It is not required to configure a lifecycle or quota etc.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let us analyse the following example, which tries to cover all possible settings:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> buckets:
- name: mybucket &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
region: my-region &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
versioning: Versioned &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
withLock: false &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
bucketReplication: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
enabled: true
targetClusterUrl: replication-target-cluster
targetClusterPort: 443
targetBucket: replication-target-bucket
replicationSettings: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
- existing-objects
credSecretName: replication-credentials &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
lifecycle:
- id: name-of-lifecycle &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
prefix: test-prefix &lt;i class="conum" data-value="9">&lt;/i>&lt;b>(9)&lt;/b>
disabled: false
expiry: &lt;i class="conum" data-value="10">&lt;/i>&lt;b>(10)&lt;/b>
days: 30 # or date
nonconcurrentDays: 10
- id: name-of-second-lifecycle
disabled: false
expiry:
deleteMarker: true
nonconcurrentDays: 10
quota: &lt;i class="conum" data-value="11">&lt;/i>&lt;b>(11)&lt;/b>
type: set
size: 1024Gib
tags: &lt;i class="conum" data-value="12">&lt;/i>&lt;b>(12)&lt;/b>
key1: value1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the bucket.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Region of the bucket&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Enable versioning (&lt;a href="https://docs.min.io/docs/minio-client-complete-guide.html#ilm" class="bare">https://docs.min.io/docs/minio-client-complete-guide.html#ilm&lt;/a>). Allowed options are: Versioned, Suspended or Unchanged.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Enable object Locking&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Configure bucket replication to a target cluster and a target bucket&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Define the settings for the bucket replication can be: delete, delete-marker or existing-objects: &lt;a href="https://min.io/docs/minio/linux/administration/bucket-replication/enable-server-side-one-way-bucket-replication.html" class="bare">https://min.io/docs/minio/linux/administration/bucket-replication/enable-server-side-one-way-bucket-replication.html&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Name of the Secret that stores the credentials for the replication&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>Define a list of lifecycle policies for the bucket: &lt;a href="https://min.io/docs/minio/linux/administration/object-management/object-lifecycle-management.html" class="bare">https://min.io/docs/minio/linux/administration/object-management/object-lifecycle-management.html&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="9">&lt;/i>&lt;b>9&lt;/b>&lt;/td>
&lt;td>A prefix that can be defined&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="10">&lt;/i>&lt;b>10&lt;/b>&lt;/td>
&lt;td>Define the expiration. This can be defined as &lt;strong>days&lt;/strong> OR as a &lt;strong>date&lt;/strong>, for example &amp;#34;2021-11-11T00:00:00Z&amp;#34;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="11">&lt;/i>&lt;b>11&lt;/b>&lt;/td>
&lt;td>Set a quota for the bucket: &lt;a href="https://docs.min.io/docs/minio-admin-complete-guide.html#bucket" class="bare">https://docs.min.io/docs/minio-admin-complete-guide.html#bucket&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="12">&lt;/i>&lt;b>12&lt;/b>&lt;/td>
&lt;td>Define additional tags for the bucket &lt;a href="https://docs.min.io/docs/minio-client-complete-guide.html#tag" class="bare">https://docs.min.io/docs/minio-client-complete-guide.html#tag&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_replication_secret">Replication Secret&lt;/h4>
&lt;div class="paragraph">
&lt;p>The definition above defines a bucket replication. To authenticate at the target cluster, we need to provide a username and a password. This is stored inside a secret:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
name: replication-user
type: Opaque
stringData:
username: username
password: password&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This defines a whole bunch of settings. Except for the bucket name, none is mandatory.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_example_openshift_logging_bucket">Example OpenShift-Logging Bucket&lt;/h4>
&lt;div class="paragraph">
&lt;p>The following is a more realistic example, for defining a bucket used for OpenShift Logging:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It defines the bucket name, with a lifecycle of 4 days and a quota of 1TB:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> buckets:
- name: openshift-logging
lifecycle:
- id: logging-retention
disabled: false
expiry:
days: 4
quota:
type: set
size: 1024GiB&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_additional_settings">Additional Settings&lt;/h3>
&lt;div class="paragraph">
&lt;p>Finally, there are some additional settings, I would like to mention here. They are completely optional, but might be interesting:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Automatically clean up the provisioning job after it has finished:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> cleanupAfterFinished:
enabled: false
seconds: 600&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Define resources for the provisioning job. For example:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">resources:
requests:
cpu: 2
memory: 512Mi
limits:
cpu: 3
memory: 1024Mi&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Typically, I leave this to &lt;strong>resources: {}&lt;/strong>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Take care of the pod placement and define a nodeSelector and tolerations, for example:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> nodeSelector: {}
tolerations:
- effect: NoSchedule
key: infra
operator: Equal
value: reserved
- effect: NoExecute
key: infra
operator: Equal
value: reserved&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With this Helm chart by Bitnami, with a little modification from my side, it is possible to &lt;strong>create and update&lt;/strong> buckets, policies, users etc. There is no need, to perform any modification manually in the MinIO WebUI.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I am currently using this chart for several bucket configurations, with sometimes more and sometimes fewer settings in the values file. Keep in mind, that many settings, especially for the bucket itself, are completely optional and are not required to create a new bucket. (For example, lifecycle). Please check out the source of the Helm Chart and the values file to get further information: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator" target="_blank" rel="noopener">minio configurator&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you have any feedback or miss something, feel free to create a pull request or an issue :)&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Setup &amp; Configure Advanced Cluster Security using GitOps</title><link>https://blog.stderr.at/gitopscollection/2024-04-28-installing-advanced-cluster-security/</link><pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-04-28-installing-advanced-cluster-security/</guid><description>&lt;div class="paragraph">
&lt;p>Today I want to demonstrate the deployment and configuration of &lt;strong>Advanced Cluster Security&lt;/strong> (ACS) using a GitOps approach. The required operator shall be installed, verified if it is running and then ACS shall be initialized. This initialization contains the deployment of several components:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Central - as UI and as a main component of ACS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SecuredClusters - installs a Scanner, Controller pods etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Console link into OpenShift UI - to directly access the ACS Central UI&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Job to create an initialization bundle to install the Secured Cluster&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Job to configure authentication using OpenShift&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s start …​&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Argo CD (OpenShift GitOps) deployed&lt;/p>
&lt;/li>
&lt;li>
&lt;p>App-Of-Apps deployed&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_introduction">Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The main components of ACS are the two custom resources: &lt;strong>Central&lt;/strong> and &lt;strong>SecuredCluster&lt;/strong>. The recommended way to deploy ACS is to use the Operator (alternatives would be the command line or Helm Chart). When I first came across ACS I thought about how to automate the full deployment. I did not want to install the Operator, then the Central, then manually create a so-called init-bundle, then deploy the Secured Cluster, then find the route that has been used, then find the secret that stores the initial administrator credentials and then, finally, log into ACS and activate OpenShift authentication.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see there are a lot of tasks to do before I can start a customer demo.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>At the same time, I started to dig into GitOps and I thought this would be a good option to create my very first Helm Chart.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Long story short, I have now a Helm Chart (actually three, because I outsourced some of the features into sub-charts) that automatically does all these things above. Once I am synchronizing my Argo CD Application everything will happen automatically.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;a href="https://blog.stderr.at/gitopscollection/2024-04-02-configure_app_of_apps/">Configure App-of-Apps&lt;/a> installed an Argo CD Application called &lt;strong>in-cluster-setup-acs&lt;/strong>:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup-acs.png?width=720px" alt="Argo CD Application: setup-acs"/>
&lt;/div>
&lt;div class="title">Figure 1. Argo CD Application: setup-acs&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This Argo CD Application used the following path to find the Helm Chart: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-acs">setup-acs&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This Helm chart is a wrapper chart that uses sub-charts as dependencies to install and configure the operator as well as to do some OpenShift Jobs on top, for example, creating a ConsoleLink or creating an init-bundle.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Please check out the article &lt;a href="https://blog.stderr.at/gitopscollection/2024-04-25-installing-compliance-operator/#_why_empty_helm_charts">Setup Compliance Operator&lt;/a> on why I am using a wrapper chart.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_installing_advanced_cluster_security">Installing Advanced Cluster Security&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_analysing_chart_yaml">Analysing Chart.yaml&lt;/h3>
&lt;div class="paragraph">
&lt;p>Let’s examine the Chart.yaml file to see which dependencies are used:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The file looks like the following. Three sub-charts are defined as required to deploy and configure the ACS. This is pretty much the same as it was for the &lt;a href="https://blog.stderr.at/gitopscollection/2024-04-25-installing-compliance-operator/#_analysing_chart_yaml">Setup Compliance Operator&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: v2
name: setup-acs
description: Deploys Advanced Cluster Security (ACS) on target cluster. If enabled Central will be deployed too.
version: 1.0.0
dependencies:
- name: rhacs-setup &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
version: ~1.0.0 &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
repository: https://charts.stderr.at/
- name: helper-operator &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
version: ~1.0.23
repository: https://charts.stderr.at/
- name: helper-status-checker &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
version: ~4.0.0
repository: https://charts.stderr.at/
condition: helper-status-checker.enabled &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/rhacs-setup" target="_blank" rel="noopener">RHACS Setup&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Version that will be used. The &amp;#34;~&amp;#34; means that the latest version of 1.0.X will be used.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Status Checker&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Only use this dependency when &amp;#34;enabled&amp;#34; is set&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the READMEs of the different Charts for detailed information on how to configure them.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuration_of_the_chart">Configuration of the Chart&lt;/h3>
&lt;div class="paragraph">
&lt;p>To configure Advanced Cluster Security the &lt;strong>values file&lt;/strong> of the wrapper Chart must be prepared accordingly.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The important thing here is, that any value that should be bypassed to a sub-chart is defined under the name of the sub-chart. For example, everything under &lt;strong>helper-operator:&lt;/strong> will be sent to the helper-operator Chart and is used there for its configuration.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check out the example &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-acs/values.yaml" target="_blank" rel="noopener">values file&lt;/a> I use to configure ACS and the
&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/rhacs-setup" target="_blank" rel="noopener">README&lt;/a> to find further information about the possible settings that can be done.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s check the main example, to quickly start:&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_installing_and_verifying_the_operator">Installing and verifying the Operator&lt;/h3>
&lt;div class="paragraph">
&lt;p>The first thing to do is to deploy the Operator and to verify if the Operator installation finished successfully.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The two Helm Charts &lt;strong>helper-operator&lt;/strong> and &lt;strong>helper-status-checker&lt;/strong> are responsible to do so.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>They are configured as follows:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-operator:
operators:
rhacs-operator: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
enabled: true &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
syncwave: &amp;#39;0&amp;#39; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
namespace:
name: rhacs-operator &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
create: true
subscription:
channel: stable &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
approval: Automatic
operatorName: rhacs-operator
source: redhat-operators
sourceNamespace: openshift-marketplace
operatorgroup: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
create: true
# rhacs does not support to monitor own namespace,
# therefore the spec in the OperatorGroup must be empty
notownnamespace: true
# Subchart helper-status-checker
# checks if ACS operator is ready
helper-status-checker:
enabled: true &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
checks: &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
- operatorName: rhacs-operator &lt;i class="conum" data-value="9">&lt;/i>&lt;b>(9)&lt;/b>
namespace:
name: rhacs-operator &lt;i class="conum" data-value="10">&lt;/i>&lt;b>(10)&lt;/b>
syncwave: 3
serviceAccount:
name: &amp;#34;status-checker-acs&amp;#34; &lt;i class="conum" data-value="11">&lt;/i>&lt;b>(11)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Key that can be freely defined. Theoretically, you can deploy multiple operators at once.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Is this Operator enabled yes/no.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Syncwave for the Operator deployment. (Subscription and OperatorGroup etc.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The Namespace where the Operator shall be deployed and if this namespace shall be created.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Configuration of the Subscription resource.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Configuration of the OperatorGroup&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Enable status checker or not. Default: false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>List of operators to check. Typically, only one is checked, but there could be more.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="9">&lt;/i>&lt;b>9&lt;/b>&lt;/td>
&lt;td>Name of the Operator to check (same as for helper-operator)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="10">&lt;/i>&lt;b>10&lt;/b>&lt;/td>
&lt;td>Namespace where the Operator has been installed (same as for helper-operator)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="11">&lt;/i>&lt;b>11&lt;/b>&lt;/td>
&lt;td>Name of the ServiceAccount that will be created to check the status.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the READMEs at &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a> and &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Operator Status Checker&lt;/a> to find additional possible configurations.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Also verify the separate article &lt;a href="https://blog.stderr.at/openshift/2023-03-20-operator-installation-with-argocd/">Operator Installation with Argo CD&lt;/a> to understand why I am verifying the status of the Operator installation.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuring_advanced_cluster_security">Configuring Advanced Cluster Security&lt;/h3>
&lt;div class="paragraph">
&lt;p>Besides the deployment of the Operator, the configuration of ACS is the most important part here. The ACS Operator provides two custom resources: Central and SecuredCluster. On the Central cluster both CRDs are required. On any other (spoke) cluster, the SecuredCluster resource is enough.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In the following example, I am going to configure both Central and SecuredCluster. Since the values file is quite huge I removed most of the additional comments, to keep this article short and readable.
You can read the example values file or the README at &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/rhacs-setup" target="_blank" rel="noopener">Advanced Cluster Security Chart&lt;/a> to find additional possible configurations. Especially, if you like to add tolerations or set resource limits.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">#########################################
# Settings for Advanced Cluster Security
#########################################
rhacs-setup:
rhacs:
namespace: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
name: stackrox
syncwave: &amp;#39;0&amp;#39;
descr: &amp;#39;Red Hat Advanced Cluster Security&amp;#39;
################
# CENTRAL of ACS
################
# Settings for the Central of ACS
central: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
enabled: true
syncwave: &amp;#39;3&amp;#39;
egress:
connectivityPolicy: Online
###############
# CENTRAL DB
###############
# Settings for Central DB, which is responsible for data persistence.
db: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
# -- Set Central DB resources.requests for a DEMO environment to save resources.
resources:
requests:
cpu: &amp;#39;1&amp;#39;
memory: &amp;#39;1Gi&amp;#39;
# -- If you want this component to only run on specific nodes, you can
# configure tolerations of tainted nodes.
tolerations: {}
# - effect: NoSchedule
# key: infra
# operator: Equal
# value: reserved
# - effect: NoSchedule
# key: infra
# operator: Equal
# value: reserved
###############
# SCANNER
###############
scanner: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
enabled: true
analyzer:
# The following settings are NOT suitable for a production environment
autoscaling:
status: &amp;#34;Disabled&amp;#34;
max: 1
min: 1
# When autoscaling is disabled, the number of replicas will always be
# configured to match this value.
replicas: 1
tolerations: {}
###############
# SCANNER DB
###############
db:
tolerations: {}
#################
# SECURED CLUSTER
#################
secured_cluster: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
enabled: true
syncwave: &amp;#39;4&amp;#39;
clustername: local-cluster
sensor:
tolerations: {}
admissioncontrol:
listenOn:
creates: true
events: true
updates: true
tolerations: {}
# -- Basic settings for ACS authentication
# This configuration is done by a Job, that will configure the OpenShift oauth for ACS.
basic_acs_settings: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
auth_provider: &amp;#39;OpenShift&amp;#39;
auth_provider_type: &amp;#39;openshift&amp;#39;
min_access_role: &amp;#39;None&amp;#39;
syncwave: 5
####################################################
# Additional settings for Central and possible Jobs
####################################################
job_vars: &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
max_attempts: 20
job_init_bundle: &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
enabled: true
syncwave: &amp;#39;3&amp;#39;
consolelink: &lt;i class="conum" data-value="9">&lt;/i>&lt;b>(9)&lt;/b>
enabled: true
syncwave: &amp;#39;3&amp;#39;
location: ApplicationMenu
text: Advanced Cluster Security
section: Observability&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Create the Namespace &lt;strong>stackrox&lt;/strong> and install the ACS resources there.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Enable the Central during Syncwave 3 and set the connectivityPolicy to Online&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The Central DB and its configuration. Here the resource requests are modified to allow a small installation on the DEMO environment. Also, tolerations might be set here, as well a PVCs etc.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Settings for the Scanner and its databases. Again, tolerations might be configurated here, but also, not shown in this example, resource limits and requests and other settings. Since I am configuring for a DEMO environment, I disabled the autoscaler and set the replica to 1.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The SecuredCluster is the 2nd CRD that is provided by ACS Operator. It is installed after the Central (thus a higher Syncwave). The most important setting here is the clustername. In our &amp;#34;local&amp;#34; example, the name is set to &lt;strong>local-cluster&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Some basic settings, that will configure the OpenShift authentication and the minimum role for authenticated users (None)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Some default settings for Jobs that are started by this Helm chart.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>The Job that initializes the creation of the init-bundle&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="9">&lt;/i>&lt;b>9&lt;/b>&lt;/td>
&lt;td>The Job and its configuration to generate a direct link to ACS in the OpenShift UI.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>With this ACS is about to be installed on the cluster. Let’s see what will happen during the synchronization.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_deploying_advanced_cluster_security_acs">Deploying Advanced Cluster Security (ACS)&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Let’s hit the sync button inside OpenShift GitOps. This will start the whole process, walking through the syncwaves and the hooks that have been defined.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/syncing-argocd.png?width=720px" alt="Syncing Argo CD"/>
&lt;/div>
&lt;div class="title">Figure 2. Syncing Argo CD&lt;/div>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Since hooks are used, you must sync the whole Argo CD Application. As you can see inside Argo CD, the hooks are not shown, because they will only appear when their time has come (and will disappear afterward again). This means, that if you perform a selective sync, Argo CD does not know when it should start such a hook and they are never triggered.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Operator installation is now started. At the moment the Operator has the status &lt;strong>Installing&lt;/strong>. Currently, no CRDs (Central or SecuredCluster) are available yet. If we would just let Argo CD continue, it would try to create the Central configuration, based on a CRD which does not yet exist. Thus, the syncing process will fail and therefore the &lt;strong>status-checker&lt;/strong> is going to verify if the installation was truly successful.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/installing-operator.png?width=720px" alt="Operator is installed"/>
&lt;/div>
&lt;div class="title">Figure 3. Operator is installed&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Status Checker is a simple Pod that is triggered by a Kubernetes Job. If waits until the status of the Operator is &lt;strong>Succeeded&lt;/strong>. Until this is the case, Argo CD waits before it continues with the synchronization. (It waits until the hook ends the Job)&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/status-checker.png?width=720px" alt="Status Checker"/>
&lt;/div>
&lt;div class="title">Figure 4. Status Checker&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In the logs file of the Pod, we can see that the Operator is ready.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/status-checker-logs.png?width=720px" alt="Status Checker Logs"/>
&lt;/div>
&lt;div class="title">Figure 5. Status Checker Logs&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>And indeed, the status of the Operator is now &lt;strong>Succeeded&lt;/strong>. Now it is time for Argo CD to continue the synchronization.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/operator-ready.png?width=720px" alt="Operator Ready"/>
&lt;/div>
&lt;div class="title">Figure 6. Operator Ready&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The next step is to create the Central CRD. This will deploy the UI of ACS and the local Scanner. You can also see two other Jobs that have been created by the Helm Charts &lt;strong>create_cluster_link&lt;/strong> and &lt;strong>create_cluster_init_bundle&lt;/strong>. They will finish when the Central becomes ready.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Until the Central becomes ready, these two additional Jobs may show errors. Do not worry, OpenShift will reschedule them.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/installing-central.png?width=720px" alt="Installing Central"/>
&lt;/div>
&lt;div class="title">Figure 7. Installing Central&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>You can also see two other Jobs that have been created by the Helm Charts &lt;strong>create_cluster_link&lt;/strong> and &lt;strong>create_cluster_init_bundle&lt;/strong>. They will finish when the Central becomes ready.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
Until the Central becomes ready, these two additional Jobs may show errors. Do not worry, OpenShift will reschedule them.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/init-job-waits.png?width=720px" alt="Init Job is waiting for Central"/>
&lt;/div>
&lt;div class="title">Figure 8. Init Job is waiting for Central&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Once the Central has been deployed, the second CRD &lt;strong>SecuredCluster&lt;/strong> will be added. This will trigger the installation of the Collectors and other components.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/installing-securedcluster.png?width=720px" alt="Installing Secured Cluster"/>
&lt;/div>
&lt;div class="title">Figure 9. Installing SecuredCluster&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Eventually, all Pods are running at the end. The additional Jobs are completed and ACS is ready to take care of the cluster security.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/acs-all-pods-running.png?width=720px" alt="All Pods running"/>
&lt;/div>
&lt;div class="title">Figure 10. All Pods running&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>We can now use the console link that was created.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/acs-consolelink.png?width=720px" alt="ACS ConsoleLink"/>
&lt;/div>
&lt;div class="title">Figure 11. ACS ConsoleLink&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
If you disabled the creation of the ConsoleLink you would need to find the Route that ACS Operator created. Honestly, I do not know why the Operator does not create such ConsoleLink out of the box.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Since I am lazy I created another Job that automatically configures authentication via OpenShift for ACS. This way, we can simply use our OpenShift credentials to login.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/acs-login.png?width=720px" alt="ACS Login"/>
&lt;/div>
&lt;div class="title">Figure 12. ACS Login&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>And that’s it, we can now use ACS, which was deployed fully automatically.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup_acs/acs.png?width=720px" alt="Advanced Cluster Security"/>
&lt;/div>
&lt;div class="title">Figure 13. Advanced Cluster Security&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As you can see Advanced Cluster Security was completely installed. This included the Operator, the Central, the creation and installation of an init-bundle, the creation of a ConsoleLink, the configuration of the SecuredCluster CRD and the initial configuration of the auth provider inside ACS. You can now start using ACS or add additional clusters.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Speaking of additional clusters: The create-cluster-init-bundle created three certificates: collector-tls, sensor-tls and admission-control-tls. They are required so that the SecuredClusters can communicate with the Central. You could now create a separate init-bundle for each SecuredCluster, which is not really easy to automate, or you simply take these created secrets and put them into your GitOps and re-use them for any other SecuredCluster.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All these steps and configurations seem quite complicated but honestly, it is straightforward. I install any Operator using &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a> and in most cases. I also use &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Operator Status Checker&lt;/a> to find additional possible configurations. Both require simple configuration only, which you would need to know anyway when you create the Subscription object manually. Once done, you can repeat this for any other Operator.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The real magic happens when the Operator is configured at the same time because this is very individual to the Operator.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Setup &amp; Configure Compliance Operator using GitOps</title><link>https://blog.stderr.at/gitopscollection/2024-04-25-installing-compliance-operator/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-04-25-installing-compliance-operator/</guid><description>&lt;div class="paragraph">
&lt;p>In the previous articles, we have discussed the &lt;a href="https://blog.stderr.at/gitopscollection/2023-12-28-gitops-repostructure/">Git repository folder structure&lt;/a> and the configuration of the &lt;a href="gitopscollection/2024-04-02-configure_app_of_apps/">App-Of-Apps&lt;/a>. Now it is time to deploy our first configuration. One of the first things I usually deploy is the &lt;a href="https://docs.openshift.com/container-platform/4.15/security/compliance_operator/co-overview.html" target="_blank" rel="noopener">Compliance Operator&lt;/a>. This Operator is recommended for any cluster and can be deployed without any addition to the Subscription.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In this article, I will describe how it is installed and how the Helm Chart is configured.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Argo CD (OpenShift GitOps) deployed&lt;/p>
&lt;/li>
&lt;li>
&lt;p>App-Of-Apps deployed&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_introduction">Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As a reminder, at &lt;a href="https://blog.stderr.at/gitopscollection/2023-12-28-gitops-repostructure/">Git repository folder structure&lt;/a> I described my preferred folder structure. I would like to deploy the Compliance Operator in the Management Cluster now. All my examples can be found at GitHub repository &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops" target="_blank" rel="noopener">OpenShift Clusterconfig GitOps&lt;/a>. The folder &lt;strong>clusters/management-cluster/setup-compliance-operator&lt;/strong> is the one I am interested in.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Inside this folder, you will find another Helm Chart. The Helm Chart has no local templates, instead, it uses dependencies to call other (sub-) charts. However, the &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-compliance-operator/values.yaml" target="_blank" rel="noopener">values.yaml&lt;/a> is the main part to configure everything.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
In case you want to have any local template, that you do NOT want to integrate into one of the sub-charts, you can easily do so, by storing them in the templates folder.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_why_empty_helm_charts">Why &amp;#34;empty&amp;#34; Helm Charts?&lt;/h3>
&lt;div class="paragraph">
&lt;p>Actually, it would be possible to use the Helm Chart of the Chart repository directly, without creating a separate chart, that does nothing else than using dependency charts.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The reasons why I am using such an &amp;#34;empty&amp;#34; Chart are the following (in no particular order):&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>With that way it is possible to add templates (i.e. SealedSecrets) and modify the values-file without packaging and releasing a new Chart version every time you change a small thing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Multi-Source Option, which allows you to use a Helm Chart from repository A and a values file from repository B is still a TechPreview feature (Argo CD 2.10). I am using this for the App-of-Apps already, but I did not do this for all charts. This feature is on the list for Argo CD version 2.11 to become globally available.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As an alternative, it is also possible to mix Kustomize and Helm. That way you only need a kustomization.yaml file and reference to a Helm Chart. In the folder &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/ingresscontroller" target="_blank" rel="noopener">clusters/management-cluster/ingresscontroller&lt;/a> I have such an example.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_installing_compliance_operator">Installing Compliance Operator&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_analysing_chart_yaml">Analysing Chart.yaml&lt;/h3>
&lt;div class="paragraph">
&lt;p>As any Helm Chart a Chart.yaml file exists, that stores the basic information. The most important ones for now are the dependencies.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The file looks like the following. Three sub-charts are defined as required to deploy and configure the Compliance Operator.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: v2
name: setup-compliance-operator
description: Deploy and configure the Compliance Operator
version: 1.0.1
dependencies:
- name: compliance-operator-full-stack &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
version: ~1.0.0 &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
repository: https://charts.stderr.at/
- name: helper-operator &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
version: ~1.0.21
repository: https://charts.stderr.at/
- name: helper-status-checker &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
version: ~4.0.0
repository: https://charts.stderr.at/
condition: helper-status-checker.enabled &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/compliance-operator-full-stack" target="_blank" rel="noopener">Compliance Operator Full Stack&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Version that will be used. The &amp;#34;~&amp;#34; means that the latest version of 1.0.X will be used.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Dependency: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Status Checker&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Only use this dependency when &amp;#34;enabled&amp;#34; is set&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the READMEs of the different Charts for detailed information on how to configure them.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As you can see three other Helm Charts are used to actually deploy and configure the Operator.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuration_of_the_chart">Configuration of the Chart&lt;/h3>
&lt;div class="paragraph">
&lt;p>To configure the Compliance Operator, the values files must be prepared accordingly.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The important thing here is, that any value that should be bypassed to a sub-chart is defined under the name of the sub-chart. For example, everything under &lt;strong>helper-operator:&lt;/strong> will be sent to the helper-operator Chart and is used there for its configuration.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following is a full example of the values I typically use.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"># Install Operator Compliance Operator
# Deploys Operator --&amp;gt; Subscription and Operatorgroup
helper-operator:
operators:
compliance-operator:
enabled: true
syncwave: &amp;#39;0&amp;#39;
namespace:
name: openshift-compliance
create: true
subscription:
channel: stable
approval: Automatic
operatorName: compliance-operator
source: redhat-operators
sourceNamespace: openshift-marketplace
operatorgroup:
create: true
notownnamespace: true
# Verify if the Operator has been successfully deployed
helper-status-checker:
enabled: true
checks:
- operatorName: compliance-operator
namespace:
name: openshift-compliance
serviceAccount:
name: &amp;#34;status-checker-compliance&amp;#34;
# Setting for the Compliance Operator
compliance-operator-full-stack:
compliance:
namespace:
name: openshift-compliance
syncwave: &amp;#39;0&amp;#39;
descr: &amp;#39;Red Hat Compliance&amp;#39;
scansettingbinding:
enabled: true
syncwave: &amp;#39;3&amp;#39;
profiles:
- name: ocp4-cis-node
kind: Profile # Could be Profile or TailedProfile
- name: ocp4-cis
kind: Profile
scansetting: default&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let us walk through the settings in more detail.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_installing_the_operator">Installing the Operator&lt;/h3>
&lt;div class="paragraph">
&lt;p>The first thing to do is to deploy the Operator. Two resources are relevant to install an Operator:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Subscription&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OperatorGroup&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Both objects should be deployed at the very beginning of Argo CD synchronisation. This is done by setting the Syncwave to 0.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The main settings are the operatorName, the channel (which is the version of the operator) and the approval (which defines if the Operator is updated automatically or manually).&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In addition, a Namespace object is deployed, because this Operator should run in its very own namespace.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will start the Operator installation process.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-operator:
operators:
compliance-operator: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
enabled: true &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
syncwave: &amp;#39;0&amp;#39; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
namespace:
name: openshift-compliance &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
create: true
subscription: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
channel: stable # Version of the Operator
approval: Automatic # Automatic or Manual
operatorName: compliance-operator # Name of the Operator
source: redhat-operators
sourceNamespace: openshift-marketplace
operatorgroup: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
create: true
notownnamespace: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Key that can be freely defined. Theoretically, you can deploy multiple operators at once.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Is this Operator enabled yes/no.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Syncwave for the Operator deployment. (Subscription and OperatorGroup etc.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The Namespace where the Operator shall be deployed and if this namespace shall be created.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Configuration of the Subscription resource.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Configuration of the OperatorGroup&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the README at &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a> to find additional possible configurations.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_verify_the_status_of_the_operator">Verify the Status of the Operator&lt;/h3>
&lt;div class="paragraph">
&lt;p>After Argo CD creates the subscription and operatorgroup resources (and namespace), OpenShift will start the installation of the Operator. This installation will take a while but Argo CD does not see this. All it sees is that the Subscription resource is available and it tries to continue with the configuration of the Operator. Here it will fail because the CRDs are not available yet.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Therefore, I created a mechanism to verify if an Operator is ready or not.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Also verify the separate article &lt;a href="https://blog.stderr.at/openshift/2023-03-20-operator-installation-with-argocd/">Operator Installation with Argo CD&lt;/a> that addresses the problem in more detail.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All it does is to start a small Job inside OpenShift and to verify the status of the Operator installation. If everything is fine, the Job will end successfully and Argo CD will continue with the next syncwave. Argo CD Hook and syncwaves are required here. The Job should be started &lt;em>after&lt;/em> the Subscription/OperatorGroup resources have been created, which means any syncwave after &amp;#34;0&amp;#34;.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following annotations will be used by the Job:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> argocd.argoproj.io/hook: Sync &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
argocd.argoproj.io/hook-delete-policy: HookSucceeded &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
argocd.argoproj.io/sync-wave: {{ .syncwave | default 1 | quote }} &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Hooks are ways to run scripts before, during, and after a Sync operation.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Deletes the OpenShift Job again. The hook resource is deleted after the hook succeeded (e.g. Job/Workflow completed successfully).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Syncwave: can be configured. Must be after helper-operator (default 0) and before the Operator is configured further. Default value is 1.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The configuration for &lt;strong>hepler_status_checker&lt;/strong> will look like the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"># Verify if the Operator has been successfully deployed
helper-status-checker:
enabled: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
checks: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- operatorName: compliance-operator &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
namespace:
name: openshift-compliance &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
serviceAccount:
name: &amp;#34;status-checker-compliance&amp;#34; &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Enable status checker or not. Default: false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>List of operators to check. Typically, only one is checked, but there could be more.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Name of the Operator to check (same as for helper-operator)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Namespace where the Operator has been installed (same as for helper-operator)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Name of the ServiceAccount that will be created to check the status.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the README at &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Operator Status Checker&lt;/a> to find additional possible configurations.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuring_compliance_operator">Configuring Compliance Operator&lt;/h3>
&lt;div class="paragraph">
&lt;p>Finally, the Operator has been deployed and has been verified. Now the time is right to configure the Operator with any configuration we would like. This means, using CRDs to do whatever the Operator offers.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is reflected in the following part of the values file. All these settings are handed over to the sub-chart &lt;strong>compliance-operator-full-stack&lt;/strong>.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Verify the README at &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/compliance-operator-full-stack" target="_blank" rel="noopener">Compliance Operator Chart&lt;/a> to find additional possible configurations. Especially, if you like to do Tailored Profiles.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The compliance operator requires a so-called ScanSettingBinding that uses Profiles which are used to check the cluster compliance once a day. In this case, I am using CIS Benchmarks. There are two profiles:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>ocp4-cis-node: will check the node operating system for missing but suggested configuration.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ocp4-cis: will check the OpenShift cluster for missing but suggested configuration.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"># Setting for the Compliance Operator
compliance-operator-full-stack: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
compliance:
namespace:
name: openshift-compliance &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
syncwave: &amp;#39;0&amp;#39;
descr: &amp;#39;Red Hat Compliance&amp;#39;
scansettingbinding: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
enabled: true
syncwave: &amp;#39;3&amp;#39;
profiles: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- name: ocp4-cis-node
kind: Profile # Could be Profile or TailedProfile
- name: ocp4-cis
kind: Profile
scansetting: default&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Handing everything that comes below to the sub-chart &lt;strong>compliance-operator-full-stack&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Namespace where the configuration should be deployed. The Syncwave at this point could be omitted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The configuration for the ScanSettingBinding. It is enabled (default = false) and has a Syncwave AFTER the helper-status-checker.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The list of profiles that shall be used. These must exist. The Compliance Operator offers several profiles. I usually use these two for full CIS compliance check.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With this configuration, the Compliance Operator will not only be installed but also configured with the same Argo CD Application. All you need to do is to synchronize Argo CD and let the magic happen. After a few minutes, everything should be in sync.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/setup-compliance-operator.png?width=720px" alt="Sync Compliance Operator"/>
&lt;/div>
&lt;div class="title">Figure 1. Sync Compliance Operator&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Inside OpenShift the Operator is configured and starts doing its job:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/configured-compliance-operator.png?width=720px" alt="Configured Compliance Operator"/>
&lt;/div>
&lt;div class="title">Figure 2. Configured Compliance Operator&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This concludes the deployment of the Compliance Operator. For further information about the Operator itself, please read the documentation or articles:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://docs.openshift.com/container-platform/4.15/security/compliance_operator/co-overview.html" target="_blank" rel="noopener">Official Documentation: Compliance Operator&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/compliance/2021/07/compliance-operator/">Blog: Compliance Operator&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Also, be sure to check out the READMEs of the different Charts:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator" target="_blank" rel="noopener">Helper Operator&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker" target="_blank" rel="noopener">Helper Operator Status Checker&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/compliance-operator-full-stack" target="_blank" rel="noopener">Compliance Operator Chart&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-compliance-operator/" target="_blank" rel="noopener">Compliance Operator Setup&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you have any questions or problems, feel free to create a GitHub issue at any time.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Configure App-of-Apps</title><link>https://blog.stderr.at/gitopscollection/2024-04-02-configure_app_of_apps/</link><pubDate>Tue, 02 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-04-02-configure_app_of_apps/</guid><description>&lt;div class="paragraph">
&lt;p>In the article &lt;a href="https://blog.stderr.at/gitopscollection/2024-02-02-setup-argocd/">Install GitOps to the cluster&lt;/a> OpenShift GitOps is deployed using a shell script. This should be the very first installation and the only deployment that is done manually on a cluster. This procedure automatically installs the so-called &lt;strong>App-of-Apps&lt;/strong> named &lt;strong>Argo CD Resources Manager&lt;/strong> which is responsible for all further Argo CD Applications and ApplicationSets. No other configuration should be done manually if possible.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This article will demonstrate how to configure the App-of-Apps in an easy and declarative way, using ApplicationSet mainly.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>At this stage, the OpenShift cluster with the openshift-gitops operator and the App-of-Apps must be deployed. Your Argo CD should look somehow like this:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/initial-applications.png?width=1024px" alt="Initial Applications"/>
&lt;/div>
&lt;div class="title">Figure 1. Argo CD: Initial Applications&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>But how do all these Applications end up in Argo CD and how can you add additional ones?&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_understanding_the_argo_cd_resources_manager">Understanding the Argo CD Resources Manager&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
For any further references, I am using the GitHub repository &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/" target="_blank" rel="noopener">OpenShift Clusterconfig GitOps&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;strong>Argo CD Resources Manager&lt;/strong> is, in fact, the App-of-Apps. Its configuration file can be found in the directory &lt;strong>base/argocd-resources-manager&lt;/strong>. It is simply a values file and uses the Helm Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-argocd" target="_blank" rel="noopener">helper-argocd&lt;/a> to create additional Applications or ApplicationSets for Argo CD.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_analyzing_the_example_values_file">Analyzing the example values file&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The example values file seems to be huge and confusing at first look. But it is quite easy to understand …​ trust me :)&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let’s walk through the file bit by bit:&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_defining_header_variables">Defining Header Variables&lt;/h3>
&lt;div class="paragraph">
&lt;p>At the top of the file, some variables are defined as so-called anchors. These definitions might be used multiple times and are defined at the top to allow us to find and change them easily.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I define here the clusters and the information about the GitHub repository for example:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">mgmt-cluster: &amp;amp;mgmtcluster https://kubernetes.default.svc &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
mgmt-cluster-name: &amp;amp;mgmtclustername in-cluster &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
production-cluster: &amp;amp;prodcluster https://api.ocp.aws.ispworld.at:6443
production-cluster-name: &amp;amp;prodclustername prod
repourl: &amp;amp;repourl &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
repobranch: &amp;amp;branch main &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Define the API URL for the cluster as configured in Argo CD. (The local cluster where Argo CD is running might be called kubernetes.default.svc)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Define the short name of the cluster as configured in Argo CD. (The local cluster where Argo CD is running might be called in-cluster)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Define the URL to the GitHub repository that is used in this file.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Define the git branch that will be used.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Any additional anchor can be used to define values, that should show up at the very top and/or are used multiple times and you do not want to write them each time.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Whenever you see a value defined as &lt;strong>*repourl&lt;/strong> for example, such an anchor is used.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_understanding_naming_conventions">Understanding Naming Conventions&lt;/h3>
&lt;div class="paragraph">
&lt;p>Each Application or ApplicationSet must have a unique name inside Argo CD. Whenever Applications are generated by ApplicationSet a prefix with the name of the cluster is usually added.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In the values file multiple Applications or ApplicationSets can be defined. They are all bypassed to the Helm Chart which takes care of everything. The name that will be used for an ApplicationSet for example will be the (yaml) &lt;strong>key&lt;/strong> of the definition.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For example, ApplicationSets are defined as:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">applicationsets:
mgmt-cluster:
...
enable-etcd-encryption:
...&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The &lt;strong>keys&lt;/strong>, for example, mgmt-cluster or enable-etcd-encryption are used as names of the ApplicationSets. This way you do not need to take care of unique names, as YAML will already complain if some kwy is used twice.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_enabledisable">Enable/Disable&lt;/h3>
&lt;div class="paragraph">
&lt;p>Like with all of my Helm Charts, I added a switch to enable (or disable) a certain configuration. This way, you can easily remove Applications without actually deleting the specification.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The default value is &lt;strong>false&lt;/strong>, so you actively need to set it to &lt;code>true&lt;/code>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> mgmt-cluster:
# Is the ApplicationSet enabled or not
enabled: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_supported_generators">Supported Generators&lt;/h3>
&lt;div class="paragraph">
&lt;p>The helm chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-argocd" target="_blank" rel="noopener">helper-argocd&lt;/a> supports the following generators currently:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Matrix Generator&lt;/p>
&lt;/li>
&lt;li>
&lt;p>List Generator&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Git Generator (for files)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cluster Generator&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Additional generators might be added in the future (ping me or create a pull request), but I found these the most useful ones.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>But what is the difference between these generators from the configuration point of view? The different generators require different configurations and therefore provide different placeholders for variables. While the Git generator might use variables that are defined in a file that it finds {{environment}} the List (or Cluster) generator is using {{url}} to define the target cluster.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This might make the specification of an ApplicationSet quite complex …​ and that’s the whole reason for creating the &lt;strong>helper-argocd&lt;/strong>&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_example_applicationset_matrix_generator">Example ApplicationSet - Matrix Generator&lt;/h3>
&lt;div class="paragraph">
&lt;p>The first ApplicationSet I would like to show is probably the most important one. As described in &lt;a href="https://blog.stderr.at/gitopscollection/2023-12-28-gitops-repostructure/">GitOps Repository Structure&lt;/a> I am using a folder structure like &lt;strong>clusters/management-cluster/&lt;/strong> and in this folder I am defining any configuration that is applicable for that specific cluster. If I want to add a new cluster, I simply create a new folder (and a new App-of-Apps configuration). With this, you will always see which settings a specific cluster has without much hassle.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The idea is to walk over this folder and automatically create a new Argo CD Application for any sub-folder that is found. This has the advantage, that whenever I want to create an additional configuration for a cluster, I simply add another sub-folder and the ApplicationSet will automatically create a new Argo CD application.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To achieve this the so-called &lt;strong>Matrix Generator&lt;/strong> is used. This generator combines two (currently two are possible only) generators. In our case, it combines:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>git generator: to walk over the folder and get and sub-folder&lt;/p>
&lt;/li>
&lt;li>
&lt;p>list generator: to define the target cluster&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The snippet of the configuration will look like the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> # Definition of Matrix Generator. Only 2 generators are supported at the moment
generatormatrix: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# Git: Walking through the specific folder and take whatever is there.
- git: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
directories:
- path: clusters/management-cluster/*
- path: clusters/management-cluster/waves
exclude: true
repoURL: *repourl
revision: *branch
# List: simply define the targetCluster. The name of the cluster must be known by Argo CD
- list: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
elements:
# targetCluster is important, this will define on which cluster it will be rolled out.
# The cluster name must be known in Argo CD
- targetCluster: *mgmtclustername&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Using matrix generator&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The first generator is Git: It will observe any changes in the folder &lt;strong>clusters/management-cluster&lt;/strong> and will create a new Argo CD Application if a new sub-folder is found. However, it excludes the folder &lt;strong>clusters/management-cluster/waves/&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The second generator is List: It simply defines the target cluster where the Application that is created by the ApplicationSet shall be deployed.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Now let us bring the whole example together:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> mgmt-cluster: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# Is the ApplicationSet enabled or not
enabled: true &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# Description - always useful
description: &amp;#34;ApplicationSet that Deploys on Management Cluster Configuration (using Matrix Generator)&amp;#34; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
# Any labels you would like to add to the Application. Good to filter it in the Argo CD UI.
labels: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
category: configuration
env: mgmt-cluster
# Using go text template. See: https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/GoTemplate/
goTemplate: true &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
argocd_project: *mgmtclustername &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
# preserve all resources when the application get deleted. This is useful to keep that workload even if Argo CD is removed or severely changed.
preserveResourcesOnDeletion: true &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
# Definition of Matrix Generator. Only 2 generators are supported at the moment
generatormatrix: &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
# Git: Walking through the specific folder and take whatever is there.
- git:
directories:
- path: clusters/management-cluster/*
- path: clusters/management-cluster/waves
exclude: true
repoURL: *repourl
revision: *branch
# List: simply define the targetCluster. The name of the cluster must be known by Argo CD
- list:
elements:
# targetCluster is important, this will define on which cluster it will be rolled out.
# The cluster name must be known in Argo CD
- targetCluster: *mgmtclustername
syncPolicy: &lt;i class="conum" data-value="9">&lt;/i>&lt;b>(9)&lt;/b>
autosync_enabled: false&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Key of the ApplicationSet inside the yaml specification, that will be used as object name&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Is the ApplicationSet enabled or not (Default: false)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>A useful description&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Labels that can be used to filter&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Enable the usage of Go Template for this ApplicationSet&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>The Argo CD project (not OpenShift project) the ApplicationSet belongs to&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Be sure that resources are not deleted when deleting the ApplicationSet. I found this quite useful …​ otherwise, all Applications the ApplicationSet created will be removed INCLUDING the resources they have created.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>The specification of the matrix generator&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="9">&lt;/i>&lt;b>9&lt;/b>&lt;/td>
&lt;td>Any kind of syncPolicy …​ in this case automatic synchronization of the Applications that are created is disabled.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Based on these settings the &lt;strong>helper-argocd&lt;/strong> helm chart will render an ApplicationSet object automatically. As mentioned above it will be called &lt;strong>mgmt-cluster&lt;/strong> and creates an Application for any sub-folder it finds in clusters/management-cluster.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Any new folder that is added will automatically create a new Application. You do not need to configure anything else.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The full objects will look like this:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
name: mgmt-cluster &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: openshift-gitops
labels:
app.kubernetes.io/instance: argocd-resources-manager
app.kubernetes.io/managed-by: Helm
app.kubernetes.io/name: helper-argocd
category: configuration
env: mgmt-cluster
helm.sh/chart: helper-argocd-2.0.28
spec:
generators: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- matrix:
generators:
- git:
directories:
- path: clusters/management-cluster/*
- exclude: true
path: clusters/management-cluster/waves
repoURL: &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39;
revision: main
- list:
elements:
- targetCluster: in-cluster
goTemplate: true
goTemplateOptions:
- missingkey=error
syncPolicy:
preserveResourcesOnDeletion: true
template:
metadata:
name: &amp;#39;{{ .targetCluster }}-{{ .path.basenameNormalized }}&amp;#39; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
spec:
destination: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
name: &amp;#39;{{ .targetCluster }}&amp;#39;
namespace: default
info:
- name: Description
value: ApplicationSet that Deploys on Management Cluster Configuration (using Matrix Generator)
project: in-cluster
source: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
path: &amp;#39;{{ .path.path }}&amp;#39;
repoURL: &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39;
targetRevision: main&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the object == name of the key in the values file definition&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Configuration of the matrix generator&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Name of the Applications that this ApplicationSet will generate. In this case, it will concat the name of the target cluster and the name of the path.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Target cluster&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Definition of the source for the Application&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_example_applicationset_git_generator">Example ApplicationSet - Git Generator&lt;/h3>
&lt;div class="paragraph">
&lt;p>Now let us take a look at a second example using the git generator. The basic idea is quite similar and just a few minor changes must be made to our configuration.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In the following object, a git &lt;strong>file&lt;/strong> generator is used to observe a specific folder and look for the file named values.yaml. For each file that it found an Application is created.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
This example is also explained in my article at &lt;a href="https://www.redhat.com/en/blog/project-onboarding-using-gitops-and-helm?channel=/en/blog/channel/hybrid-cloud-infrastructure" target="_blank" rel="noopener">Project onboarding using GitOps and Helm&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> # Tenant Onboarding (using Git Generator)
onboarding-tenant-workload: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# Is the ApplicationSet enabled or not
enabled: true
# Description - always useful
description: &amp;#34;Onboarding Workload to the cluster&amp;#34;
# Any labels you would like to add to the Application. Good to filter it in the Argo CD UI.
labels:
catagory: tenant-onboarding
# Path to the Git repository. The default URL and revision are defined as anchors at the beginning of the file, but could be overwritten here.
path: clusters/all/project-onboarding &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
repourl: *repourl
targetrevision: *branch
# Using go text template. See: https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/GoTemplate/
goTemplate: true
# Helm configuration. A list of helm values files
helm: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
per_cluster_helm_values: false
value_files:
- &amp;#39;/{{ .path.path }}/values.yaml&amp;#39;
- /tenants/values-global.yaml
# Generator: currently list, git and cluster are possible.
# either &amp;#34;generatorlist&amp;#34;, &amp;#34;generatorgit&amp;#34; or &amp;#34;generatorclusters&amp;#34;
# Define the repository that shall be checked for configuration file
generatorgit: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- repourl: *repourl
targetrevision: *branch
files:
- tenants/**/values.yaml &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
# preserve all resources when the application gets deleted. This is useful to keep that workload even if Argo CD is removed or severely changed.
preserveResourcesOnDeletion: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the ApplicationSet&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The repo URL and path which shall be read for the ApplicationSet&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>A list of values files, that shall be used.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The specification of the Git generator&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The path that shall be observed by this ApplicationSet. ** will return all files and directories recursively.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Again, the Helm chart &lt;strong>helper-argocd&lt;/strong> will render an ApplicationSet for us.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
name: onboarding-tenant-workload
namespace: openshift-gitops
labels:
app.kubernetes.io/instance: argocd-resources-manager
app.kubernetes.io/managed-by: Helm
app.kubernetes.io/name: helper-argocd
catagory: tenant-onboarding
helm.sh/chart: helper-argocd-2.0.28
spec:
generators:
- git:
files:
- path: tenants/**/values.yaml
repoURL: &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39;
revision: main
goTemplate: true
goTemplateOptions:
- missingkey=error
syncPolicy:
preserveResourcesOnDeletion: true
template:
metadata:
name: &amp;#39;{{ index .path.segments 1 | normalize }}-{{ .path.basename }}&amp;#39;
spec:
destination:
name: &amp;#39;{{ .environment }}&amp;#39;
namespace: default
info:
- name: Description
value: Onboarding Workload to the cluster
project: default
source:
helm:
valueFiles:
- &amp;#39;/{{ .path.path }}/values.yaml&amp;#39;
- /tenants/values-global.yaml
path: clusters/all/project-onboarding
repoURL: &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39;
targetRevision: main&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_example_applicationset_list_generator">Example ApplicationSet - List Generator&lt;/h3>
&lt;div class="paragraph">
&lt;p>At this point, we have seen two examples of ApplicationSets defined for &lt;strong>helper-argocd&lt;/strong>. The List generator will be very easy to understand as it simply uses a list of target clusters to render the ApplicationSet.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following snippet demonstrates that all you need to set are the &lt;strong>clustername&lt;/strong> and &lt;strong>clusterurl&lt;/strong>.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Please also verify the article &lt;a href="https://www.redhat.com/en/blog/argo-cd-and-release-management-with-helm-charts-and-applicationsets?channel=/en/blog/channel/hybrid-cloud-infrastructure" target="_blank" rel="noopener">Argo CD and Release Management with Helm Charts and ApplicationSets&lt;/a> to understand the usage of the setting &lt;strong>chart_version&lt;/strong>.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> # List of clusters
# &amp;#34;clustername&amp;#34; (string): Is the name of the cluster a defined in Argo CD
# &amp;#34;clusterurl&amp;#34; (string): Is the URL of the cluster API
# &amp;#34;chart_version&amp;#34; (string, optional): Defines which chart version shall be deployed on each cluster.
generatorlist:
- clustername: *mgmtclustername
clusterurl: *mgmtcluster&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is all the magic. The rendered ApplicationSet will look like:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
name: install-sonarqube
namespace: openshift-gitops
labels:
app.kubernetes.io/instance: argocd-resources-manager
app.kubernetes.io/managed-by: Helm
app.kubernetes.io/name: helper-argocd
category: project
helm.sh/chart: helper-argocd-2.0.28
spec:
generators:
- list:
elements:
- cluster: in-cluster
url: &amp;#39;https://kubernetes.default.svc&amp;#39;
template:
metadata:
name: &amp;#39;{{ cluster }}-install-sonarqube&amp;#39;
spec:
destination:
namespace: sonarqube
server: &amp;#39;{{ url }}&amp;#39;
info:
- name: Description
value: Install Sonarqube
project: &amp;#39;{{ cluster }}&amp;#39;
source:
chart: sonarqube
helm:
releaseName: sonarqube
repoURL: &amp;#39;https://charts.stderr.at/&amp;#39;
targetRevision: 1.0.1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The list generator can be used to deploy on &lt;strong>ALL&lt;/strong> clusters too. Simply define &lt;strong>generatorlist: []&lt;/strong>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The example above also demonstrates how to use a Helm chart instead of a git repository.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_what_about_applications">What about Applications?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The examples above show the usage of ApplicationSet and recently I migrated any specification of an Application to ApplicationSets as I believe this is easier to use, especially when the Chart is rendering it for you.
However, it is still possible to define Applications as well.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following example defines such an Application. The configuration differs compared to the ApplicationSet, however, the main idea stays the same:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">applications: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
node-labelling: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
enabled: true
description: &amp;#34;Deploy Node Labels&amp;#34;
labels:
category: configuration
namespace:
name: default
create: false
server: *mgmtcluster &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
project: default
syncOptions: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- name: ServerSideApply
value: true
- name: Validate
value: false
source: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
path: clusters/management-cluster/node-labels
helm:
valuesfiles:
- name: values.yaml
repourl: *repourl
targetrevision: *branch&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Defining Applications&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the Application. Be sure that it is unique since this time no prefix will be added&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The target cluster for this Application&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Different options for the synchronization&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The specification of the source. This contains the path, URL and branch of the repository and (in this case) the definition of a Helm values file.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_summary">Summary&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>I hope I was able to explain the usage of my chart &lt;strong>helper-argocd&lt;/strong> and how I configure it. You can also verify the &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-argocd" target="_blank" rel="noopener">README&lt;/a> to find additional possible settings and the example &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/base/argocd-resources-manager/values.yaml" target="_blank" rel="noopener">values.file&lt;/a> that I use for all my clusters when I to a demo.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Setup OpenShift GitOps/Argo CD</title><link>https://blog.stderr.at/gitopscollection/2024-02-02-setup-argocd/</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-02-02-setup-argocd/</guid><description>&lt;div class="paragraph">
&lt;p>„&lt;em>If it is not in GitOps, it does not exist&lt;/em>“ - is a mantra I hear quite often and also try to practice at customer engagements. The idea is to have Git as the only source of truth on what happens inside the environment. That said, &lt;a href="https://openpracticelibrary.com/practice/everything-as-code/">Everything as Code&lt;/a> is a practice that treats every aspect of the system as a code. Storing this code in Git provides a shared understanding, traceability and repeatability of changes.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>While there are many articles about how to get GitOps into the deployment process of applications, this one rather sets the focus on the &lt;strong>cluster configuration&lt;/strong> and tasks system administrators usually have to do.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Also check out the article &lt;a href="https://blog.stderr.at/openshift/2020-08-06-argocd/">GitOps Argo CD&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>It all begins with an OpenShift cluster. Such a cluster must be installed and while we will not discuss a bootstrap of the whole cluster … yes, it is possible to even automate the cluster deployment using Advanced Cluster Management as an example, we will simply assume that one cluster is up and running.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For our setup, an OpenShift cluster 4.14 is deployed and we will use the repository &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops">OpenShift Cluster Configuration using GitOps&lt;/a> to deploy our configuration onto this cluster. This repository shall act as the source of truth for any configuration. In the article &lt;a href="http://blog.stderr.at/gitopscollection/2023-12-28-gitops-repostructure/">Choosing the right Git repository structure&lt;/a> I have explained the folder structure I am usually using. As tool I am usually using Helm Charts.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The &lt;strong>openshift-clusterconfig-gitops&lt;/strong> repository heavily uses the Helm Repository found at &lt;a href="https://charts.stderr.at/" class="bare">https://charts.stderr.at/&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_deploy_openshift_gitops">Deploy OpenShift-GitOps&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The first thing we need to do is to deploy &lt;a href="https://docs.openshift.com/gitops/1.11/understanding_openshift_gitops/what-is-gitops.html" target="_blank" rel="noopener">OpenShift-GitOps&lt;/a>, which is based on the &lt;a href="https://argo-cd.readthedocs.io/en/stable/" target="_blank" rel="noopener">Argo CD&lt;/a> project. OpenShift-GitOps comes as an Operator and is available to all OpenShift customers. The Operator will deploy and configure Argo CD and provide several custom resources to configure Argo CD &lt;strong>Applications&lt;/strong> or &lt;strong>ApplicationSets&lt;/strong> for example.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To automate the operator deployment the following shell script can be used: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/init_GitOps.sh" target="_blank" rel="noopener">init_GitOps.sh&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
This Shell script is the only script that is executed manually. It installs and configures Argo CD. Any other operation on the cluster must then be done using GitOps processes. I am using this to quickly install a new Demo-cluster. There are alternatives and maybe better way, but for my purpose it works pretty well.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Clone the repository to your local machine&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/tjungbauer/openshift-clusterconfig-gitops.git&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Be sure that you are logged in the the required cluster&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc whoami --show-server&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Execute the init_GitOps.sh&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">./init_GitOps.sh&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The script will deploy the operator and configure/patch the Argo CD instance. In addition, it will create the so-called &lt;strong>Application of Applications&lt;/strong>, which acts as an umbrella Application, that automatically creates all other Argo CD Application(Sets).
For now, the App of Apps is the only Argo CD Application that automatically synchronizes all changes found in Git. This is for security, purposes so you can test the cluster configuration one after another.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Of course, it is up to you if you want to use the shell script. The Operator can also be installed manually, using Advanced Cluster Manager, or using Platform Operators and installing the Operating during the cluster installation (However, this feature is currently (v4.15) TechPreview)
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_what_will_this_script_do">What will this script do?&lt;/h3>
&lt;div class="paragraph">
&lt;p>I will not de-assemble the script line by line, but in general, the following will happen:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Adding repository &lt;a href="https://charts.stderr.at/" class="bare">https://charts.stderr.at/&lt;/a> and install the Chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/openshift-gitops">openshift-gitops&lt;/a>&lt;/p>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
This FIRST OpenShift-GitOps will be deployed with &lt;strong>cluster-admin&lt;/strong> privileges since we want to manage the whole cluster configuration. This Argo CD instance should not be used for application deployment. For that, deploy additional instances of GitOps.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Waiting for Deployments to become ready&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deploy the &lt;strong>Application of Applications&lt;/strong> that is responsible for automatically deploying a set of Applications or ApplicationSets (see &lt;a href="#The Argo CD Object Manager Application">[The Argo CD Object Manager Application]&lt;/a>)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following shows the output of the command:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;div class="expand">
&lt;div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
&lt;i style="font-size:x-small;" class="fas fa-chevron-right">&lt;/i>
&lt;span>
&lt;a>Expand me...&lt;/a>
&lt;/span>
&lt;/div>
&lt;div class="expand-content" style="display: none;">
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>❯ ./init_GitOps.sh
Starting Deployment
Deploying OpenShift GitOps Operator
Adding Helm Repo https://charts.stderr.at/
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /Users/tjungbau/openshift-aws/aws/auth/kubeconfig
&amp;#34;tjungbauer&amp;#34; has been added to your repositories
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /Users/tjungbau/openshift-aws/aws/auth/kubeconfig
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the &amp;#34;sealed-secrets&amp;#34; chart repository
...Successfully got an update from the &amp;#34;tjungbauer&amp;#34; chart repository
...Successfully got an update from the &amp;#34;apache-airflow&amp;#34; chart repository
...Successfully got an update from the &amp;#34;hashicorp&amp;#34; chart repository
...Successfully got an update from the &amp;#34;bitnami&amp;#34; chart repository
Update Complete. ⎈Happy Helming!⎈
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /Users/tjungbau/openshift-aws/aws/auth/kubeconfig
Release &amp;#34;openshift-gitops-operator&amp;#34; has been upgraded. Happy Helming!
NAME: openshift-gitops-operator
LAST DEPLOYED: Mon Sep 26 13:22:33 2022
NAMESPACE: openshift-operators
STATUS: deployed
REVISION: 2
TEST SUITE: None
Give the gitops-operator some time to be installed. Waiting for 45 seconds...
Waiting for operator to start. Chcking every 10 seconds.
NAME READY UP-TO-DATE AVAILABLE AGE
gitops-operator-controller-manager 1/1 1 1 4d4h
Waiting for openshift-gitops namespace to be created. Checking every 10 seconds.
NAME STATUS AGE
openshift-gitops Active 4d4h
Waiting for deployments to start. Checking every 10 seconds.
NAME READY UP-TO-DATE AVAILABLE AGE
cluster 1/1 1 1 4d4h
Waiting for all pods to be created
Waiting for deployment cluster
deployment &amp;#34;cluster&amp;#34; successfully rolled out
Waiting for deployment kam
deployment &amp;#34;kam&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-applicationset-controller
deployment &amp;#34;openshift-gitops-applicationset-controller&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-redis
deployment &amp;#34;openshift-gitops-redis&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-repo-server
deployment &amp;#34;openshift-gitops-repo-server&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-server
deployment &amp;#34;openshift-gitops-server&amp;#34; successfully rolled out
GitOps Operator ready
Lets use our patched Argo CD CRD
argocd.argoproj.io/openshift-gitops unchanged
clusterrolebinding.rbac.authorization.k8s.io/cluster-admin-0 unchanged
Waiting for deployment cluster
deployment &amp;#34;cluster&amp;#34; successfully rolled out
Waiting for deployment kam
deployment &amp;#34;kam&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-applicationset-controller
deployment &amp;#34;openshift-gitops-applicationset-controller&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-redis
deployment &amp;#34;openshift-gitops-redis&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-repo-server
deployment &amp;#34;openshift-gitops-repo-server&amp;#34; successfully rolled out
Waiting for deployment openshift-gitops-server
deployment &amp;#34;openshift-gitops-server&amp;#34; successfully rolled out
GitOps Operator ready... again
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /Users/tjungbau/openshift-aws/aws/auth/kubeconfig
Release &amp;#34;app-of-apps&amp;#34; has been upgraded. Happy Helming!
NAME: app-of-apps
LAST DEPLOYED: Mon Sep 26 13:23:59 2022
NAMESPACE: openshift-gitops
STATUS: deployed
REVISION: 2
TEST SUITE: None&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_logging_into_argo_cd">Logging into Argo CD&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>At this point, we have GitOps and the &amp;#34;&lt;strong>App of Apps&lt;/strong>&amp;#34; deployed.
Argo CD comes with a WebUI and a command line tool. The latter must installed to your local environment. In this article, we will use the WebUI.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To access the WebUI use the applications menu of the top right corner in Openshift.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-link.png?width=340px" alt="WebUI Link"/>
&lt;/div>
&lt;div class="title">Figure 1. Argo CD: WebUI Link&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Use the button &amp;#34;Login via OpenShift&amp;#34;.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-login.png?width=340px" alt="Authentication"/>
&lt;/div>
&lt;div class="title">Figure 2. Argo CD: Authentication&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_argo_cd_resources_manager_application">The Argo CD Resources Manager Application&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The &lt;strong>Application of Applications&lt;/strong> (short App of Apps) is called &lt;strong>Argo CD Resources Manager&lt;/strong> and it is the only Argo CD application that is deployed using the init script. This single Argo CD Application has the sole purpose of deploying other Argo CD objects, such as Applications, ApplicationSets and AppProjects.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-app-of-apps.png?width=340px" alt="App of Apps"/>
&lt;/div>
&lt;div class="title">Figure 3. Argo CD: App of Apps&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It synchronizes everything that is found in the repository in the path:
&lt;em>base/argocd-resources-manager&lt;/em> (main branch)&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Whenever you would like to create a new Argo CD application(set) it is supposed to be done using this App-of-Apps or to be more exact: in the path mentioned above.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The App-of-Apps is the only Argo CD Application (at this moment) that has automatic synchronization enabled. Thus any changes in the App-of-Apps will be propagated automatically as soon as GitOps syncs with Git.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The current Applications or ApplicationSets that come with the bootstrap repository are for example:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Deployment of Advanced Cluster Security (RHACS)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deployment of Advanced Cluster Management (RHACM)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deployment of basic cluster configuration (i.e. etcd encryption, some UI tweaks …​)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deployment of Compliance Operator&lt;/p>
&lt;/li>
&lt;li>
&lt;p>and many more.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Check out the deployed Argo CD objects or the openshift-clusterconfig-gitops repository.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>A deep dive into the argocd-resources-manager will be topic of a different episode of this serie.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>GitOps - Choosing the right Git repository structure</title><link>https://blog.stderr.at/gitopscollection/2023-12-28-gitops-repostructure/</link><pubDate>Thu, 28 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2023-12-28-gitops-repostructure/</guid><description>&lt;div class="paragraph">
&lt;p>One of the most popular questions asked before adopting the GitOps approach is how to deploy an application to different environments (Test, Dev, Production, etc.) in a safe and repeatable way.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Each organisation has different requirements, and the choice will depend on a multitude of factors that also include non-technical aspects.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Therefore, it is important to state: &amp;#34;&lt;strong>There is no unique “right” way, there are common practices&lt;/strong>&amp;#34;.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
In this series, I will focus on cluster configuration.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_git_repository_strategy_options">Git Repository Strategy - Options&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>As written in the introduction: There is no unique “right” way, there are common practices. But how shall the Git repository structure look like? How shall the folder structure look like? Multiple options might be considered. Each has advantages and disadvantages, some I would recommend, some I would not recommend.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It is important to understand that:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>The Git repository structure will depend heavily on how the organisation is laid out.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The final repo and directory structure is unique for every organisation, as such the right one will be a discovery process within the organisation and the teams involved in the GitOps engineering process.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Before I describe what I usually try to leverage, let’s see the different options.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_environment_per_branch">Environment-per-branch&lt;/h3>
&lt;div class="paragraph">
&lt;p>In this case, there is a Git branch for each environment. A “Dev” branch holds the configuration for the DEV environments, a “production” branch for production and so on. This approach is very popular and will be familiar to people who have adopted git flow in the past. However, it is focused on application source code and not environment configuration and is best used when you need to support multiple versions of your application in production. I do not recommend this approach for GitOps, the main reasons are that pull requests and merges will be very complex and promotions between environments are a hurdle. The whole life cycle of a cluster configuration will be very complex.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_environment_per_folder_monorepo">Environment-per-folder - Monorepo&lt;/h3>
&lt;div class="paragraph">
&lt;p>In this case, all environments are in a &lt;strong>single&lt;/strong> Git repository, and all are in the same branch. The filesystem has different folders that hold configuration files for each environment. The configuration of the “DEV” environment is described by a “DEV” folder, the “production” environment is found in a “production” folder and so on.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/2_repostructure/monorepo.png" alt="GitOps Monorepo Approach"/>
&lt;/div>
&lt;div class="title">Figure 1. GitOps Monorepo Approach&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This is the approach I usually recommend, especially when someone is new to the whole GitOps workflow and because of the simplicity of setting up such a repository.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following advantages and disadvantages should be considered:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Pros&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Provides a central location for configuration changes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This simplicity enabled straightforward Git workflows that will be centrally visible to the entire organisation, allowing a smoother and clearer approval process and merging.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Better suitable for small teams that are managing the cluster and easy to read and understand&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Easy to debug problems.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Cons&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Scalability &amp;gt;&amp;gt; Increase complexity &amp;gt;&amp;gt; Management&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Performance for huge repositories&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Challenging to control access permissions on a single repository&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_environment_per_repository_multirepo">Environment-per-repository - Multirepo&lt;/h3>
&lt;div class="paragraph">
&lt;p>In this case, each environment is on its separate git repository. So, the DEV environment is in a git repository called “DEV”, the “production” environment is in a “production” git repository and so on. The GitOps agent (OpenShift GitOps) connects to multiple repositories and takes care to apply the correct configuration to the correct target cluster.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/gitopscollection/images/2_repostructure/multirepo.png" alt="GitOps Multirepo Approach"/>
&lt;/div>
&lt;div class="title">Figure 2. GitOps Multirepo Approach&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Like the Monorepo approach, Multirepo comes with some advantages and disadvantages:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Pros&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Allows separating concerns between different departments of organisations (a repository for the security team, a repository for the operations team, etc.)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Cons&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>More complex to manage&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Harder to understand and read the configuration (what is coming from where)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Argo CD Application dependencies might not be solved (i.e., Security tries to manage the same object as the operating team. Who is the leader?)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_example_setup">Example Setup&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_the_approach_i_choose">The Approach I choose&lt;/h3>
&lt;div class="paragraph">
&lt;p>I usually use and recommend &lt;strong>Monorepo&lt;/strong> approach.
The &lt;strong>environment-per-folder&lt;/strong> approach is a very good way to organise your GitOps applications. Not only is it very simple to implement and maintain, but it is also the optimal method for promoting releases between different GitOps environments. This approach can also work for any number of environments without any additional effort. Cluster configurations (for multiple clusters) are typically done by one team, therefore controlling access permissions in Git is not a big issue.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_example_folder_structure">Example Folder Structure&lt;/h3>
&lt;div class="paragraph">
&lt;p>Over time the following folder structure evolved or my repository:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">├── base &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
│   ├── argocd-resources-manager &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
│   └── init_app_of_apps &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
├── charts &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
├── clusters &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
│   ├── all &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
│   │   ├── base-operators
│   │   ├── etcd-encryption
│   ├── management-cluster &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
│   │   ├── branding
│   │   ├── generic-cluster-config
│   │   ├── management-gitops
│   │   ├── node-labels
│   │   ├── openshift-data-foundation
│   │   ├── setup-acm
│   │   ├── setup-acs
│   │   ├── setup-compliance-oeprator
│   │   ├── setup-openshift-logging
│   │   └── setup-quay
│   └── production-cluster &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
│   │   ├── branding
│   │   ├── generic-cluster-config
│   │   ├── node-labels
│   │   ├── openshift-data-foundation
│   │   ├── setup-acs
│   │   ├── setup-compliance-oeprator
│   │   └── setup-openshift-logging
├── init_GitOps.sh &lt;i class="conum" data-value="9">&lt;/i>&lt;b>(9)&lt;/b>
├── scripts &lt;i class="conum" data-value="10">&lt;/i>&lt;b>(10)&lt;/b>
│   ├── example_htpasswd
│   ├── sealed_secrets
├── tenant-projects &lt;i class="conum" data-value="11">&lt;/i>&lt;b>(11)&lt;/b>
   ├── my-main-app
   └── my-second-app&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The &lt;code>base&lt;/code> folder contains basic configurations or Argo CD itself.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The &lt;code>argocd-resources-manager&lt;/code> is a Helm Chart that configures Applications and ApplicationSets or Argo CD using a single configuration file.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The &lt;code>init_app_of_apps&lt;/code> is used during the initial installation of OpenShift GitOps and installs the App-of-Apps that manages other Applications or Argo CD. This Application automatically synchronises and watches for changes in the folder &lt;code>argocd-resources-manager&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The &lt;code>charts&lt;/code> folder is &lt;strong>optional&lt;/strong> and can store local Helm Charts. Usually, it is better to release the Charts in a Helm repository, where they can be managed independently to the cluster configuration repository.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The folder for the different clusters.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Configurations that are equal for all clusters and simple to achieve without any deeper configuration. Currently, for example, the activation of the etcd encryption and the deployment of base Operators that every cluster will require. In this case, the Operators are installed only, without further configuration.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Configuration for the &lt;code>management-cluster&lt;/code>. For example, deploying ACM, ACS, Quay or any generic cluster configuration. Here we see immediately what is deployed and where I can modify the configuration for that cluster.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>Configuration for the &lt;code>production-clusters&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="9">&lt;/i>&lt;b>9&lt;/b>&lt;/td>
&lt;td>The deployment script to install and configure the OpenShift GitOps Operator. This might be replaced or at least modified in the future once &lt;a href="https://docs.openshift.com/container-platform/4.14/operators/admin/olm-managing-po.html#platform-operators_olm-managing-po" target="_blank" rel="noopener">PlatformOperators&lt;/a> are generally available and not in a technology preview state anymore.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="10">&lt;/i>&lt;b>10&lt;/b>&lt;/td>
&lt;td>The &lt;code>scripts&lt;/code> folder simply contains some shell scripts that might be useful. For example, to backup a Sealed Secrets key or generate a htpasswd file.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="11">&lt;/i>&lt;b>11&lt;/b>&lt;/td>
&lt;td>The &lt;code>tenant-projects&lt;/code> folder is a special folder to store the configuration or projects. Any project onboarding is configured here, such as Quota, LimitRanges, NetworkPolicies etc.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_why_the_repeating_folders">Why the repeating folders?&lt;/h3>
&lt;div class="paragraph">
&lt;p>Some may argue why certain folders are equal for management and production clusters, for example, &amp;#34;setup-compliance-operator&amp;#34;, when this could be done more easily by defining such folder only once and using different overlays (using Kustomize) or different values-files (using Helm Charts). However, while this is a very valid question, I personally, like to see immediately what is configured on each cluster. I see, based on the folders, what is configured on the management cluster and where I could modify the configuration.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Using Kustomize overlays, for example, would mean recreating the overlays for each configuration (if you want to have a clean separation and not combine all manifests into one overlay). Using different values-files is again a valid option, but (also again), you do not see what is configured on which cluster with one look.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Therefore, I like this folder structure, even if it may look weird (especially if you are used to Kustomize overlays). However, everyone is invited to define their very own structure :)&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_managing_kubernetes_manifests">Managing Kubernetes Manifests&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The Kubernetes manifests (the yaml files) must be managed in a way Argo CD can read and synchronise them.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Three &lt;strong>main&lt;/strong> options are commonly used:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Helm&lt;/strong>: Helm uses a packaging format called charts. A chart is a collection of files that describe a related set of Kubernetes resources.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Kustomize&lt;/strong>: A Template-free way to customise application configuration that simplifies the use of off-the-shelf applications.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Plain Text&lt;/strong>: Plain text Kubernetes objects provided in YAML of JSON format.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Argo CD also understands &lt;strong>jsonnet&lt;/strong> or even custom plugins. However, I had no customer up until now, who wanted to use something else than Kustomize or Helm.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The different tools are not explained in detail in this article, but the choice of the tool highly depends on the existing knowledge and individual preferences inside the company. Every option has advantages and disadvantages that will become visible when they are used.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I have seen companies tend to use Helm Charts or Plain Text, especially when they are new to the tools.
However, no tool is better than the other. Instead, the tools can be combined which might be useful for some use cases.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Kustomize and Helm do not exclude each other and can be combined. However, for the start, a single tool should be selected.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Introducing the GitOps Approach</title><link>https://blog.stderr.at/gitopscollection/2023-12-11-gitops-intro/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2023-12-11-gitops-intro/</guid><description>&lt;div class="paragraph">
&lt;p>When managing one or more clusters, the question arises as to how cluster configurations and applications can be installed securely, regularly, and in the same way.
This is where the so-called GitOps approach helps, according to the mantra: &amp;#34;&lt;strong>If it is not in Git, it does not exist&lt;/strong>&amp;#34;.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The idea is to have Git as the only source of truth on what happens inside the environment. While there are many articles about how to get GitOps into the deployment process of applications, this series of articles tries to set the focus on the &lt;strong>cluster configuration&lt;/strong> and tasks system administrators usually have to do, for example: Setup an Operator.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_gitops_approach">The GitOps Approach&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>This series includes the following articles:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2023-12-28-gitops-repostructure/">Choosing the right Git repository structure&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-02-02-setup-argocd/">Install GitOps to the cluster&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-04-02-configure_app_of_apps/">Configure App-of-Apps&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-04-25-installing-compliance-operator/">Setup Compliance Operator&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-04-28-installing-advanced-cluster-security/">Setup &amp;amp; Configure Advanced Cluster Security using GitOps&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-05-17-configure-minio-buckets/">Configure Buckets in MinIO using GitOps&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-05-19-install-openshift-logging/">Installing OpenShift Logging using GitOps&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-06-02-multisources-for-application-in-argocd/">Multiple Sources for Applications in Argo CD&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-06-07-update-cluster-version-with-gitops/">Update Cluster Version&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-07-04-managing-certificates-with-gitops/">Managing Certificates&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.stderr.at/gitopscollection/2024-10-13-using-post-renderer/">Using Kustomize to post render a Helm Chart&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
In this series, I will focus on cluster configuration.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The GitOps approach is a very common practice and the-facto &amp;#34;standard&amp;#34; as of today.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
When I write standard, then be assured, that the approach itself should be followed, but HOW this is done can be a topic of many tough discussions.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>But what is it and why should a company invest time to follow this approach?&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>_GitOps is a declarative way to implement continuous deployment for cloud-native applications. It should be a repeatable process to manage multiple clusters.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>GitOps adds the following features to company processes:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Everything as code&lt;/strong>: The entire state of the application, infrastructure and configuration is declaratively defined as code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Git and the single source of truth&lt;/strong>: Every setting and every manifest is stored and versioned in Git. Any change must first be saved to Git.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Operations via Git workflows&lt;/strong>: Standard Git procedures, such as pull or merge requests, should be used to track any changes to the applications or cluster configurations.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It is important that not only the manifests of the applications but also the cluster configuration is stored in Git. The goal should be to ensure that no manual changes are made directly to the cluster.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_benefitschallenges">Benefits/Challenges&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Deploying new versions of applications or cluster configurations with a high degree of confidence is a desirable goal as getting features reliably to production is one of the most important characteristics of fast-moving organisations.
GitOps is a set of &lt;strong>common practices&lt;/strong> where the entire code delivery process is controlled via Git, including infrastructure and application definition as code and automation to complete updates and rollbacks.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>GitOps constantly watches for changes in Git repositories and compares them with the current state of the cluster. If there is a drift it will either automatically synchronise to the wanted state or warn accordingly (manual sync must then be performed).&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The key GitOps advantages are:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Cluster and application configuration versioned in Git&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Visualisation of desired system state&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Automatically syncs configuration from Git to clusters (if enabled)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Drift detection, visualisation, and correction&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rollback and roll-forward to any Git commit.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Manifest templating support (Helm, Kustomize, etc.)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Visual insight into sync status and history.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Role-Based access support&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pipeline integration&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Adopting GitOps has enormous benefits but does pose some challenges. Many teams will have to adjust their culture and way of working to support using Git as the single source of truth. Strictly adhering to GitOps processes will mean all changes will be committed. This may present a challenge when it comes to debugging a live environment. There may be times when that is necessary and will require suspending GitOps in some way.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Some other prerequisites for adopting GitOps include&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Good testing and CI processes are in place.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A strategy for dealing with promotions between environments.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Strategy for Secrets management.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_used_tools">Used Tools&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The following list of tools (or specifications) are used for our GitOps Approach.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://docs.openshift.com/gitops/1.11/understanding_openshift_gitops/what-is-gitops.html#what-is-gitops" target="_blank" rel="noopener">OpenShift GitOps&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://helm.sh/docs/topics/charts/" target="_blank" rel="noopener">Helm&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_used_repositories">Used Repositories&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The following two Git repositories are used throughout the series:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops" target="_blank" rel="noopener">OpenShift Configuration&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://charts.stderr.at/" target="_blank" rel="noopener">Helm Repository&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Quay Deployment and Configuration using GitOps</title><link>https://blog.stderr.at/openshift/2023/11/quay-deployment-and-configuration-using-gitops/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/openshift/2023/11/quay-deployment-and-configuration-using-gitops/</guid><description>&lt;div class="paragraph">
&lt;p>Installing and configuring Quay Enterprise using a GitOps approach is not as easy as it sounds.
On the one hand, the operator is deployed easily, on the other hand, the configuration of Quay is quite tough to do in a declarative way and syntax rules must be strictly followed.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In this article, I am trying to explain how I solved this issue by using a Kubernetes Job and a Helm Chart.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_what_about_quay_configuration">What about Quay configuration?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Quay Enterprise is using a (quite big) Secrets object that defines tons of settings for the registry. The syntax must strictly be followed.
For example, a Boolean must be &lt;code>true&lt;/code> or &lt;code>false&lt;/code>. Quay ignores if a string like &lt;strong>&amp;#34;true&amp;#34;&lt;/strong> or &lt;strong>&amp;#34;false&amp;#34;&lt;/strong> is provided.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This alone is already a hassle since working with Booleans in Helm is not as easy as you might think.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Secret combines &lt;strong>non-sensitive data&lt;/strong> (like &lt;em>DEFAULT_TAG_EXPIRATION&lt;/em>) with &lt;strong>sensitive data&lt;/strong> (like settings for the Object Store)&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If there is any error in the configuration file, or if the Operator is configured to manage a specific component, but finds settings for this component in the Secret, the deployment will fail.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_solution">The solution?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>I thought for a long time about how to solve this issue. One solution might be to create the whole Secret upfront and simply provide it
during the deployment. This works and I have done this previously, but I wanted to generate the Secret during the deployment.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Therefore, I am now trying to create a ConfigMap that holds a complete skeleton of the required Secret. This ConfigMap is used by a
Kubernetes Job, which reads the required sensitive information out of other existing Secrets (such as S3 information) and generates a
quay-secret by replacing the required fields.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Is this the perfect and optimal way to do that? Probably not, however, it works :)&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_let_us_see_that_in_action">Let us see that in action&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_prerequisites">Prerequisites&lt;/h3>
&lt;div class="paragraph">
&lt;p>First, we have some prerequisites.&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Quay is very …​ very hungry for resources. Quay application pods require 8 CPU and 16GB Memory per pod and per default…​ and it tries to spin up 2 pods. The
same goes for Clair and so on. Therefore, I will configure Quay to only use 1 replica for these services.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Quay requires node roles &lt;code>infra&lt;/code>. I am not sure if this is new or if I never saw that, but the nodeSelector, which it seems you cannot
configure, is looking for the label infra. Therefore, the nodes that should host Quay must have the label: &lt;code>node-role.kubernetes.io/infra: &amp;#39;&amp;#39;&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Currently, I am using a &lt;code>BucketClaim&lt;/code> object to create an S3-bucket
and once created I read the required information of the bucket to
replace the settings in the generated Quay configuration accordingly.
The BucketClaim object comes from the &lt;strong>OpenShift Data Foundation&lt;/strong>. I
installed the &lt;strong>Multicloud Object Gateway&lt;/strong> only, which allows me to
provide Object Storage (S3). (Very useful to test other solutions too,
like OpenShift Logging or Network Observability)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Meeting these requirements, allows us to deploy Quay. But first some theory.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_deployment_workflow">Deployment Workflow&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The workflow of the deployment is as the following image demonstrates&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/quay-setup/quay-synwaves.png" alt="Argo CD Syncwaves"/>
&lt;/div>
&lt;div class="title">Figure 1. Argo CD: Syncwaves&lt;/div>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Everything starts with the Helm Chart &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/setup-quay">setup-quay&lt;/a>. This Chart itself provides the logic to create an S3-bucket, a Job to generate the configuration and the creation of a Secret, that provides the initial administrator credential.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>setup-quay&lt;/strong> has multiple dependencies to other Helm charts, that can be found at my &lt;a href="https://charts.stderr.at">Helm repository&lt;/a>:&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/quay-registry-setup">quay-registry-setup&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-operator">helper-operator&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-status-checker">helper-status-checker&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_configuration">Configuration&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>All values for the Helm Charts can be found in the &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/blob/main/clusters/management-cluster/setup-quay/values.yaml">values file&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Since sub-charts are used the file is divided into 4 blocks:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>helper-operator: Here the sub-chart helper-operator is configured. All settings here are bypassed to the subchart. It defines the required settings to deploy the operator.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>helper-status-checker: Here settings for the status-checker Job are defined.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>quay-registry-setup: This defines the actual configuration of the QuayEnterprise object. It will spin up the Quay instance. Some components are set to &amp;#34;false&amp;#34; or &amp;#34;replica == 1&amp;#34; to minimize the required resources in my lab. For a production environment, additional replicas or components might be required.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>quay: These are the actual values for the configuration. It defines the bucketClaim as well as settings for the Quay configuration that might be overwritten.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_deploy_it">Deploy it&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Using for example the following Argo CD Application we can deploy everything.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
name: in-cluster-setup-quay
namespace: openshift-gitops
spec:
destination:
name: in-cluster &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: default
ignoreDifferences: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- jsonPointers:
- /data/password
kind: Secret
name: init-user
namespace: quay-enterprise
info:
- name: Description
value: ApplicationSet that Deploys on Management Cluster (Matrix Generator)
project: in-cluster
source:
path: clusters/management-cluster/setup-quay &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
repoURL: &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39;
targetRevision: main&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The destination cluster. Here the &amp;#34;in-cluster&amp;#34; means the local cluster of Argo CD.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The initial credential for Quay is being generated and would change if the Argo CD application gets refreshed and therefore it would be out of sync. So, we are ignoring differences in the password field.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The source of the Helm Chart.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Argo CD this Application will look like&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/quay-setup/quay-in-argocd.png?width=640px" alt="Quay in Argo CD"/>
&lt;/div>
&lt;div class="title">Figure 2. Quay in Argo CD&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Deployment means in GitOps approach: synchronizing the Argo CD Application.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will install the Operator and spin up all required Pods and Jobs. It will take several minutes until everything is up and running. During the deployment, some Pods may fail and will get restarted automatically. This happens because they are dependent on the Postgres DB which must be started first.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_quay_is_alive">Quay is Alive&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Congratulations, you have now a Quay instance. Use the auto-generated
credentials, that are stored in the Secret &lt;code>init-user&lt;/code> to authenticate.&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/quay-setup/quay-login.png?width=320px" alt="Quay Login"/>
&lt;/div>
&lt;div class="title">Figure 3. Quay Login&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_is_that_all_kind_of_summary">Is that All - Kind of Summary?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Several configurations are done here now. However, there are tons to follow. For example, log forwarding or additional certificates. Some
settings will contain sensitive information some will not. All these settings can be added to the ConfigMap skeleton and be replaced
accordingly with &amp;#34;little&amp;#34; effort.
For me, it is simply not possible to test every setting and possibility. Maybe I will extend the
Helm Chart during the journey. If you find this useful, feel free to re-use it and of course, if you find any issues feel free to create a GitHub issue.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Operator installation with Argo CD</title><link>https://blog.stderr.at/openshift/2023/03/operator-installation-with-argo-cd/</link><pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/openshift/2023/03/operator-installation-with-argo-cd/</guid><description>&lt;div class="paragraph">
&lt;p>GitOps for application deployment and cluster configuration is a must-have I am trying to convince every customer to follow from the very beginning when starting the Kubernetes journey. For me, as more on the infrastructure side of things, I am more focused on the configuration of an environment.
Meaning, configuring a cluster, installing an operator etc.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In this article, I would like to share how I deal with cluster configuration when certain Kubernetes objects are dependent on each other and how to use Kubernetes but also Argo CD features to resolve these dependencies.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
This article assumes that you have the &lt;strong>openshift-gitops&lt;/strong> Operator, which provides Argo CD, already installed, and configured. If you are new to GitOps check out this article: &lt;a href="https://blog.stderr.at/openshift/2020-08-06-argocd/">Argo CD&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_tldr">TL;DR&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>If you want to jump directly to the technical fun part, go here: &lt;a href="#source_1">Let’s start&lt;/a>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_idea">The Idea&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Everything should be seen as a code. Everything should be possible to be deployed in a repeatable way. With a GitOps approach, everything is stored naturally in Git and from there, a GitOps agent validates and synchronizes changes to one or more clusters.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>When it comes to OpenShift, Red Hat supports Argo CD using the Operator &lt;strong>openshift-gitops&lt;/strong>. This gives you everything you need to deploy an Argo CD instance. The only thing you need to take care of is a Git repository, no matter if it is GitHub, Gitlab, Bitbucket etc.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_problem">The Problem&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Sometimes Kubernetes objects depend on each other. This is especially true when you would like to install and configure Operators, where the configuration, based on a Customer Resource Definition (CRD), can only happen after the Operator has been installed and is ready.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Why is that? Well, when you want to deploy an Operator, you will store a “Subscription object” in Git. Argo CD will take this object and applies it to the cluster. However, for an Operator, the creation of the Subscription object is just the first step. A lot of other steps are required until the Operator gets ready. Unfortunately, Argo CD cannot verify if the installation is successful. All it sees is that the Subscription object has been created and then it immediately tries to deploy the CRD. The CRD which is not yet available on the system because the Operator is still installing it.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Even if you use Argo CD features like Sync waves it would not wait until the Operator is successfully installed because for Argo CD the “success” is the creation of the Subscription object.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Subsequently, the Argo CD synchronisation process will fail.
You could now try to automatically “Retry” the sync or use multiple Argo CD applications that you execute one after each other, but I was not fully happy with that and tried a different approach.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_my_solution">My Solution&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Let’s say I would like to deploy and configure the &lt;strong>Compliance Operator&lt;/strong>. The steps would be:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Install the Operator.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Wait until the Operator is ready.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Configure Operator specific CRDs.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This “Wait until the Operator is ready” is the tricky party for Argo CD. What I have done is the following:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Install the Operator, this is the first step and is done during Sync Wave 0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create a Kubernetes Job that verifies the status of the Operator. This Job additionally requires a ServiceAccount and a role with a binding. They are configured during Sync Wave is 1. Moreover, I use a &lt;strong>Hook&lt;/strong> (another Argo CD feature) with the deletion policy “HookSucceeded”. This makes sure that the Job, ServiceAccount, Role and RoleBinding are removed after the status has been verified.
The verification is successful as soon as the Operator status says “Succeeded”. In fact, all the Job does is to execute some oc commands. For example,&lt;/p>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get clusterserviceversion openshift-gitops-operator.v1.8.0 -n openshift-gitops -o jsonpath={.status.phase}
Succeeded&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Finally, during the next Sync Wave (2+) the CRD can be deployed. In this case, I deploy the object &lt;strong>ScanSettingBinding&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>In Argo CD everything is correctly synchronized, and the Operator and its configuration is in place.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
If you are new to the compliance operator, I recommend the following article: &lt;a href="https://blog.stderr.at/compliance/2021/07/compliance-operator/">Compliance Operator&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I use this approach for every Operator that I would like to install and configure at the same time. For example, I do the same for Advanced Cluster Security or Advanced Cluster Management where I use the Job to verify if everything is ready before I let Argo CD continue.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
More information about Sync Waves and Hooks can be found in the official Argo CD documentation: &lt;a href="https://argo-cd.readthedocs.io/en/stable/user-guide/sync-waves/">Sync Phases and Waves&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="source_1">Let’s see this in Action&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;strong>Prerequisites&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>OpenShift cluster 4.x&lt;/p>
&lt;/li>
&lt;li>
&lt;p>openshift-gitops is installed and ready to be used.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Access to GitHub (or to your own Repository)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I will be using my Helm Chart repository at &lt;a href="https://charts.stderr.at/" class="bare">https://charts.stderr.at/&lt;/a> and from there the charts:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>compliance-operator-full-stack&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>helper-operator (sub chart): Responsible to install the Operators.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>helper-status-checker (sub chart): Responsible to check the status of the Operator.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>Why do I use Helm charts?&lt;/strong>
There is no specific reason for that. I started with Helm for the cluster configuration and now it has evolved with a separate Chart repository and sub-charts and so on.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_argo_cd_application">Argo CD Application&lt;/h3>
&lt;div class="paragraph">
&lt;p>In Argo CD I have the following Application:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
name: in-cluster-install-compliance-scans
namespace: openshift-gitops
spec:
destination:
namespace: default
server: &amp;#39;https://kubernetes.default.svc&amp;#39; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
info:
- name: Description
value: Deploy and configure the Compliance Scan Operator
project: in-cluster
source:
path: charts/compliance-operator-full-stack &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
repoURL: &amp;#39;https://github.com/tjungbauer/helm-charts&amp;#39;
targetRevision: main&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Installing on the local cluster where Argo CD is installed.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Git configuration, including path and revision.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Actually, this Application is created out of an ApplicationSet, but I did not want to make it too complex :)
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Application would like to synchronize the objects:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Subscription&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OperatorGroup&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Namespace (openshift-compliance)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ScanSettingBinding&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-operator-installation.png" alt="Installing Compliance Operator"/>
&lt;/div>
&lt;div class="title">Figure 1. Argo CD: Installing Compliance Operator&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
&lt;strong>Where are the objects we need for the Job?&lt;/strong> Since they are only available during the Sync-Hook they will not show up here. In fact, they will only show up during the time they are alive and will disappear again after the status of the operator has been verified.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_helm_chart_configuration">Helm Chart Configuration&lt;/h3>
&lt;div class="paragraph">
&lt;p>The &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/compliance-operator-full-stack">Helm Chart&lt;/a> gets its configuration from a values file. You can verify the whole file on GitHub.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The important pieces here are that some variables are handed over to the appropriate Sub Charts.&lt;/p>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_operator_configuration">Operator Configuration&lt;/h4>
&lt;div class="paragraph">
&lt;p>This part is handed over to the Chart “&lt;strong>helper-operator&lt;/strong>”.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-operator:
operators:
compliance-operator:
enabled: true
syncwave: &amp;#39;0&amp;#39;
namespace:
name: openshift-compliance
create: true
subscription:
channel: release-0.1
approval: Automatic
operatorName: compliance-operator
source: redhat-operators
sourceNamespace: openshift-marketplace
operatorgroup:
create: true
notownnamespace: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It is executed during Sync Wave 0 and defines if a Namespace (openshift-compliance) shall be created (true) and the specification of the Operator which you need to know upfront:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>channel&lt;/strong>: Defines which channel shall be used. Some operators offer different channels.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>approval&lt;/strong>: Either Automatic or Manual … defines if the Operator shall be updated automatically or requires an approval.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>operatorName&lt;/strong>: the actual name of the Operator (compliance-operator)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>source&lt;/strong>: Where does this Operator come from (redhat-operator)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>sourceNamespace&lt;/strong>: In this case openshift-marketplace&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>You can fetch these values by looking at the Packagemanifest:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-bash" data-lang="bash">oc get packagemanifest compliance-operator -o yaml&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_status_checker_configuration">Status Checker Configuration&lt;/h4>
&lt;div class="paragraph">
&lt;p>This part is handed over to the Sub-Chart &amp;#34;&lt;strong>helper-status-checker&lt;/strong>&amp;#34;&amp;#34;. The main values here are the operatorName and the namespace where the Operator is installed.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>What is not visible here is the Sync Wave, which is per default set to 1 inside the Helm Chart. If you need to overwrite it, it can be configured in this section as well.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-status-checker:
enabled: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# use the value of the currentCSV (packagemanifest) but WITHOUT the version !!
operatorName: compliance-operator &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# where operator is installed
namespace:
name: openshift-compliance &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
serviceAccount:
create: true
name: &amp;#34;sa-compliance&amp;#34; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Is the status checker enabled or is it not.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The name of the operator as it is reported by the value currentCSV inside the packageManifest&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The namespace where the Operator has been installed.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>The name of the ServiceAccount that is created temporarily.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock warning">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-warning" title="Warning">&lt;/i>
&lt;/td>
&lt;td class="content">
The operatorName is sometimes different than the Operator name required for helper-operator chart. Here it seems the value of the currentCSV must be used but without the version number. (The Job will look up the version itself)
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_operator_crd_configuration">Operator CRD configuration&lt;/h4>
&lt;div class="paragraph">
&lt;p>The final section of the values file manages the configuration for the Operator itself. This section does not use a Sub Chart. Instead, the variables are used in the Main-Chart. In this example, the &lt;strong>ScanSettingBinding&lt;/strong> will be configured during Sync Wave 3, which is all we need to basic functionality.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">compliance:
scansettingbinding:
enabled: true
syncwave: &amp;#39;3&amp;#39; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
profiles: &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- name: ocp4-cis-node
- name: ocp4-cis
scansetting: default&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Define the Sync Wave. This value must be higher than the Sync Wave of the &lt;strong>helper-status-checker&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>ScanSettingBinding configuration. Two profiles are used in this example.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_synchronizing_argo_cd">Synchronizing Argo CD&lt;/h3>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Basic Application in Argo CD before it is synced:&lt;/p>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-operator-installation.png?width=480" alt="argocd operator installation"/>
&lt;/div>
&lt;div class="title">Figure 2. Argo CD: Application&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Sync Wave 0: Synchronization has started. Namespace and Subscription are deployed.&lt;/p>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-starting-operator-installation.png?width=480" alt="argocd starting operator installation"/>
&lt;/div>
&lt;div class="title">Figure 3. Argo CD: Synchronization is started (Sync Wave 0)&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Sync Wave 1: Status Checker Job has started and tries to verify the Operator.&lt;/p>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-starting-job.png?width=480" alt="argocd starting job"/>
&lt;/div>
&lt;div class="title">Figure 4. Argo CD: Status Checker Job started (Sync Wave 1)&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>The Log output of the Operator. You can see that the status switches from Pending to Installing to Succeeded.&lt;/p>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-status-checker-log.png?width=480" alt="argocd status checker log"/>
&lt;/div>
&lt;div class="title">Figure 5. Argo CD: Log of the Status Checker Pod&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>After Sync Wave 3, the whole Application has been synchronized and the Checker Job has been removed.&lt;/p>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-operator-installed.png?width=480" alt="argocd operator installed"/>
&lt;/div>
&lt;div class="title">Figure 6. Argo CD: Compliance Operator is fully deployed&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Using ServerSideApply with ArgoCD</title><link>https://blog.stderr.at/openshift/2022/11/using-serversideapply-with-argocd/</link><pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/openshift/2022/11/using-serversideapply-with-argocd/</guid><description>&lt;div class="paragraph">
&lt;p>„&lt;em>If it is not in GitOps, it does not exist&lt;/em>“ - However, managing objects partially only by Gitops was always an issue, since ArgoCD would like to manage the whole object. For example, when you tried to work with node labels and would like to manage them via Gitops, you would need to put the whole node object into ArgoCD. This is impractical since the node object is very complex and typically managed by the cluster.
There were 3rd party solutions (like the patch operator), that helped with this issue.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>However, with the Kubernetes feature &lt;strong>Server-Side Apply&lt;/strong> this problem is solved. Read further to see a working example of this feature.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_what_is_server_side_apply_ssa">What is Server-Side Apply (SSA)&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Quoting from &lt;a href="https://kubernetes.io/docs/reference/using-api/server-side-apply/">Kuberneted Documentation&lt;/a>:&lt;/p>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>&lt;em>Server-Side Apply helps users and controllers manage their resources through declarative configurations. Clients can create and modify their objects declaratively by sending their fully specified intent.&lt;/em>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;em>A fully specified intent is a partial object that only includes the fields and values for which the user has an opinion. That intent either creates a new object or is combined, by the server, with the existing object.&lt;/em>&lt;/p>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>In other words: you can send a snippet of an object to the cluster and the cluster will eventually combine everything on the server and not validate on the client side first. All you need is a way to identify the object. Usually, the name and maybe the namespace too.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_ssa_and_argocd">SSA and ArgoCD&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>When it comes to GitOps the implementation of SSA is quite new. However, it is important to note, that (managed field) conflicts are currently not handled by ArgoCD. Instead, ArgoCD forces a change and overrides everything, even if the field is managed by somebody else. This might be improved in the future. Nevertheless …​ let’s test the feature.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The support of the Server-Side Apply feature is currently available in the &lt;strong>latest&lt;/strong> version of ArgoCD. This means, that the channel of the openshift-gitops operator must be changed to &amp;#34;latest&amp;#34;, which will deploy openshift-gitops version &lt;strong>1.6&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>A new stable version will arrive soon. :)&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_node_labelling_chart">Node Labelling Chart&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>In this example, I would like to use a Helm chart that will try to set two different labels on 2 nodes. This is a very easy example to demonstrate the feature.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As a Helm chart, I have prepared the following: &lt;a href="https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/node-configuration" class="bare">https://github.com/tjungbauer/openshift-clusterconfig-gitops/tree/main/clusters/management-cluster/node-configuration&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The values for this chart are straightforward: per node, a list of custom labels is defined.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">helper-server-side-apply:
nodes: &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
- name: ip-10-0-233-237.us-west-1.compute.internal &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
enabled: true
custom_labels: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
environment: &amp;#39;Production&amp;#39;
gpu: false
- name: ip-10-0-193-67.us-west-1.compute.internal
enabled: true
custom_labels:
environment: &amp;#39;Test&amp;#39;
gpu: true&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>List of nodes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Node name as OpenShift knows the node (&lt;em>oc get nodes&lt;/em>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>List of labels that should be added to the node: here environment and gpu&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The Chart is using a sub-chart called &lt;strong>helper-server-side-apply&lt;/strong>. The source can be found at the &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/helper-server-side-apply">Helm Repository&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The output of this Helm Chart will be the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"># Source: node-labels/charts/helper-server-side-apply/templates/node.yaml
kind: Node
apiVersion: v1
metadata:
name: &amp;#34;ip-10-0-233-237.us-west-1.compute.internal&amp;#34; &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
labels:
gitops.ownedBy: openshift-gitops
helm.sh/chart: helper-server-side-apply-1.0.3
app.kubernetes.io/name: helper-server-side-apply
app.kubernetes.io/instance: release-name
app.kubernetes.io/managed-by: Helm
environment: &amp;#34;Production&amp;#34; &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
gpu: &amp;#34;false&amp;#34; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
---
# Source: node-labels/charts/helper-server-side-apply/templates/node.yaml
kind: Node
apiVersion: v1
metadata:
name: &amp;#34;ip-10-0-193-67.us-west-1.compute.internal&amp;#34;
labels:
gitops.ownedBy: openshift-gitops
helm.sh/chart: helper-server-side-apply-1.0.3
app.kubernetes.io/name: helper-server-side-apply
app.kubernetes.io/instance: release-name
app.kubernetes.io/managed-by: Helm
environment: &amp;#34;Test&amp;#34;
gpu: &amp;#34;true&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>The name of the node and our identifier&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>The first label we set&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>The second label we set&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
This is not a full definition of a Node object. The only things defined are the node name and the labels. (Besides the customer labels we would like to add, some default labels are added automatically.)
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_argocd_application">ArgoCD Application&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>So we have a Helm chart in Git. Perfect, but to automate everything with Gitops we need to create the object &lt;strong>Application&lt;/strong>. For example the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
name: node-labelling
namespace: openshift-gitops
spec:
destination:
namespace: default
server: &amp;#39;https://kubernetes.default.svc&amp;#39;
info:
- name: Description
value: Deploy Node Labels
project: default
source:
helm:
valueFiles:
- values.yaml
path: clusters/management-cluster/node-configuration &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
repoURL: &amp;#39;https://github.com/tjungbauer/openshift-clusterconfig-gitops&amp;#39;
targetRevision: main
syncPolicy:
syncOptions:
- ServerSideApply=true &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
- Validate=false &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Path and URL of the node labelling Helm chart&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Must be set to &lt;strong>true&lt;/strong> to enable SSA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Must be set to &lt;strong>false&lt;/strong> to skip schema validation&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
The two &lt;strong>syncOptions&lt;/strong> are important to set. Since the yaml output might not pass the validation, the schema validation should be disabled.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This will create the following application in ArgoCD:&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://blog.stderr.at/openshift/images/argocd2/argocd-app-nodelabelling.png?width=840px" alt="ApplicationSet"/>
&lt;/div>
&lt;div class="title">Figure 1. Argo CD: Application&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_syncing_the_application">Syncing the Application&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>When you now synchronize the ArgoCD application, ArgoCD will take the yaml and will tell Kubernetes (or OpenShift) to perform a Server-Side Apply. This will result in the following yaml for the node:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">kind: Node
apiVersion: v1
metadata:
name: ip-10-0-193-67.us-west-1.compute.internal
labels:
beta.kubernetes.io/os: linux
app.kubernetes.io/instance: node-labelling
[...]
node-role.kubernetes.io/worker: &amp;#39;&amp;#39;
gitops.ownedBy: openshift-gitops
[...]
environment: Test
[...]&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>That’s it …​ all the magic is done.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item></channel></rss>