<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>MinIO on TechBlog about OpenShift/Ansible/Satellite and much more</title><link>https://blog.stderr.at/tags/minio/</link><description>TechBlog about OpenShift/Ansible/Satellite and much more</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Toni Schmidbauer &amp; Thomas Jungbauer</copyright><lastBuildDate>Fri, 17 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stderr.at/tags/minio/index.xml" rel="self" type="application/rss+xml"/><item><title>Configure Buckets in MinIO using GitOps</title><link>https://blog.stderr.at/gitopscollection/2024-05-17-configure-minio-buckets/</link><pubDate>Fri, 17 May 2024 00:00:00 +0000</pubDate><guid>https://blog.stderr.at/gitopscollection/2024-05-17-configure-minio-buckets/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;a href="https://min.io/" target="_blank" rel="noopener">MinIO&lt;/a> is a simple, S3-compatible object storage, built for high-performance and large-scale environments. It can be installed as an Operator to Openshift. In addition, to a command line tool, it provides a WebUI where all settings can be done, especially creating and configuring new buckets. Currently, this is not possible in a declarative GitOps-friendly way.
Therefore, I created the Helm chart &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator" target="_blank" rel="noopener">minio configurator&lt;/a>, that will start a Kubernetes Job, which will take care of the configuration.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Honestly, when I say I have created it, the truth is, that it is based on an existing &lt;a href="https://github.com/bitnami/charts/tree/main/bitnami/minio" target="_blank" rel="noopener">MinIO Chart by Bitnami&lt;/a>, that does much more than just set up a bucket. I took out the bucket configuration part, streamlined it a bit and added some new features, which I required.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This article shall explain how to achieve this.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_prerequisites">Prerequisites&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Argo CD (OpenShift GitOps) deployed&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MinIO including a deployed tenant that is waiting for buckets&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_introduction">Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>After MinIO and the Tenant have been deployed, we can &lt;strong>configure and update&lt;/strong> a bucket, users, policies and more. Since I do not want to do this manually, the Helm Chart that will be described here creates a Kubernetes Job that leverages the &lt;strong>mc command line tool&lt;/strong> to execute certain tasks automatically. The chart will take care of:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>creating a lifecycle policy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>creating an access policy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>creating a new user/group. User credentials might be added directly to the values file or, better, are imported as a secret&lt;/p>
&lt;/li>
&lt;li>
&lt;p>attaching policies to a user/group&lt;/p>
&lt;/li>
&lt;li>
&lt;p>creating a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>set a quota for a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>set tags for a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>enable versioning for a bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>enable object locking for a bucket (&lt;strong>be aware&lt;/strong> that this can only be enabled during the bucket creation)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>enable bucket replication to a target cluster/bucket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>execute possible extra commands that are configured in the values file&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>To perform all these tasks Bitnami released a container image: &lt;strong>docker.io/bitnami/minio:2024.5.1-debian-12-r0&lt;/strong>
They are updating this image regularly.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Actually, the image can be used to deploy the minio server. At this moment, we are interested in the command line tool only. Bitnami also managing a &lt;em>minio-client&lt;/em> image, that can be tested and used. However, I left the original image, which is working very well.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_the_values">The Values&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
All settings are explained in more detail at: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator" class="bare">https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
The Job and everything that is required, are executed inside the Tenant namespace. In the following examples, this will be &lt;strong>minio-tenant-namespace&lt;/strong>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_basic_settings">Basic Settings&lt;/h3>
&lt;div class="paragraph">
&lt;p>The basic settings are the following. They will define the namespace of the Tenant, the name of the ServiceAccount, the URL of the tenant, Argo CD Hook settings and the image that shall be used for the deployment.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">name: minio-provisioner &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: minio-tenant-namespace &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
synwave: 5 &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
argoproj: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
hook: Sync
hook_delete_policy: HookSucceeded
image:
url: docker.io/bitnami/minio:2024.5.1-debian-12-r0 &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
# Information of the Minio Cluster
miniocluster: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
url: minio-tenant-api-url
port: 443
skip_tls_verification: true &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
# Specifies whether a ServiceAccount should be created
serviceAccount: &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
create: true
name: &amp;#34;minio-provisioner&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the Kubernetes provisioner Job resource.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Namespace of the MinIO Tenant.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Syncwave of the provisioner Job.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Possible Argo CD hook configuration.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The container image the provisioner Job will use.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>The URL of the minio console. This will be used to set the &amp;#34;alias&amp;#34; for the mc command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Skip verification of TLS for the mc command. This will disable the TLS check for any mc command the Job will execute.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>Information about the ServiceAccount&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_authentication_settings">Authentication Settings&lt;/h3>
&lt;div class="paragraph">
&lt;p>To be able to authenticate against MinIO credentials must be provided. This happens, typically, in the form of a Secret:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">auth:
useCredentialsFiles: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
secretName: minio-provisioner &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Shall a secret mounted as a file be used (preferred)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the Secret&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The Secret itself requires specific keys and should look like the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">kind: Secret
apiVersion: v1
metadata:
name: minio-provisioner &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
namespace: minio-tenant-namespace &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
data:
root-password: &amp;lt;base64 string&amp;gt; &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
root-user: &amp;lt;base64 string&amp;gt; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
type: Opaque&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the Secret as mentioned in the minio-configurator values files&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the Namespace as mentioned in the minio-configurator values files&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Password to access MinIO&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>User to access MinIO&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
The Secret must exist upfront and is not created by the Helm Chart. Either pick it from a Vault or create a Sealed Secret to be able to store it in Git.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The credentials are called &lt;strong>root-&lt;/strong>. Any user that has permission to configure buckets is sufficient here. Still, the keys must be named that way.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_creating_minio_policies">Creating MinIO Policies&lt;/h3>
&lt;div class="paragraph">
&lt;p>MinIO uses Policy-Based Access Control to define which actions can be performed on certain resources by an authenticated user.
A policy can be created by the command &lt;strong>mc admin policy&lt;/strong>. Our Kubernetes Job will take the configuration from the values file and mount the information as a JSON file, that will be imported into MinIO.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following specification shows the example for OpenShift Logging:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">provisioning:
enabled: true &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
policies:
- name: openshift-logging-access-policy &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
statements:
- resources: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
- &amp;#34;arn:aws:s3:::openshift-logging&amp;#34;
- &amp;#34;arn:aws:s3:::openshift-logging/*&amp;#34;
effect: &amp;#34;Allow&amp;#34; &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
actions:
- &amp;#34;s3:*&amp;#34; &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>In general, enable the provisioning or not&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Name of the policy. Multiple can be defined and assigned to a user or group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Define the resources the policy should manage access to.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Define the effect: Allow or Deny (default)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>The actions that are allowed. Here: any s3: action&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Multiple policies can be defined in the values file, and it is very important to exactly define the resources, the effect and the actions.
The above configuration will allow the user that has the policy assigned:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>All s3 actions to the bucket openshift-logging and everything inside this bucket (thus two resources)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>All actions are defined at: &lt;a href="https://min.io/docs/minio/linux/administration/identity-access-management/policy-based-access-control.html#minio-policy" target="_blank" rel="noopener">MinIO Access Management&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Another example would be the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> policies:
- name: custom-bucket-specific-policy
statements:
- resources:
- &amp;#34;arn:aws:s3:::my-bucket&amp;#34;
actions:
- &amp;#34;s3:GetBucketLocation&amp;#34;
- &amp;#34;s3:ListBucket&amp;#34;
- &amp;#34;s3:ListBucketMultipartUploads&amp;#34;
- resources:
- &amp;#34;arn:aws:s3:::my-bucket/*&amp;#34;
effect: &amp;#34;Allow&amp;#34;
actions:
- &amp;#34;s3:AbortMultipartUpload&amp;#34;
- &amp;#34;s3:DeleteObject&amp;#34;
- &amp;#34;s3:GetObject&amp;#34;
- &amp;#34;s3:ListMultipartUploadParts&amp;#34;
- &amp;#34;s3:PutObject&amp;#34;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This policy defines the actions in a fine granular way:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>To the bucket &lt;strong>my-bucket&lt;/strong> we have three allowed actions (GetBucketLocation, ListBucket and ListBucketMultipartUploads)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>To everything inside the bucket (/*) we can also Delete, Get, Put objects etc.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_creating_a_user">Creating a User&lt;/h3>
&lt;div class="paragraph">
&lt;p>The policy that has been created must be assigned to a user (or a group) to be effective. Such a user requires a username, a password and a list of policies that shall be assigned.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The required information can be added directly to the values file like this:&lt;/p>
&lt;/div>
&lt;div class="admonitionblock caution">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-caution" title="Caution">&lt;/i>
&lt;/td>
&lt;td class="content">
&lt;strong>This is NOT the recommended way!&lt;/strong>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> # users:
# - username: test-username &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
# password: test-password &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
# disabled: false &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
# policies: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
# - readwrite
# - consoleAdmin
# - diagnostics
# # When set to true, it will replace all policies with the specified.
# # When false, the policies will be added to the existing.
# setPolicies: false
# @default -- []&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Username&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>clear text password&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Shall the user be created or not&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>List of policies that shall be assigned&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>As mentioned above: Defining a list of users directly in the values file is &lt;strong>not recommended&lt;/strong> as it would mean that the passwords are stored in clear text.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Instead, a list of Secrets can be defined:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> usersExistingSecrets:
- minio-users&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The defined Secrets require a specific structure and can be encrypted and stored in Git or a Vault.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The data structure is the following:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
name: minio-users &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
type: Opaque
stringData:
username1: | &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
username=username &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
password=password &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
disabled=false &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
policies=openshift-logging-access-policy,readwrite,consoleAdmin,diagnostics &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
setPolicies=false &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the Secret as referenced in the values file.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>List of users, distinguished by the key &amp;#34;username1&amp;#34;, &amp;#34;username2&amp;#34;, etc.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Username&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Password&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Enabled or disabled&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>List of policies to assign to the user&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Replace or add the policies to an (existing) user.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_built_in_policies">Built-In Policies&lt;/h4>
&lt;div class="paragraph">
&lt;p>MinIO provides several &lt;a href="https://min.io/docs/minio/linux/administration/identity-access-management/policy-based-access-control.html#built-in-policies" target="_blank" rel="noopener">Built-In Policies&lt;/a> that can be attached to a user or group.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The following policies will always exist: (Please verify the official documentation for further information)&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>consoleAdmin&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants complete access to all S3 and administrative API operations against all resources on the MinIO deployment.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:*&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:*&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>readonly&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants read-only permissions on any object on the MinIO deployment. The GET action must apply to a specific object without requiring any listing.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:GetBucketLocation&lt;/p>
&lt;/li>
&lt;li>
&lt;p>s3:GetObject&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>readwrite&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants read and write permissions for all buckets and objects on the MinIO server.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:*&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>diagnostics&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants permission to perform diagnostic actions on the MinIO deployment.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>admin:ServerTrace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:Profiling&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:ConsoleLog&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:ServerInfo&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:TopLocksInfo&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:OBDInfo&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:BandwidthMonitor&lt;/p>
&lt;/li>
&lt;li>
&lt;p>admin:Prometheus&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>writeonly&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Grants write-only permissions to any namespace (bucket and path to object) the MinIO deployment.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>s3:PutObject&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_provisioning_groups">Provisioning Groups&lt;/h3>
&lt;div class="paragraph">
&lt;p>Users can be combined into groups and instead of assigning policies to individual users, we can assign them to a whole group.
The idea is the same as for users, except, that we define a list of members for that group:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> groups
- name: test-group &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
disabled: false &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
members: &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
- username
policies: &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
- readwrite
# When set to true, it will replace all policies with the specified.
# When false, the policies will be added to the existing.
setPolicies: false &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Enabled or disabled.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>List of users that are members of this group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>List of policies that are assigned to this group.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Replace or add the policies to an (existing) user.&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configure_the_bucket">Configure the Bucket&lt;/h3>
&lt;div class="paragraph">
&lt;p>Finally, we can configure the bucket itself. A bucket will have a specific configuration, a lifecycle a quota etc.
A list of buckets with different configurations can be defined in the values files.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
The only mandatory information is the name of the bucket. It is not required to configure a lifecycle or quota etc.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Let us analyse the following example, which tries to cover all possible settings:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> buckets:
- name: mybucket &lt;i class="conum" data-value="1">&lt;/i>&lt;b>(1)&lt;/b>
region: my-region &lt;i class="conum" data-value="2">&lt;/i>&lt;b>(2)&lt;/b>
versioning: Versioned &lt;i class="conum" data-value="3">&lt;/i>&lt;b>(3)&lt;/b>
withLock: false &lt;i class="conum" data-value="4">&lt;/i>&lt;b>(4)&lt;/b>
bucketReplication: &lt;i class="conum" data-value="5">&lt;/i>&lt;b>(5)&lt;/b>
enabled: true
targetClusterUrl: replication-target-cluster
targetClusterPort: 443
targetBucket: replication-target-bucket
replicationSettings: &lt;i class="conum" data-value="6">&lt;/i>&lt;b>(6)&lt;/b>
- existing-objects
credSecretName: replication-credentials &lt;i class="conum" data-value="7">&lt;/i>&lt;b>(7)&lt;/b>
lifecycle:
- id: name-of-lifecycle &lt;i class="conum" data-value="8">&lt;/i>&lt;b>(8)&lt;/b>
prefix: test-prefix &lt;i class="conum" data-value="9">&lt;/i>&lt;b>(9)&lt;/b>
disabled: false
expiry: &lt;i class="conum" data-value="10">&lt;/i>&lt;b>(10)&lt;/b>
days: 30 # or date
nonconcurrentDays: 10
- id: name-of-second-lifecycle
disabled: false
expiry:
deleteMarker: true
nonconcurrentDays: 10
quota: &lt;i class="conum" data-value="11">&lt;/i>&lt;b>(11)&lt;/b>
type: set
size: 1024Gib
tags: &lt;i class="conum" data-value="12">&lt;/i>&lt;b>(12)&lt;/b>
key1: value1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="colist arabic">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td>&lt;i class="conum" data-value="1">&lt;/i>&lt;b>1&lt;/b>&lt;/td>
&lt;td>Name of the bucket.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="2">&lt;/i>&lt;b>2&lt;/b>&lt;/td>
&lt;td>Region of the bucket&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="3">&lt;/i>&lt;b>3&lt;/b>&lt;/td>
&lt;td>Enable versioning (&lt;a href="https://docs.min.io/docs/minio-client-complete-guide.html#ilm" class="bare">https://docs.min.io/docs/minio-client-complete-guide.html#ilm&lt;/a>). Allowed options are: Versioned, Suspended or Unchanged.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="4">&lt;/i>&lt;b>4&lt;/b>&lt;/td>
&lt;td>Enable object Locking&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="5">&lt;/i>&lt;b>5&lt;/b>&lt;/td>
&lt;td>Configure bucket replication to a target cluster and a target bucket&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="6">&lt;/i>&lt;b>6&lt;/b>&lt;/td>
&lt;td>Define the settings for the bucket replication can be: delete, delete-marker or existing-objects: &lt;a href="https://min.io/docs/minio/linux/administration/bucket-replication/enable-server-side-one-way-bucket-replication.html" class="bare">https://min.io/docs/minio/linux/administration/bucket-replication/enable-server-side-one-way-bucket-replication.html&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="7">&lt;/i>&lt;b>7&lt;/b>&lt;/td>
&lt;td>Name of the Secret that stores the credentials for the replication&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="8">&lt;/i>&lt;b>8&lt;/b>&lt;/td>
&lt;td>Define a list of lifecycle policies for the bucket: &lt;a href="https://min.io/docs/minio/linux/administration/object-management/object-lifecycle-management.html" class="bare">https://min.io/docs/minio/linux/administration/object-management/object-lifecycle-management.html&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="9">&lt;/i>&lt;b>9&lt;/b>&lt;/td>
&lt;td>A prefix that can be defined&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="10">&lt;/i>&lt;b>10&lt;/b>&lt;/td>
&lt;td>Define the expiration. This can be defined as &lt;strong>days&lt;/strong> OR as a &lt;strong>date&lt;/strong>, for example &amp;#34;2021-11-11T00:00:00Z&amp;#34;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="11">&lt;/i>&lt;b>11&lt;/b>&lt;/td>
&lt;td>Set a quota for the bucket: &lt;a href="https://docs.min.io/docs/minio-admin-complete-guide.html#bucket" class="bare">https://docs.min.io/docs/minio-admin-complete-guide.html#bucket&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;i class="conum" data-value="12">&lt;/i>&lt;b>12&lt;/b>&lt;/td>
&lt;td>Define additional tags for the bucket &lt;a href="https://docs.min.io/docs/minio-client-complete-guide.html#tag" class="bare">https://docs.min.io/docs/minio-client-complete-guide.html#tag&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_replication_secret">Replication Secret&lt;/h4>
&lt;div class="paragraph">
&lt;p>The definition above defines a bucket replication. To authenticate at the target cluster, we need to provide a username and a password. This is stored inside a secret:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
name: replication-user
type: Opaque
stringData:
username: username
password: password&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>This defines a whole bunch of settings. Except for the bucket name, none is mandatory.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="_example_openshift_logging_bucket">Example OpenShift-Logging Bucket&lt;/h4>
&lt;div class="paragraph">
&lt;p>The following is a more realistic example, for defining a bucket used for OpenShift Logging:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It defines the bucket name, with a lifecycle of 4 days and a quota of 1TB:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> buckets:
- name: openshift-logging
lifecycle:
- id: logging-retention
disabled: false
expiry:
days: 4
quota:
type: set
size: 1024GiB&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_additional_settings">Additional Settings&lt;/h3>
&lt;div class="paragraph">
&lt;p>Finally, there are some additional settings, I would like to mention here. They are completely optional, but might be interesting:&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Automatically clean up the provisioning job after it has finished:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> cleanupAfterFinished:
enabled: false
seconds: 600&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Define resources for the provisioning job. For example:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml">resources:
requests:
cpu: 2
memory: 512Mi
limits:
cpu: 3
memory: 1024Mi&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-note" title="Note">&lt;/i>
&lt;/td>
&lt;td class="content">
Typically, I leave this to &lt;strong>resources: {}&lt;/strong>
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Take care of the pod placement and define a nodeSelector and tolerations, for example:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-yaml" data-lang="yaml"> nodeSelector: {}
tolerations:
- effect: NoSchedule
key: infra
operator: Equal
value: reserved
- effect: NoExecute
key: infra
operator: Equal
value: reserved&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_conclusion">Conclusion&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>With this Helm chart by Bitnami, with a little modification from my side, it is possible to &lt;strong>create and update&lt;/strong> buckets, policies, users etc. There is no need, to perform any modification manually in the MinIO WebUI.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I am currently using this chart for several bucket configurations, with sometimes more and sometimes fewer settings in the values file. Keep in mind, that many settings, especially for the bucket itself, are completely optional and are not required to create a new bucket. (For example, lifecycle). Please check out the source of the Helm Chart and the values file to get further information: &lt;a href="https://github.com/tjungbauer/helm-charts/tree/main/charts/minio-configurator" target="_blank" rel="noopener">minio configurator&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>If you have any feedback or miss something, feel free to create a pull request or an issue :)&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item></channel></rss>